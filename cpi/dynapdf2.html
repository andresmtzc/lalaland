<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF Template Editor</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=STIX+Two+Text:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

  <!-- html2pdf -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 16px;
      background: #1a1a2e;
      font-family: Arial, sans-serif;
      display: flex;
      gap: 16px;
      height: 100vh;
      overflow: hidden;
    }

    /* LEFT PANEL */
    .panel {
      width: 320px;
      background: #16213e;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .panel-header {
      padding: 12px 16px;
      background: #0f3460;
      color: #fff;
      font-weight: 600;
      font-size: 14px;
      border-bottom: 1px solid #1a1a2e;
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .section {
      margin-bottom: 16px;
      background: #0f3460;
      border-radius: 6px;
      padding: 12px;
    }

    .section-title {
      font-size: 11px;
      font-weight: 600;
      color: #e94560;
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    label {
      font-size: 11px;
      color: #aaa;
      display: block;
      margin-top: 8px;
      margin-bottom: 3px;
    }

    input, select, textarea {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #1a1a2e;
      border-radius: 4px;
      background: #16213e;
      color: #fff;
      font-size: 12px;
    }

    textarea {
      height: 60px;
      resize: none;
      font-family: monospace;
    }

    .row {
      display: flex;
      gap: 6px;
    }

    .row > * { flex: 1; }

    button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
    }

    .btn-primary {
      background: #e94560;
      color: #fff;
    }
    .btn-primary:hover { background: #ff6b6b; }

    .btn-secondary {
      background: #0f3460;
      color: #fff;
      border: 1px solid #e94560;
    }
    .btn-secondary:hover { background: #16213e; }

    .btn-small {
      padding: 4px 8px;
      font-size: 10px;
    }

    .btn-danger {
      background: #c0392b;
      color: #fff;
    }
    .btn-danger:hover { background: #e74c3c; }

    .style-row {
      display: flex;
      gap: 4px;
      margin-top: 6px;
    }

    .style-btn {
      flex: 1;
      padding: 6px;
      background: #16213e;
      color: #fff;
      border: 1px solid #0f3460;
    }

    .style-btn.active {
      background: #e94560;
      border-color: #e94560;
    }

    /* ELEMENT LIST */
    .element-list {
      max-height: 150px;
      overflow-y: auto;
    }

    .element-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 8px;
      background: #16213e;
      border-radius: 4px;
      margin-bottom: 4px;
      cursor: pointer;
      font-size: 11px;
      color: #fff;
    }

    .element-item:hover { background: #1a1a2e; }
    .element-item.selected { background: #e94560; }

    .element-item .delete-btn {
      background: transparent;
      color: #e94560;
      padding: 2px 6px;
    }
    .element-item.selected .delete-btn { color: #fff; }

    /* PLACEHOLDER LIST */
    .placeholder-list {
      max-height: 200px;
      overflow-y: auto;
      font-size: 10px;
    }

    .placeholder-item {
      padding: 4px 6px;
      background: #16213e;
      border-radius: 3px;
      margin-bottom: 2px;
      color: #4ecdc4;
      font-family: monospace;
      cursor: pointer;
    }

    .placeholder-item:hover { background: #1a1a2e; }

    /* CENTER - CANVAS AREA */
    .canvas-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 16px;
      background: #16213e;
      border-radius: 8px 8px 0 0;
    }

    .page-nav {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .page-nav button {
      background: #0f3460;
      color: #fff;
      padding: 6px 12px;
    }

    .page-nav span {
      color: #fff;
      font-size: 13px;
      min-width: 80px;
      text-align: center;
    }

    .toolbar-actions {
      display: flex;
      gap: 8px;
      margin-left: auto;
    }

    .canvas-wrapper {
      flex: 1;
      overflow: auto;
      background: #0f0f1a;
      padding: 20px;
      border-radius: 0 0 8px 8px;
    }

    /* PDF PAGE */
    .pdf-page {
      width: 1224px;
      height: 1584px;
      position: relative;
      background-size: cover;
      background-repeat: no-repeat;
      background-position: top left;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      margin: 0 auto;
    }

    /* TEXT BOX */
    .text-box {
      position: absolute;
      cursor: move;
      user-select: none;
      min-width: 20px;
      min-height: 20px;
    }

    .text-box.selected {
      outline: 2px dashed #e94560;
      outline-offset: 2px;
    }

    .text-box .resize-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #e94560;
      border-radius: 2px;
      display: none;
    }

    .text-box.selected .resize-handle { display: block; }

    .text-box .resize-handle.se { right: -5px; bottom: -5px; cursor: se-resize; }

    /* TABLE CONTAINER */
    .table-container {
      position: absolute;
    }

    .table-container.selected {
      outline: 2px dashed #e94560;
      outline-offset: 2px;
    }

    .table-drag-handle {
      height: 16px;
      background: #e94560;
      cursor: move;
      border-radius: 3px 3px 0 0;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .table-container.selected .table-drag-handle {
      display: flex;
    }

    .table-drag-handle::before {
      content: '‚ãÆ‚ãÆ';
      color: white;
      font-size: 10px;
      letter-spacing: 2px;
    }

    /* TABLE */
    .pdf-table {
      border-collapse: collapse;
    }

    .pdf-table td {
      border: 1px solid #000;
      padding: 4px 8px;
      min-width: 40px;
      min-height: 24px;
      position: relative;
      cursor: text;
    }

    .pdf-table td.cell-selected {
      background: rgba(233, 69, 96, 0.3) !important;
    }

    .pdf-table td[contenteditable="true"]:focus {
      outline: 2px solid #4ecdc4;
      outline-offset: -2px;
    }

    /* RIGHT PANEL - PROPERTIES */
    .properties-panel {
      width: 280px;
      background: #16213e;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* ZOOM INDICATOR */
    .zoom-control {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #fff;
      font-size: 12px;
    }

    .zoom-control input {
      width: 60px;
    }

    /* TABLE CONTROLS */
    .table-grid-input {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .table-grid-input input {
      width: 50px;
      text-align: center;
    }

    .table-grid-input span {
      color: #aaa;
    }

    /* COLOR INPUT ROW */
    .color-row {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .color-row input[type="color"] {
      width: 36px;
      height: 28px;
      padding: 0;
      border: none;
      cursor: pointer;
    }

    .color-row input[type="text"] {
      flex: 1;
      font-family: monospace;
    }

    /* IMAGE CONTAINER */
    .image-box {
      position: absolute;
      cursor: move;
      user-select: none;
      min-width: 50px;
      min-height: 50px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }

    .image-box.selected {
      outline: 2px dashed #4ecdc4;
      outline-offset: 2px;
    }

    .image-box .resize-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #4ecdc4;
      border-radius: 2px;
      display: none;
    }

    .image-box.selected .resize-handle { display: block; }

    .image-box .resize-handle.se { right: -6px; bottom: -6px; cursor: se-resize; }
    .image-box .resize-handle.sw { left: -6px; bottom: -6px; cursor: sw-resize; }
    .image-box .resize-handle.ne { right: -6px; top: -6px; cursor: ne-resize; }
    .image-box .resize-handle.nw { left: -6px; top: -6px; cursor: nw-resize; }

    .image-box .image-label {
      position: absolute;
      top: -20px;
      left: 0;
      font-size: 10px;
      color: #4ecdc4;
      background: rgba(0,0,0,0.7);
      padding: 2px 6px;
      border-radius: 3px;
      white-space: nowrap;
      display: none;
    }

    .image-box.selected .image-label { display: block; }

    /* INSTRUCTIONS */
    .instructions {
      padding: 12px;
      background: #0f3460;
      border-radius: 6px;
      font-size: 10px;
      color: #aaa;
      line-height: 1.5;
    }

    .instructions strong {
      color: #e94560;
    }

    .instructions kbd {
      background: #1a1a2e;
      padding: 2px 4px;
      border-radius: 3px;
      font-family: monospace;
    }
  </style>
</head>

<body>

<!-- LEFT PANEL: Elements & Placeholders -->
<div class="panel">
  <div class="panel-header">Elements</div>
  <div class="panel-content">

    <div class="section">
      <div class="section-title">Add Elements</div>
      <div class="row">
        <button class="btn-primary" onclick="addTextBox()">+ Text</button>
        <button class="btn-primary" onclick="addTable()">+ Table</button>
        <button class="btn-primary" onclick="addImage()">+ Image</button>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Text Boxes (Page <span id="textBoxPageNum">1</span>)</div>
      <div class="element-list" id="textBoxList"></div>
    </div>

    <div class="section">
      <div class="section-title">Tables (Page <span id="tablePageNum">1</span>)</div>
      <div class="element-list" id="tableList"></div>
    </div>

    <div class="section">
      <div class="section-title">Images (Page <span id="imagePageNum">1</span>)</div>
      <div class="element-list" id="imageList"></div>
    </div>

    <div class="section">
      <div class="section-title">Placeholders</div>
      <div class="placeholder-list">
        <div class="placeholder-item" onclick="insertPlaceholder('{{dynamicText}}')">{{dynamicText}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.number}}')">{{lot.number}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.category}}')">{{lot.category}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.size}}')">{{lot.size}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.pricePerM2}}')">{{lot.pricePerM2}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.totalPrice}}')">{{lot.totalPrice}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.downpayment25}}')">{{lot.downpayment25}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.downpayment50}}')">{{lot.downpayment50}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.downpayment85}}')">{{lot.downpayment85}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.monthly25}}')">{{lot.monthly25}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.discount0}}')">{{lot.discount0}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.discount5}}')">{{lot.discount5}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.discount12}}')">{{lot.discount12}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.priceWith5Discount}}')">{{lot.priceWith5Discount}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.priceWith12Discount}}')">{{lot.priceWith12Discount}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.contraEscritura30}}')">{{lot.contraEscritura30}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.contraEscritura50}}')">{{lot.contraEscritura50}}</div>
        <div class="placeholder-item" onclick="insertPlaceholder('{{lot.contraEscritura15}}')">{{lot.contraEscritura15}}</div>
      </div>
    </div>

    <div class="section instructions">
      <strong>Tips:</strong><br>
      <kbd>Click</kbd> to select element<br>
      <kbd>Shift+Click</kbd> cells to multi-select<br>
      <kbd>Delete</kbd> to remove selected<br>
      <kbd>Drag</kbd> text boxes to move<br>
      <kbd>Drag handle</kbd> (pink bar) to move tables
    </div>
  </div>
</div>

<!-- CENTER: Canvas -->
<div class="canvas-area">
  <div class="toolbar">
    <div class="page-nav">
      <button onclick="prevPage()">&#9664;</button>
      <span id="pageIndicator">Page 1 / 8</span>
      <button onclick="nextPage()">&#9654;</button>
    </div>

    <div class="zoom-control">
      <label style="margin: 0; color: #aaa;">Zoom:</label>
      <input type="range" id="zoomSlider" min="25" max="100" value="50" oninput="setZoom(this.value)">
      <span id="zoomValue">50%</span>
    </div>

    <div class="zoom-control">
      <label style="margin: 0; color: #aaa;">Preview Lot:</label>
      <input type="text" id="previewLot" value="001" style="width: 60px; text-align: center;" oninput="updatePreviewImages()">
    </div>

    <div class="toolbar-actions">
      <button class="btn-secondary" onclick="undo()" title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
      <button class="btn-secondary" onclick="loadTemplate()">Load JSON</button>
      <button class="btn-primary" onclick="saveTemplate()">Save JSON</button>
      <button class="btn-primary" onclick="exportPDF()">Export PDF</button>
    </div>
  </div>

  <div class="canvas-wrapper" id="canvasWrapper">
    <div class="pdf-page" id="pdfPage"></div>
  </div>
</div>

<!-- RIGHT PANEL: Properties -->
<div class="properties-panel">
  <div class="panel-header">Properties</div>
  <div class="panel-content">

    <!-- Text Box Properties -->
    <div id="textBoxProps" style="display: none;">
      <div class="section">
        <div class="section-title">Text Box</div>

        <label>Content</label>
        <textarea id="prop_text" oninput="updateSelectedTextBox()"></textarea>

        <div class="row">
          <div>
            <label>Font Size</label>
            <input type="number" id="prop_fontSize" value="24" min="6" max="200" oninput="updateSelectedTextBox()">
          </div>
          <div>
            <label>Font</label>
            <select id="prop_fontFamily" onchange="updateSelectedTextBox()">
              <option value="STIX Two Text">STIX Two Text</option>
              <option value="Arial">Arial</option>
              <option value="Georgia">Georgia</option>
              <option value="Times New Roman">Times New Roman</option>
            </select>
          </div>
        </div>

        <label>Style</label>
        <div class="style-row">
          <button class="style-btn" id="prop_bold" onclick="toggleStyle('bold')">B</button>
          <button class="style-btn" id="prop_italic" onclick="toggleStyle('italic')">I</button>
          <button class="style-btn" id="prop_underline" onclick="toggleStyle('underline')">U</button>
        </div>

        <label>Text Color</label>
        <div class="color-row">
          <input type="color" id="prop_color" value="#000000" oninput="updateSelectedTextBox()">
          <input type="text" id="prop_colorHex" value="#000000" oninput="syncColorFromHex()">
        </div>

        <label>Text Align</label>
        <div class="style-row">
          <button class="style-btn" id="prop_alignLeft" onclick="setTextAlign('left')">L</button>
          <button class="style-btn" id="prop_alignCenter" onclick="setTextAlign('center')">C</button>
          <button class="style-btn" id="prop_alignRight" onclick="setTextAlign('right')">R</button>
        </div>

        <div class="row">
          <div>
            <label>X Position</label>
            <input type="number" id="prop_x" oninput="updateSelectedTextBox()">
          </div>
          <div>
            <label>Y Position</label>
            <input type="number" id="prop_y" oninput="updateSelectedTextBox()">
          </div>
        </div>

        <div class="row">
          <div>
            <label>Width</label>
            <input type="number" id="prop_width" oninput="updateSelectedTextBox()">
          </div>
          <div>
            <label>Height</label>
            <input type="number" id="prop_height" placeholder="auto" oninput="updateSelectedTextBox()">
          </div>
        </div>

        <label style="margin-top: 12px;"></label>
        <button class="btn-danger" onclick="deleteSelected()" style="width: 100%;">Delete Text Box</button>
      </div>
    </div>

    <!-- Table Properties -->
    <div id="tableProps" style="display: none;">
      <div class="section">
        <div class="section-title">Table</div>

        <label>Dimensions</label>
        <div class="table-grid-input">
          <input type="number" id="prop_rows" value="3" min="1" max="20">
          <span>x</span>
          <input type="number" id="prop_cols" value="3" min="1" max="10">
          <button class="btn-small btn-secondary" onclick="resizeTable()">Apply</button>
        </div>

        <div class="row">
          <div>
            <label>X Position</label>
            <input type="number" id="prop_tableX" oninput="updateSelectedTable()">
          </div>
          <div>
            <label>Y Position</label>
            <input type="number" id="prop_tableY" oninput="updateSelectedTable()">
          </div>
        </div>

        <button class="btn-secondary" onclick="centerTableHorizontally()" style="width: 100%; margin-top: 8px;">Center Horizontally</button>

        <label style="margin-top: 12px;"></label>
        <button class="btn-danger" onclick="deleteSelected()" style="width: 100%;">Delete Table</button>
      </div>

      <div class="section">
        <div class="section-title">Column Widths (px)</div>
        <div id="colWidthsContainer" style="display: flex; flex-direction: column; gap: 4px;"></div>
      </div>

      <div class="section">
        <div class="section-title">Row Heights (px)</div>
        <div id="rowHeightsContainer" style="display: flex; flex-direction: column; gap: 4px;"></div>
      </div>

      <div class="section">
        <div class="section-title">Cell Properties</div>
        <p style="font-size: 10px; color: #aaa; margin: 0 0 8px 0;">Select cells with Shift+Click</p>

        <label>Cell Background</label>
        <div class="color-row">
          <input type="color" id="prop_cellBg" value="#ffffff" oninput="updateCellProp('bgColor')">
          <input type="text" id="prop_cellBgHex" value="#ffffff" oninput="syncCellBgFromHex()">
        </div>

        <label>Cell Text Color</label>
        <div class="color-row">
          <input type="color" id="prop_cellColor" value="#000000" oninput="updateCellProp('textColor')">
          <input type="text" id="prop_cellColorHex" value="#000000" oninput="syncCellColorFromHex()">
        </div>

        <label>Font Family</label>
        <select id="prop_cellFontFamily" onchange="updateCellProp('fontFamily')">
          <option value="Arial">Arial</option>
          <option value="STIX Two Text">STIX Two Text</option>
          <option value="Georgia">Georgia</option>
          <option value="Times New Roman">Times New Roman</option>
        </select>

        <label>Font Size</label>
        <input type="number" id="prop_cellFontSize" value="14" min="6" max="72" oninput="updateCellProp('fontSize')">

        <label>Text Style</label>
        <div class="style-row">
          <button class="style-btn" id="prop_cellBold" onclick="toggleCellStyle('bold')"><b>B</b></button>
          <button class="style-btn" id="prop_cellItalic" onclick="toggleCellStyle('italic')"><i>I</i></button>
          <button class="style-btn" id="prop_cellUnderline" onclick="toggleCellStyle('underline')"><u>U</u></button>
        </div>

        <label>Border Color</label>
        <div class="color-row">
          <input type="color" id="prop_cellBorder" value="#000000" oninput="updateCellProp('borderColor')">
          <input type="text" id="prop_cellBorderHex" value="#000000" oninput="syncCellBorderFromHex()">
        </div>

        <label>Border Width</label>
        <input type="number" id="prop_cellBorderWidth" value="1" min="0" max="5" oninput="updateCellProp('borderWidth')">

        <label>Border Style</label>
        <select id="prop_cellBorderStyle" onchange="updateCellProp('borderStyle')">
          <option value="solid">Solid</option>
          <option value="dashed">Dashed</option>
          <option value="none">None</option>
        </select>

        <label>Border Position</label>
        <select id="prop_cellBorderPosition" onchange="updateCellProp('borderPosition')">
          <option value="all">All Sides</option>
          <option value="top">Top Only</option>
          <option value="bottom">Bottom Only</option>
        </select>

        <label>Text Align</label>
        <div class="style-row">
          <button class="style-btn" id="prop_cellAlignLeft" onclick="setCellAlign('left')">L</button>
          <button class="style-btn" id="prop_cellAlignCenter" onclick="setCellAlign('center')">C</button>
          <button class="style-btn" id="prop_cellAlignRight" onclick="setCellAlign('right')">R</button>
        </div>

        <label style="margin-top: 12px;">Insert Column</label>
        <div class="row">
          <button class="btn-secondary" onclick="insertColumn('left')">‚Üê Left</button>
          <button class="btn-secondary" onclick="insertColumn('right')">Right ‚Üí</button>
        </div>

        <label>Insert Row</label>
        <div class="row">
          <button class="btn-secondary" onclick="insertRow('above')">‚Üë Above</button>
          <button class="btn-secondary" onclick="insertRow('below')">Below ‚Üì</button>
        </div>

        <label style="margin-top: 12px;"></label>
        <div class="row">
          <button class="btn-secondary" onclick="mergeCells()">Merge Cells</button>
          <button class="btn-secondary" onclick="unmergeCells()">Unmerge</button>
        </div>
      </div>
    </div>

    <!-- Image Properties -->
    <div id="imageProps" style="display: none;">
      <div class="section">
        <div class="section-title">Image</div>

        <label>Image Type</label>
        <select id="prop_imageType" onchange="updateSelectedImage()">
          <option value="static">Static Image</option>
          <option value="{{lot.landscape}}">{{lot.landscape}}</option>
          <option value="{{lot.map}}">{{lot.map}}</option>
        </select>

        <div id="staticImageUrlGroup">
          <label>Image URL</label>
          <input type="text" id="prop_imageUrl" placeholder="https://..." oninput="updateSelectedImage()">
        </div>

        <div class="row">
          <div>
            <label>X Position</label>
            <input type="number" id="prop_imageX" oninput="updateSelectedImage()">
          </div>
          <div>
            <label>Y Position</label>
            <input type="number" id="prop_imageY" oninput="updateSelectedImage()">
          </div>
        </div>

        <div class="row">
          <div>
            <label>Width</label>
            <input type="number" id="prop_imageWidth" oninput="updateSelectedImage()">
          </div>
          <div>
            <label>Height</label>
            <input type="number" id="prop_imageHeight" oninput="updateSelectedImage()">
          </div>
        </div>

        <label>Aspect Ratio</label>
        <div class="style-row">
          <button class="style-btn active" id="prop_lockAspect" onclick="toggleAspectLock()">üîí Locked</button>
        </div>
        <p style="font-size: 9px; color: #aaa; margin: 4px 0 0 0;">Hold Shift while resizing to freely adjust</p>

        <label style="margin-top: 12px;"></label>
        <button class="btn-danger" onclick="deleteSelected()" style="width: 100%;">Delete Image</button>
      </div>
    </div>

    <!-- No Selection -->
    <div id="noSelectionProps">
      <div class="section">
        <p style="color: #aaa; font-size: 12px; margin: 0; text-align: center;">
          Select an element to edit its properties
        </p>
      </div>
    </div>

  </div>
</div>

<!-- Hidden file input for loading -->
<input type="file" id="fileInput" accept=".json" style="display: none;" onchange="handleFileLoad(event)">

<script>
// ===== STATE =====
let currentPage = 1;
const totalPages = 8;
let selectedElement = null;
let selectedCells = [];
let elementIdCounter = 0;

// Undo history
const undoHistory = [];
const MAX_UNDO_HISTORY = 50;

// Template data: pages[pageNum] = { textBoxes: [], tables: [] }
const template = {
  pages: {}
};

// Initialize empty pages
for (let i = 1; i <= totalPages; i++) {
  template.pages[i] = { textBoxes: [], tables: [], images: [] };
}

// ===== INIT =====
function init() {
  renderPage();
  updateElementLists();
  setZoom(50);
  setupPositionScrollWheels();
}

// ===== UNDO =====
function saveState() {
  // Deep clone the current template state
  const state = JSON.stringify(template);
  undoHistory.push(state);

  // Limit history size
  if (undoHistory.length > MAX_UNDO_HISTORY) {
    undoHistory.shift();
  }
}

function undo() {
  if (undoHistory.length === 0) return;

  // Pop the last state
  const previousState = undoHistory.pop();
  const restored = JSON.parse(previousState);

  // Restore the template
  template.pages = restored.pages;

  // Re-render
  clearSelection();
  renderPage();
  updateElementLists();
}

// ===== PAGE NAVIGATION =====
function renderPage() {
  const page = document.getElementById('pdfPage');
  const pageNum = String(currentPage).padStart(3, '0');
  page.style.backgroundImage = `url("https://la-la.land/cpi/pdf/page.${pageNum}.png")`;

  // Clear and re-render elements
  page.innerHTML = '';

  const pageData = template.pages[currentPage];

  // Render text boxes
  pageData.textBoxes.forEach(tb => {
    const el = createTextBoxElement(tb);
    page.appendChild(el);
  });

  // Render tables
  pageData.tables.forEach(t => {
    const el = createTableElement(t);
    page.appendChild(el);
  });

  // Render images
  pageData.images.forEach(img => {
    const el = createImageElement(img);
    page.appendChild(el);
  });

  document.getElementById('pageIndicator').textContent = `Page ${currentPage} / ${totalPages}`;
  document.getElementById('textBoxPageNum').textContent = currentPage;
  document.getElementById('tablePageNum').textContent = currentPage;
  document.getElementById('imagePageNum').textContent = currentPage;

  updateElementLists();
  clearSelection();
}

function prevPage() {
  if (currentPage > 1) {
    currentPage--;
    renderPage();
  }
}

function nextPage() {
  if (currentPage < totalPages) {
    currentPage++;
    renderPage();
  }
}

// ===== ZOOM =====
function setZoom(value) {
  const page = document.getElementById('pdfPage');
  const scale = value / 100;
  page.style.transform = `scale(${scale})`;
  page.style.transformOrigin = 'top left';
  document.getElementById('zoomValue').textContent = value + '%';
}

// ===== TEXT BOX =====
function addTextBox() {
  const id = 'tb_' + (++elementIdCounter);
  const textBox = {
    id,
    content: 'New Text',
    x: 100,
    y: 100,
    width: 200,
    height: null,
    fontSize: 24,
    fontFamily: 'Arial',
    color: '#000000',
    bold: false,
    italic: false,
    underline: false,
    textAlign: 'left'
  };

  template.pages[currentPage].textBoxes.push(textBox);
  renderPage();

  // Select the new element
  setTimeout(() => {
    const el = document.getElementById(id);
    if (el) selectElement(el, 'textbox');
  }, 10);
}

function createTextBoxElement(data) {
  const div = document.createElement('div');
  div.className = 'text-box';
  div.id = data.id;
  div.dataset.type = 'textbox';

  div.style.left = data.x + 'px';
  div.style.top = data.y + 'px';
  if (data.width) div.style.width = data.width + 'px';
  if (data.height) div.style.height = data.height + 'px';
  div.style.fontSize = data.fontSize + 'px';
  div.style.fontFamily = data.fontFamily;
  div.style.color = data.color;
  div.style.fontWeight = data.bold ? '700' : '400';
  div.style.fontStyle = data.italic ? 'italic' : 'normal';
  div.style.textDecoration = data.underline ? 'underline' : 'none';
  div.style.textAlign = data.textAlign || 'left';
  div.style.whiteSpace = 'pre-wrap';

  div.textContent = data.content;

  // Resize handle
  const handle = document.createElement('div');
  handle.className = 'resize-handle se';
  div.appendChild(handle);

  // Events
  div.addEventListener('mousedown', (e) => {
    if (e.target === handle) {
      startResize(e, div, data);
    } else {
      selectElement(div, 'textbox');
      startDrag(e, div, data);
    }
  });

  return div;
}

function updateSelectedTextBox() {
  if (!selectedElement || selectedElement.dataset.type !== 'textbox') return;

  const data = getTextBoxData(selectedElement.id);
  if (!data) return;

  data.content = document.getElementById('prop_text').value;
  data.fontSize = parseInt(document.getElementById('prop_fontSize').value) || 24;
  data.fontFamily = document.getElementById('prop_fontFamily').value;
  data.color = document.getElementById('prop_color').value;
  data.x = parseInt(document.getElementById('prop_x').value) || 0;
  data.y = parseInt(document.getElementById('prop_y').value) || 0;
  data.width = parseInt(document.getElementById('prop_width').value) || null;
  data.height = parseInt(document.getElementById('prop_height').value) || null;

  // Update hex display
  document.getElementById('prop_colorHex').value = data.color.toUpperCase();

  // Apply to element
  applyTextBoxStyles(selectedElement, data);
}

function applyTextBoxStyles(el, data) {
  el.style.left = data.x + 'px';
  el.style.top = data.y + 'px';
  if (data.width) el.style.width = data.width + 'px';
  if (data.height) el.style.height = data.height + 'px';
  el.style.fontSize = data.fontSize + 'px';
  el.style.fontFamily = data.fontFamily;
  el.style.color = data.color;
  el.style.fontWeight = data.bold ? '700' : '400';
  el.style.fontStyle = data.italic ? 'italic' : 'normal';
  el.style.textDecoration = data.underline ? 'underline' : 'none';
  el.style.textAlign = data.textAlign || 'left';

  // Update text content (preserve the resize handle)
  const handle = el.querySelector('.resize-handle');
  el.textContent = data.content;
  if (handle) el.appendChild(handle);
}

function toggleStyle(style) {
  if (!selectedElement || selectedElement.dataset.type !== 'textbox') return;

  const data = getTextBoxData(selectedElement.id);
  if (!data) return;

  const btn = document.getElementById('prop_' + style);

  if (style === 'bold') {
    data.bold = !data.bold;
  } else if (style === 'italic') {
    data.italic = !data.italic;
  } else if (style === 'underline') {
    data.underline = !data.underline;
  }

  btn.classList.toggle('active', data[style]);
  applyTextBoxStyles(selectedElement, data);
}

function setTextAlign(align) {
  if (!selectedElement || selectedElement.dataset.type !== 'textbox') return;

  const data = getTextBoxData(selectedElement.id);
  if (!data) return;

  data.textAlign = align;

  document.getElementById('prop_alignLeft').classList.toggle('active', align === 'left');
  document.getElementById('prop_alignCenter').classList.toggle('active', align === 'center');
  document.getElementById('prop_alignRight').classList.toggle('active', align === 'right');

  applyTextBoxStyles(selectedElement, data);
}

function syncColorFromHex() {
  const hex = document.getElementById('prop_colorHex').value;
  if (/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
    document.getElementById('prop_color').value = hex;
    updateSelectedTextBox();
  }
}

function getTextBoxData(id) {
  return template.pages[currentPage].textBoxes.find(tb => tb.id === id);
}

// ===== TABLE =====
function addTable() {
  const id = 'table_' + (++elementIdCounter);
  const rows = 3;
  const cols = 3;

  // Create cells data
  const cells = [];
  for (let r = 0; r < rows; r++) {
    const row = [];
    for (let c = 0; c < cols; c++) {
      row.push({
        content: '',
        bgColor: '#ffffff',
        textColor: '#000000',
        fontSize: 14,
        borderColor: '#000000',
        borderWidth: 1,
        padding: 4,
        textAlign: 'left',
        colSpan: 1,
        rowSpan: 1
      });
    }
    cells.push(row);
  }

  // Default column widths and row heights (in px)
  const colWidths = Array(cols).fill(100);  // 100px per column default
  const rowHeights = Array(rows).fill(30);  // 30px per row default

  const table = {
    id,
    x: 100,
    y: 100,
    rows,
    cols,
    cells,
    colWidths,
    rowHeights
  };

  template.pages[currentPage].tables.push(table);
  renderPage();

  setTimeout(() => {
    const el = document.getElementById(id);
    if (el) selectElement(el, 'table');
  }, 10);
}

function createTableElement(data) {
  // Create container for table + drag handle
  const container = document.createElement('div');
  container.className = 'table-container';
  container.id = data.id;
  container.dataset.type = 'table';

  container.style.left = data.x + 'px';
  container.style.top = data.y + 'px';

  // Drag handle
  const dragHandle = document.createElement('div');
  dragHandle.className = 'table-drag-handle';
  dragHandle.addEventListener('mousedown', (e) => {
    e.preventDefault();
    selectElement(container, 'table');
    startDrag(e, container, data);
  });
  container.appendChild(dragHandle);

  // Table element
  const table = document.createElement('table');
  table.className = 'pdf-table';
  table.style.tableLayout = 'fixed';  // Enforce exact column widths
  table.style.borderCollapse = 'collapse';

  // Calculate total table width from column widths
  const colWidths = data.colWidths || Array(data.cols).fill(100);
  const rowHeights = data.rowHeights || Array(data.rows).fill(30);
  const totalWidth = colWidths.reduce((sum, w) => sum + w, 0);
  table.style.width = totalWidth + 'px';

  // Build table cells
  for (let r = 0; r < data.rows; r++) {
    const tr = document.createElement('tr');
    tr.style.height = rowHeights[r] + 'px';
    for (let c = 0; c < data.cols; c++) {
      const cellData = data.cells[r]?.[c];
      if (!cellData || cellData.hidden) continue;

      const td = document.createElement('td');
      td.dataset.row = r;
      td.dataset.col = c;
      td.contentEditable = true;
      td.textContent = cellData.content || '';

      // Apply explicit column width and row height
      td.style.width = colWidths[c] + 'px';
      td.style.height = rowHeights[r] + 'px';
      td.style.boxSizing = 'border-box';
      td.style.overflow = 'hidden';
      td.style.whiteSpace = 'nowrap';  // Prevent long placeholders from wrapping
      td.style.textOverflow = 'clip';

      // Apply cell styles
      td.style.backgroundColor = cellData.bgColor || '#ffffff';
      td.style.color = cellData.textColor || '#000000';
      td.style.fontFamily = cellData.fontFamily || 'Arial';
      td.style.fontSize = (cellData.fontSize || 14) + 'px';
      td.style.fontWeight = cellData.bold ? '700' : '400';
      td.style.fontStyle = cellData.italic ? 'italic' : 'normal';
      td.style.textDecoration = cellData.underline ? 'underline' : 'none';

      // Apply border based on position and style
      const borderWidth = cellData.borderWidth || 1;
      const borderStyle = cellData.borderStyle || 'solid';
      const borderColor = cellData.borderColor || '#000000';
      const borderPosition = cellData.borderPosition || 'all';

      if (borderPosition === 'bottom') {
        td.style.border = 'none';
        td.style.borderBottom = `${borderWidth}px ${borderStyle} ${borderColor}`;
      } else if (borderPosition === 'top') {
        td.style.border = 'none';
        td.style.borderTop = `${borderWidth}px ${borderStyle} ${borderColor}`;
      } else {
        td.style.border = `${borderWidth}px ${borderStyle} ${borderColor}`;
      }

      td.style.padding = '0';
      td.style.textAlign = cellData.textAlign || 'left';
      td.style.verticalAlign = 'middle';

      if (cellData.colSpan > 1) td.colSpan = cellData.colSpan;
      if (cellData.rowSpan > 1) td.rowSpan = cellData.rowSpan;

      // Cell selection with shift
      td.addEventListener('mousedown', (e) => {
        e.stopPropagation();

        // Check if this table is already selected
        const isTableSelected = selectedElement === container;

        if (e.shiftKey && isTableSelected) {
          // Add/remove from multi-selection
          td.classList.toggle('cell-selected');
          if (td.classList.contains('cell-selected')) {
            selectedCells.push({ row: r, col: c, element: td });
          } else {
            selectedCells = selectedCells.filter(sc => !(sc.row === r && sc.col === c));
          }
        } else {
          // New selection - clear others first
          document.querySelectorAll('.cell-selected').forEach(c => c.classList.remove('cell-selected'));
          selectedCells = [{ row: r, col: c, element: td }];
          td.classList.add('cell-selected');
        }

        // Load cell properties into panel
        loadCellProps(cellData);

        // Select table without clearing cell selection
        if (!isTableSelected) {
          selectElement(container, 'table', true); // preserveCells = true
        }
      });

      // Save cell content on blur
      td.addEventListener('blur', () => {
        if (data.cells[r]?.[c]) {
          data.cells[r][c].content = td.textContent;
        }
      });

      tr.appendChild(td);
    }
    table.appendChild(tr);
  }

  container.appendChild(table);
  return container;
}

function updateSelectedTable() {
  if (!selectedElement || selectedElement.dataset.type !== 'table') return;

  const data = getTableData(selectedElement.id);
  if (!data) return;

  data.x = parseInt(document.getElementById('prop_tableX').value) || 0;
  data.y = parseInt(document.getElementById('prop_tableY').value) || 0;

  selectedElement.style.left = data.x + 'px';
  selectedElement.style.top = data.y + 'px';
}

function centerTableHorizontally() {
  if (!selectedElement || selectedElement.dataset.type !== 'table') return;

  const data = getTableData(selectedElement.id);
  if (!data) return;

  const pageWidth = 1224;  // PDF page width in px
  const colWidths = data.colWidths || Array(data.cols).fill(100);
  const tableWidth = colWidths.reduce((sum, w) => sum + w, 0);

  data.x = Math.round((pageWidth - tableWidth) / 2);
  document.getElementById('prop_tableX').value = data.x;
  selectedElement.style.left = data.x + 'px';
}

// Setup scroll wheel on X/Y position inputs
function setupPositionScrollWheels() {
  const xInput = document.getElementById('prop_tableX');
  const yInput = document.getElementById('prop_tableY');

  xInput.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = e.deltaY > 0 ? -10 : 10;  // Scroll down = decrease, up = increase
    xInput.value = (parseInt(xInput.value) || 0) + delta;
    updateSelectedTable();
  });

  yInput.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = e.deltaY > 0 ? -10 : 10;
    yInput.value = (parseInt(yInput.value) || 0) + delta;
    updateSelectedTable();
  });
}

function resizeTable() {
  if (!selectedElement || selectedElement.dataset.type !== 'table') return;

  const data = getTableData(selectedElement.id);
  if (!data) return;

  const newRows = parseInt(document.getElementById('prop_rows').value) || 3;
  const newCols = parseInt(document.getElementById('prop_cols').value) || 3;

  // Resize cells array
  while (data.cells.length < newRows) {
    const row = [];
    for (let c = 0; c < newCols; c++) {
      row.push(createDefaultCell());
    }
    data.cells.push(row);
  }
  data.cells.length = newRows;

  data.cells.forEach(row => {
    while (row.length < newCols) {
      row.push(createDefaultCell());
    }
    row.length = newCols;
  });

  // Resize colWidths array
  if (!data.colWidths) data.colWidths = [];
  while (data.colWidths.length < newCols) {
    data.colWidths.push(100);  // Default 100px for new columns
  }
  data.colWidths.length = newCols;

  // Resize rowHeights array
  if (!data.rowHeights) data.rowHeights = [];
  while (data.rowHeights.length < newRows) {
    data.rowHeights.push(30);  // Default 30px for new rows
  }
  data.rowHeights.length = newRows;

  data.rows = newRows;
  data.cols = newCols;

  renderPage();

  setTimeout(() => {
    const el = document.getElementById(data.id);
    if (el) selectElement(el, 'table');
  }, 10);
}

function createDefaultCell() {
  return {
    content: '',
    bgColor: '#ffffff',
    textColor: '#000000',
    fontFamily: 'Arial',
    fontSize: 14,
    bold: false,
    italic: false,
    underline: false,
    borderColor: '#000000',
    borderWidth: 1,
    borderStyle: 'solid',
    borderPosition: 'all',
    textAlign: 'left',
    colSpan: 1,
    rowSpan: 1
  };
}

// Update only a specific cell property (preserves other properties)
function updateCellProp(propName) {
  if (!selectedElement || selectedElement.dataset.type !== 'table') return;

  const data = getTableData(selectedElement.id);
  if (!data) return;

  // Get the new value based on property name
  let newValue;
  switch (propName) {
    case 'bgColor':
      newValue = document.getElementById('prop_cellBg').value;
      document.getElementById('prop_cellBgHex').value = newValue.toUpperCase();
      break;
    case 'textColor':
      newValue = document.getElementById('prop_cellColor').value;
      document.getElementById('prop_cellColorHex').value = newValue.toUpperCase();
      break;
    case 'fontFamily':
      newValue = document.getElementById('prop_cellFontFamily').value;
      break;
    case 'fontSize':
      newValue = parseInt(document.getElementById('prop_cellFontSize').value) || 14;
      break;
    case 'borderColor':
      newValue = document.getElementById('prop_cellBorder').value;
      document.getElementById('prop_cellBorderHex').value = newValue.toUpperCase();
      break;
    case 'borderWidth':
      newValue = parseInt(document.getElementById('prop_cellBorderWidth').value) || 1;
      break;
    case 'borderStyle':
      newValue = document.getElementById('prop_cellBorderStyle').value;
      break;
    case 'borderPosition':
      newValue = document.getElementById('prop_cellBorderPosition').value;
      break;
    default:
      return;
  }

  selectedCells.forEach(({ row, col, element }) => {
    const cellData = data.cells[row]?.[col];
    if (cellData) {
      // Update only the specific property
      cellData[propName] = newValue;

      // Apply visual update to element
      applyStylesToCell(element, cellData);
    }
  });
}

// Apply all styles from cellData to element
function applyStylesToCell(element, cellData) {
  element.style.backgroundColor = cellData.bgColor || '#ffffff';
  element.style.color = cellData.textColor || '#000000';
  element.style.fontFamily = cellData.fontFamily || 'Arial';
  element.style.fontSize = (cellData.fontSize || 14) + 'px';
  element.style.fontWeight = cellData.bold ? '700' : '400';
  element.style.fontStyle = cellData.italic ? 'italic' : 'normal';
  element.style.textDecoration = cellData.underline ? 'underline' : 'none';
  element.style.padding = '0';
  element.style.verticalAlign = 'middle';

  const borderWidth = cellData.borderWidth || 1;
  const borderStyle = cellData.borderStyle || 'solid';
  const borderColor = cellData.borderColor || '#000000';
  const borderPosition = cellData.borderPosition || 'all';

  if (borderPosition === 'bottom') {
    element.style.border = 'none';
    element.style.borderBottom = `${borderWidth}px ${borderStyle} ${borderColor}`;
  } else if (borderPosition === 'top') {
    element.style.border = 'none';
    element.style.borderTop = `${borderWidth}px ${borderStyle} ${borderColor}`;
  } else {
    element.style.border = `${borderWidth}px ${borderStyle} ${borderColor}`;
  }

  element.style.textAlign = cellData.textAlign || 'left';
}

// Load cell properties into the panel when a cell is selected
function loadCellProps(cellData) {
  if (!cellData) return;

  document.getElementById('prop_cellBg').value = cellData.bgColor || '#ffffff';
  document.getElementById('prop_cellBgHex').value = (cellData.bgColor || '#ffffff').toUpperCase();
  document.getElementById('prop_cellColor').value = cellData.textColor || '#000000';
  document.getElementById('prop_cellColorHex').value = (cellData.textColor || '#000000').toUpperCase();
  document.getElementById('prop_cellFontFamily').value = cellData.fontFamily || 'Arial';
  document.getElementById('prop_cellFontSize').value = cellData.fontSize || 14;
  document.getElementById('prop_cellBorder').value = cellData.borderColor || '#000000';
  document.getElementById('prop_cellBorderHex').value = (cellData.borderColor || '#000000').toUpperCase();
  document.getElementById('prop_cellBorderWidth').value = cellData.borderWidth ?? 1;
  document.getElementById('prop_cellBorderStyle').value = cellData.borderStyle || 'solid';
  document.getElementById('prop_cellBorderPosition').value = cellData.borderPosition || 'all';

  // Update text style buttons
  document.getElementById('prop_cellBold').classList.toggle('active', cellData.bold === true);
  document.getElementById('prop_cellItalic').classList.toggle('active', cellData.italic === true);
  document.getElementById('prop_cellUnderline').classList.toggle('active', cellData.underline === true);

  // Update alignment buttons
  const align = cellData.textAlign || 'left';
  document.getElementById('prop_cellAlignLeft').classList.toggle('active', align === 'left');
  document.getElementById('prop_cellAlignCenter').classList.toggle('active', align === 'center');
  document.getElementById('prop_cellAlignRight').classList.toggle('active', align === 'right');
}

function setCellAlign(align) {
  if (!selectedElement || selectedElement.dataset.type !== 'table') return;

  const data = getTableData(selectedElement.id);
  if (!data) return;

  document.getElementById('prop_cellAlignLeft').classList.toggle('active', align === 'left');
  document.getElementById('prop_cellAlignCenter').classList.toggle('active', align === 'center');
  document.getElementById('prop_cellAlignRight').classList.toggle('active', align === 'right');

  selectedCells.forEach(({ row, col, element }) => {
    const cellData = data.cells[row]?.[col];
    if (cellData) {
      cellData.textAlign = align;
      element.style.textAlign = align;
    }
  });
}

function toggleCellStyle(style) {
  if (!selectedElement || selectedElement.dataset.type !== 'table') return;

  const data = getTableData(selectedElement.id);
  if (!data) return;

  // Toggle the button active state
  const btn = document.getElementById('prop_cell' + style.charAt(0).toUpperCase() + style.slice(1));
  const isActive = btn.classList.contains('active');
  btn.classList.toggle('active');

  selectedCells.forEach(({ row, col, element }) => {
    const cellData = data.cells[row]?.[col];
    if (cellData) {
      cellData[style] = !isActive;

      // Apply to element
      if (style === 'bold') {
        element.style.fontWeight = !isActive ? '700' : '400';
      } else if (style === 'italic') {
        element.style.fontStyle = !isActive ? 'italic' : 'normal';
      } else if (style === 'underline') {
        element.style.textDecoration = !isActive ? 'underline' : 'none';
      }
    }
  });
}

function syncCellBgFromHex() {
  const hex = document.getElementById('prop_cellBgHex').value;
  if (/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
    document.getElementById('prop_cellBg').value = hex;
    updateCellProp('bgColor');
  }
}

function syncCellColorFromHex() {
  const hex = document.getElementById('prop_cellColorHex').value;
  if (/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
    document.getElementById('prop_cellColor').value = hex;
    updateCellProp('textColor');
  }
}

function syncCellBorderFromHex() {
  const hex = document.getElementById('prop_cellBorderHex').value;
  if (/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
    document.getElementById('prop_cellBorder').value = hex;
    updateCellProp('borderColor');
  }
}

function insertColumn(direction) {
  if (!selectedElement || selectedElement.dataset.type !== 'table') return;
  if (selectedCells.length === 0) return;

  const data = getTableData(selectedElement.id);
  if (!data) return;

  saveState();

  // Get the column index from the first selected cell
  const colIndex = selectedCells[0].col;
  const insertAt = direction === 'left' ? colIndex : colIndex + 1;

  // Add a new cell to each row at the insert position
  data.cells.forEach(row => {
    row.splice(insertAt, 0, createDefaultCell());
  });

  // Add column width entry
  if (!data.colWidths) data.colWidths = Array(data.cols).fill(100);
  data.colWidths.splice(insertAt, 0, 100);  // Default 100px for new column

  data.cols++;

  // Re-render and re-select
  renderPage();
  setTimeout(() => {
    const el = document.getElementById(data.id);
    if (el) selectElement(el, 'table');
  }, 10);
}

function insertRow(direction) {
  if (!selectedElement || selectedElement.dataset.type !== 'table') return;
  if (selectedCells.length === 0) return;

  const data = getTableData(selectedElement.id);
  if (!data) return;

  saveState();

  // Get the row index from the first selected cell
  const rowIndex = selectedCells[0].row;
  const insertAt = direction === 'above' ? rowIndex : rowIndex + 1;

  // Create a new row with the same number of columns
  const newRow = [];
  for (let c = 0; c < data.cols; c++) {
    newRow.push(createDefaultCell());
  }

  // Insert the new row
  data.cells.splice(insertAt, 0, newRow);

  // Add row height entry
  if (!data.rowHeights) data.rowHeights = Array(data.rows).fill(30);
  data.rowHeights.splice(insertAt, 0, 30);  // Default 30px for new row

  data.rows++;

  // Re-render and re-select
  renderPage();
  setTimeout(() => {
    const el = document.getElementById(data.id);
    if (el) selectElement(el, 'table');
  }, 10);
}

function mergeCells() {
  if (selectedCells.length < 2) return;

  const data = getTableData(selectedElement.id);
  if (!data) return;

  saveState();

  // Find bounds
  const rows = selectedCells.map(c => c.row);
  const cols = selectedCells.map(c => c.col);
  const minRow = Math.min(...rows);
  const maxRow = Math.max(...rows);
  const minCol = Math.min(...cols);
  const maxCol = Math.max(...cols);

  // Set first cell to span
  const firstCell = data.cells[minRow][minCol];
  firstCell.colSpan = maxCol - minCol + 1;
  firstCell.rowSpan = maxRow - minRow + 1;

  // Hide other cells
  for (let r = minRow; r <= maxRow; r++) {
    for (let c = minCol; c <= maxCol; c++) {
      if (r === minRow && c === minCol) continue;
      data.cells[r][c].hidden = true;
    }
  }

  selectedCells = [];
  renderPage();
}

function unmergeCells() {
  if (selectedCells.length === 0) return;

  const data = getTableData(selectedElement.id);
  if (!data) return;

  saveState();

  selectedCells.forEach(({ row, col }) => {
    const cell = data.cells[row]?.[col];
    if (cell && (cell.colSpan > 1 || cell.rowSpan > 1)) {
      // Unhide cells
      for (let r = row; r < row + cell.rowSpan; r++) {
        for (let c = col; c < col + cell.colSpan; c++) {
          if (data.cells[r]?.[c]) {
            data.cells[r][c].hidden = false;
          }
        }
      }
      cell.colSpan = 1;
      cell.rowSpan = 1;
    }
  });

  selectedCells = [];
  renderPage();
}

function getTableData(id) {
  return template.pages[currentPage].tables.find(t => t.id === id);
}

// ===== IMAGE =====
function addImage() {
  const id = 'img_' + (++elementIdCounter);
  const image = {
    id,
    type: 'static', // 'static', '{{lot.landscape}}', '{{lot.map}}'
    url: '', // Only used for static images
    x: 100,
    y: 100,
    width: 300,
    height: 200,
    aspectRatio: 1.5, // width / height
    lockAspect: true
  };

  template.pages[currentPage].images.push(image);
  renderPage();

  setTimeout(() => {
    const el = document.getElementById(id);
    if (el) selectElement(el, 'image');
  }, 10);
}

function createImageElement(data) {
  const div = document.createElement('div');
  div.className = 'image-box';
  div.id = data.id;
  div.dataset.type = 'image';

  div.style.left = data.x + 'px';
  div.style.top = data.y + 'px';
  div.style.width = data.width + 'px';
  div.style.height = data.height + 'px';

  // Set background image based on type
  const previewUrl = getImagePreviewUrl(data);
  if (previewUrl) {
    div.style.backgroundImage = `url("${previewUrl}")`;
  } else {
    div.style.backgroundColor = '#333';
  }

  // Label showing image type
  const label = document.createElement('div');
  label.className = 'image-label';
  label.textContent = data.type === 'static' ? 'Static' : data.type;
  div.appendChild(label);

  // Resize handles (all 4 corners)
  ['se', 'sw', 'ne', 'nw'].forEach(pos => {
    const handle = document.createElement('div');
    handle.className = `resize-handle ${pos}`;
    handle.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      startImageResize(e, div, data, pos);
    });
    div.appendChild(handle);
  });

  // Events
  div.addEventListener('mousedown', (e) => {
    if (e.target.classList.contains('resize-handle')) return;
    selectElement(div, 'image');
    startDrag(e, div, data);
  });

  return div;
}

function getImagePreviewUrl(data) {
  const lotNum = document.getElementById('previewLot')?.value || '001';

  if (data.type === '{{lot.landscape}}') {
    return `/cpi/pdf/lotcpi1-${lotNum}_landscape.jpg`;
  } else if (data.type === '{{lot.map}}') {
    return `/cpi/pdf/lotcpi1-${lotNum}_map.jpg`;
  } else if (data.type === 'static' && data.url) {
    return data.url;
  }
  return null;
}

function updatePreviewImages() {
  // Re-render all images on current page to update their preview URLs
  const pageData = template.pages[currentPage];
  pageData.images.forEach(img => {
    const el = document.getElementById(img.id);
    if (el) {
      const previewUrl = getImagePreviewUrl(img);
      if (previewUrl) {
        el.style.backgroundImage = `url("${previewUrl}")`;
      } else {
        el.style.backgroundImage = 'none';
        el.style.backgroundColor = '#333';
      }
    }
  });
}

function updateSelectedImage() {
  if (!selectedElement || selectedElement.dataset.type !== 'image') return;

  const data = getImageData(selectedElement.id);
  if (!data) return;

  const imageType = document.getElementById('prop_imageType').value;
  data.type = imageType;
  data.url = document.getElementById('prop_imageUrl').value;
  data.x = parseInt(document.getElementById('prop_imageX').value) || 0;
  data.y = parseInt(document.getElementById('prop_imageY').value) || 0;
  data.width = parseInt(document.getElementById('prop_imageWidth').value) || 100;
  data.height = parseInt(document.getElementById('prop_imageHeight').value) || 100;

  // Update aspect ratio when dimensions change
  if (data.width > 0 && data.height > 0) {
    data.aspectRatio = data.width / data.height;
  }

  // Show/hide static URL input
  document.getElementById('staticImageUrlGroup').style.display =
    imageType === 'static' ? 'block' : 'none';

  // Update label
  const label = selectedElement.querySelector('.image-label');
  if (label) {
    label.textContent = imageType === 'static' ? 'Static' : imageType;
  }

  applyImageStyles(selectedElement, data);
}

function applyImageStyles(el, data) {
  el.style.left = data.x + 'px';
  el.style.top = data.y + 'px';
  el.style.width = data.width + 'px';
  el.style.height = data.height + 'px';

  const previewUrl = getImagePreviewUrl(data);
  if (previewUrl) {
    el.style.backgroundImage = `url("${previewUrl}")`;
    el.style.backgroundColor = 'transparent';
  } else {
    el.style.backgroundImage = 'none';
    el.style.backgroundColor = '#333';
  }
}

function loadImageProps(id) {
  const data = getImageData(id);
  if (!data) return;

  document.getElementById('prop_imageType').value = data.type;
  document.getElementById('prop_imageUrl').value = data.url || '';
  document.getElementById('prop_imageX').value = data.x;
  document.getElementById('prop_imageY').value = data.y;
  document.getElementById('prop_imageWidth').value = data.width;
  document.getElementById('prop_imageHeight').value = data.height;

  // Show/hide static URL input
  document.getElementById('staticImageUrlGroup').style.display =
    data.type === 'static' ? 'block' : 'none';

  // Update aspect lock button
  const lockBtn = document.getElementById('prop_lockAspect');
  lockBtn.classList.toggle('active', data.lockAspect !== false);
  lockBtn.textContent = data.lockAspect !== false ? 'üîí Locked' : 'üîì Unlocked';
}

function toggleAspectLock() {
  if (!selectedElement || selectedElement.dataset.type !== 'image') return;

  const data = getImageData(selectedElement.id);
  if (!data) return;

  data.lockAspect = !data.lockAspect;

  const lockBtn = document.getElementById('prop_lockAspect');
  lockBtn.classList.toggle('active', data.lockAspect);
  lockBtn.textContent = data.lockAspect ? 'üîí Locked' : 'üîì Unlocked';
}

function getImageData(id) {
  return template.pages[currentPage].images.find(img => img.id === id);
}

// ===== IMAGE RESIZE =====
let imageResizeData = null;

function startImageResize(e, el, data, corner) {
  e.preventDefault();
  e.stopPropagation();

  selectElement(el, 'image');

  const page = document.getElementById('pdfPage');
  const scale = page.getBoundingClientRect().width / 1224;

  imageResizeData = {
    el,
    data,
    corner,
    startX: e.clientX,
    startY: e.clientY,
    origX: data.x,
    origY: data.y,
    origW: data.width,
    origH: data.height,
    aspectRatio: data.aspectRatio || (data.width / data.height),
    scale
  };

  document.addEventListener('mousemove', onImageResize);
  document.addEventListener('mouseup', stopImageResize);
}

function onImageResize(e) {
  if (!imageResizeData) return;

  const { el, data, corner, startX, startY, origX, origY, origW, origH, aspectRatio, scale } = imageResizeData;

  const dx = (e.clientX - startX) / scale;
  const dy = (e.clientY - startY) / scale;

  let newW = origW;
  let newH = origH;
  let newX = origX;
  let newY = origY;

  // Determine how resize affects dimensions based on corner
  const lockAspect = data.lockAspect !== false && !e.shiftKey;

  if (corner === 'se') {
    newW = Math.max(50, origW + dx);
    newH = Math.max(50, origH + dy);
    if (lockAspect) {
      // Use the larger delta to determine scaling
      const scaleW = newW / origW;
      const scaleH = newH / origH;
      if (scaleW > scaleH) {
        newH = newW / aspectRatio;
      } else {
        newW = newH * aspectRatio;
      }
    }
  } else if (corner === 'sw') {
    newW = Math.max(50, origW - dx);
    newH = Math.max(50, origH + dy);
    if (lockAspect) {
      const scaleW = newW / origW;
      const scaleH = newH / origH;
      if (scaleW > scaleH) {
        newH = newW / aspectRatio;
      } else {
        newW = newH * aspectRatio;
      }
    }
    newX = origX + (origW - newW);
  } else if (corner === 'ne') {
    newW = Math.max(50, origW + dx);
    newH = Math.max(50, origH - dy);
    if (lockAspect) {
      const scaleW = newW / origW;
      const scaleH = newH / origH;
      if (scaleW > scaleH) {
        newH = newW / aspectRatio;
      } else {
        newW = newH * aspectRatio;
      }
    }
    newY = origY + (origH - newH);
  } else if (corner === 'nw') {
    newW = Math.max(50, origW - dx);
    newH = Math.max(50, origH - dy);
    if (lockAspect) {
      const scaleW = newW / origW;
      const scaleH = newH / origH;
      if (scaleW > scaleH) {
        newH = newW / aspectRatio;
      } else {
        newW = newH * aspectRatio;
      }
    }
    newX = origX + (origW - newW);
    newY = origY + (origH - newH);
  }

  data.x = Math.round(newX);
  data.y = Math.round(newY);
  data.width = Math.round(newW);
  data.height = Math.round(newH);

  el.style.left = data.x + 'px';
  el.style.top = data.y + 'px';
  el.style.width = data.width + 'px';
  el.style.height = data.height + 'px';

  // Update props panel
  document.getElementById('prop_imageX').value = data.x;
  document.getElementById('prop_imageY').value = data.y;
  document.getElementById('prop_imageWidth').value = data.width;
  document.getElementById('prop_imageHeight').value = data.height;
}

function stopImageResize() {
  if (imageResizeData) {
    // Update aspect ratio after resize
    const data = imageResizeData.data;
    if (data.width > 0 && data.height > 0) {
      data.aspectRatio = data.width / data.height;
    }
  }
  imageResizeData = null;
  document.removeEventListener('mousemove', onImageResize);
  document.removeEventListener('mouseup', stopImageResize);
}

// ===== SELECTION =====
function selectElement(el, type, preserveCells = false) {
  // Clear previous selection but optionally preserve cell selections
  if (preserveCells) {
    // Only clear element selection, not cell selections
    document.querySelectorAll('.selected').forEach(e => e.classList.remove('selected'));
    selectedElement = null;
  } else {
    clearSelection();
  }

  selectedElement = el;
  el.classList.add('selected');

  // Show appropriate properties panel
  document.getElementById('noSelectionProps').style.display = 'none';

  if (type === 'textbox') {
    document.getElementById('textBoxProps').style.display = 'block';
    document.getElementById('tableProps').style.display = 'none';
    document.getElementById('imageProps').style.display = 'none';
    loadTextBoxProps(el.id);
  } else if (type === 'table') {
    document.getElementById('textBoxProps').style.display = 'none';
    document.getElementById('tableProps').style.display = 'block';
    document.getElementById('imageProps').style.display = 'none';
    loadTableProps(el.id);
  } else if (type === 'image') {
    document.getElementById('textBoxProps').style.display = 'none';
    document.getElementById('tableProps').style.display = 'none';
    document.getElementById('imageProps').style.display = 'block';
    loadImageProps(el.id);
  }

  updateElementLists();
}

function clearSelection() {
  document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
  document.querySelectorAll('.cell-selected').forEach(el => el.classList.remove('cell-selected'));
  selectedElement = null;
  selectedCells = [];

  document.getElementById('noSelectionProps').style.display = 'block';
  document.getElementById('textBoxProps').style.display = 'none';
  document.getElementById('tableProps').style.display = 'none';
  document.getElementById('imageProps').style.display = 'none';

  updateElementLists();
}

function loadTextBoxProps(id) {
  const data = getTextBoxData(id);
  if (!data) return;

  document.getElementById('prop_text').value = data.content;
  document.getElementById('prop_fontSize').value = data.fontSize;
  document.getElementById('prop_fontFamily').value = data.fontFamily;
  document.getElementById('prop_color').value = data.color;
  document.getElementById('prop_colorHex').value = data.color.toUpperCase();
  document.getElementById('prop_x').value = data.x;
  document.getElementById('prop_y').value = data.y;
  document.getElementById('prop_width').value = data.width || '';
  document.getElementById('prop_height').value = data.height || '';

  document.getElementById('prop_bold').classList.toggle('active', data.bold);
  document.getElementById('prop_italic').classList.toggle('active', data.italic);
  document.getElementById('prop_underline').classList.toggle('active', data.underline);

  document.getElementById('prop_alignLeft').classList.toggle('active', data.textAlign === 'left');
  document.getElementById('prop_alignCenter').classList.toggle('active', data.textAlign === 'center');
  document.getElementById('prop_alignRight').classList.toggle('active', data.textAlign === 'right');
}

function loadTableProps(id) {
  const data = getTableData(id);
  if (!data) return;

  document.getElementById('prop_rows').value = data.rows;
  document.getElementById('prop_cols').value = data.cols;
  document.getElementById('prop_tableX').value = data.x;
  document.getElementById('prop_tableY').value = data.y;

  // Render column width inputs
  renderColWidthInputs(data);
  // Render row height inputs
  renderRowHeightInputs(data);
}

function renderColWidthInputs(data) {
  const container = document.getElementById('colWidthsContainer');
  const colWidths = data.colWidths || Array(data.cols).fill(100);

  container.innerHTML = colWidths.map((w, i) => `
    <div style="display: flex; align-items: center; gap: 4px;">
      <span style="font-size: 10px; width: 35px;">Col ${i + 1}:</span>
      <input type="number" value="${w}" min="20" max="500"
             style="flex: 1; padding: 4px;"
             onchange="updateColWidth(${i}, this.value)">
    </div>
  `).join('');
}

function renderRowHeightInputs(data) {
  const container = document.getElementById('rowHeightsContainer');
  const rowHeights = data.rowHeights || Array(data.rows).fill(30);

  container.innerHTML = rowHeights.map((h, i) => `
    <div style="display: flex; align-items: center; gap: 4px;">
      <span style="font-size: 10px; width: 35px;">Row ${i + 1}:</span>
      <input type="number" value="${h}" min="15" max="200"
             style="flex: 1; padding: 4px;"
             onchange="updateRowHeight(${i}, this.value)">
    </div>
  `).join('');
}

function updateColWidth(colIndex, value) {
  if (!selectedElement || selectedElement.dataset.type !== 'table') return;
  const data = getTableData(selectedElement.id);
  if (!data) return;

  // Initialize if not exists
  if (!data.colWidths) {
    data.colWidths = Array(data.cols).fill(100);
  }

  data.colWidths[colIndex] = parseInt(value) || 100;
  renderPage();

  // Re-select the table
  setTimeout(() => {
    const el = document.getElementById(selectedElement.id);
    if (el) selectElement(el, 'table');
  }, 10);
}

function updateRowHeight(rowIndex, value) {
  if (!selectedElement || selectedElement.dataset.type !== 'table') return;
  const data = getTableData(selectedElement.id);
  if (!data) return;

  // Initialize if not exists
  if (!data.rowHeights) {
    data.rowHeights = Array(data.rows).fill(30);
  }

  data.rowHeights[rowIndex] = parseInt(value) || 30;
  renderPage();

  // Re-select the table
  setTimeout(() => {
    const el = document.getElementById(selectedElement.id);
    if (el) selectElement(el, 'table');
  }, 10);
}

// ===== ELEMENT LISTS =====
function updateElementLists() {
  const textBoxList = document.getElementById('textBoxList');
  const tableList = document.getElementById('tableList');

  const pageData = template.pages[currentPage];

  // Text boxes
  textBoxList.innerHTML = pageData.textBoxes.map(tb => `
    <div class="element-item ${selectedElement?.id === tb.id ? 'selected' : ''}"
         onclick="selectElementById('${tb.id}', 'textbox')">
      <span>${tb.content.substring(0, 20)}${tb.content.length > 20 ? '...' : ''}</span>
      <button class="delete-btn btn-small" onclick="event.stopPropagation(); deleteElementById('${tb.id}', 'textbox')">‚úï</button>
    </div>
  `).join('');

  // Tables
  tableList.innerHTML = pageData.tables.map(t => `
    <div class="element-item ${selectedElement?.id === t.id ? 'selected' : ''}"
         onclick="selectElementById('${t.id}', 'table')">
      <span>Table ${t.rows}x${t.cols}</span>
      <button class="delete-btn btn-small" onclick="event.stopPropagation(); deleteElementById('${t.id}', 'table')">‚úï</button>
    </div>
  `).join('');

  // Images
  const imageList = document.getElementById('imageList');
  imageList.innerHTML = pageData.images.map(img => `
    <div class="element-item ${selectedElement?.id === img.id ? 'selected' : ''}"
         onclick="selectElementById('${img.id}', 'image')">
      <span>${img.type === 'static' ? 'Static Image' : img.type}</span>
      <button class="delete-btn btn-small" onclick="event.stopPropagation(); deleteElementById('${img.id}', 'image')">‚úï</button>
    </div>
  `).join('');
}

function selectElementById(id, type) {
  const el = document.getElementById(id);
  if (el) selectElement(el, type);
}

function deleteElementById(id, type) {
  const pageData = template.pages[currentPage];

  if (type === 'textbox') {
    pageData.textBoxes = pageData.textBoxes.filter(tb => tb.id !== id);
  } else if (type === 'table') {
    pageData.tables = pageData.tables.filter(t => t.id !== id);
  } else if (type === 'image') {
    pageData.images = pageData.images.filter(img => img.id !== id);
  }

  renderPage();
}

function deleteSelected() {
  if (!selectedElement) return;
  saveState();
  deleteElementById(selectedElement.id, selectedElement.dataset.type);
}

// ===== DRAG & RESIZE =====
let dragData = null;

function startDrag(e, el, data) {
  e.preventDefault();

  const rect = el.getBoundingClientRect();
  const page = document.getElementById('pdfPage');
  const pageRect = page.getBoundingClientRect();
  const scale = page.getBoundingClientRect().width / 1224;

  dragData = {
    el,
    data,
    startX: e.clientX,
    startY: e.clientY,
    origX: data.x,
    origY: data.y,
    scale
  };

  document.addEventListener('mousemove', onDrag);
  document.addEventListener('mouseup', stopDrag);
}

function onDrag(e) {
  if (!dragData) return;

  const dx = (e.clientX - dragData.startX) / dragData.scale;
  const dy = (e.clientY - dragData.startY) / dragData.scale;

  dragData.data.x = Math.round(dragData.origX + dx);
  dragData.data.y = Math.round(dragData.origY + dy);

  dragData.el.style.left = dragData.data.x + 'px';
  dragData.el.style.top = dragData.data.y + 'px';

  // Update props
  if (dragData.data.id?.startsWith('tb_')) {
    document.getElementById('prop_x').value = dragData.data.x;
    document.getElementById('prop_y').value = dragData.data.y;
  } else if (dragData.data.id?.startsWith('table_')) {
    document.getElementById('prop_tableX').value = dragData.data.x;
    document.getElementById('prop_tableY').value = dragData.data.y;
  } else if (dragData.data.id?.startsWith('img_')) {
    document.getElementById('prop_imageX').value = dragData.data.x;
    document.getElementById('prop_imageY').value = dragData.data.y;
  }
}

function stopDrag() {
  dragData = null;
  document.removeEventListener('mousemove', onDrag);
  document.removeEventListener('mouseup', stopDrag);
}

let resizeData = null;

function startResize(e, el, data) {
  e.preventDefault();
  e.stopPropagation();

  const page = document.getElementById('pdfPage');
  const scale = page.getBoundingClientRect().width / 1224;

  resizeData = {
    el,
    data,
    startX: e.clientX,
    startY: e.clientY,
    origW: data.width || el.offsetWidth,
    origH: data.height || el.offsetHeight,
    scale
  };

  document.addEventListener('mousemove', onResize);
  document.addEventListener('mouseup', stopResize);
}

function onResize(e) {
  if (!resizeData) return;

  const dx = (e.clientX - resizeData.startX) / resizeData.scale;
  const dy = (e.clientY - resizeData.startY) / resizeData.scale;

  resizeData.data.width = Math.max(50, Math.round(resizeData.origW + dx));
  resizeData.data.height = Math.max(20, Math.round(resizeData.origH + dy));

  resizeData.el.style.width = resizeData.data.width + 'px';
  resizeData.el.style.height = resizeData.data.height + 'px';

  document.getElementById('prop_width').value = resizeData.data.width;
  document.getElementById('prop_height').value = resizeData.data.height;
}

function stopResize() {
  resizeData = null;
  document.removeEventListener('mousemove', onResize);
  document.removeEventListener('mouseup', stopResize);
}

// ===== PLACEHOLDERS =====
function insertPlaceholder(placeholder) {
  const textarea = document.getElementById('prop_text');
  if (document.getElementById('textBoxProps').style.display !== 'none') {
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = textarea.value;
    textarea.value = text.substring(0, start) + placeholder + text.substring(end);
    textarea.focus();
    textarea.setSelectionRange(start + placeholder.length, start + placeholder.length);
    updateSelectedTextBox();
  }
}

// ===== SAVE / LOAD =====
function saveTemplate() {
  const json = JSON.stringify(template, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = 'pdf-template.json';
  a.click();

  URL.revokeObjectURL(url);
}

function loadTemplate() {
  document.getElementById('fileInput').click();
}

function handleFileLoad(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const loaded = JSON.parse(e.target.result);

      // Merge loaded data
      for (let i = 1; i <= totalPages; i++) {
        if (loaded.pages[i]) {
          template.pages[i] = loaded.pages[i];
        }
      }

      // Find max element ID to continue from
      Object.values(template.pages).forEach(page => {
        page.textBoxes?.forEach(tb => {
          const num = parseInt(tb.id.replace('tb_', ''));
          if (num > elementIdCounter) elementIdCounter = num;
        });
        page.tables?.forEach(t => {
          const num = parseInt(t.id.replace('table_', ''));
          if (num > elementIdCounter) elementIdCounter = num;
        });
        page.images?.forEach(img => {
          const num = parseInt(img.id.replace('img_', ''));
          if (num > elementIdCounter) elementIdCounter = num;
        });
        // Ensure images array exists
        if (!page.images) page.images = [];
      });

      renderPage();
      alert('Template loaded successfully!');
    } catch (err) {
      alert('Error loading template: ' + err.message);
    }
  };
  reader.readAsText(file);

  // Reset input
  event.target.value = '';
}

// ===== EXPORT PDF =====
function exportPDF() {
  alert('PDF Export will generate the current page.\nFor multi-page export, use the JSON template in index.html');

  // Remove selection styling temporarily
  const selected = document.querySelector('.selected');
  if (selected) selected.classList.remove('selected');

  // Remove cell selection styling
  const selectedCellEls = document.querySelectorAll('.cell-selected');
  selectedCellEls.forEach(c => c.classList.remove('cell-selected'));

  // Hide all drag handles
  const dragHandles = document.querySelectorAll('.table-drag-handle');
  dragHandles.forEach(h => h.style.display = 'none');

  const page = document.getElementById('pdfPage');
  const origTransform = page.style.transform;
  page.style.transform = 'none';

  // Reset scroll position of canvas wrapper
  const canvasWrapper = document.getElementById('canvasWrapper');
  const origScrollLeft = canvasWrapper.scrollLeft;
  const origScrollTop = canvasWrapper.scrollTop;
  canvasWrapper.scrollLeft = 0;
  canvasWrapper.scrollTop = 0;

  html2pdf().set({
    margin: 0,
    filename: `page-${currentPage}.pdf`,
    image: { type: 'jpeg', quality: 1 },
    html2canvas: {
      scale: 1,
      useCORS: true,
      backgroundColor: '#ffffff',
      width: 1224,
      height: 1584,
      scrollX: 0,
      scrollY: 0,
      x: 0,
      y: 0,
      windowWidth: 1224,
      windowHeight: 1584
    },
    jsPDF: { unit: 'px', format: [1224, 1584], orientation: 'portrait' }
  }).from(page).save().then(() => {
    page.style.transform = origTransform;
    canvasWrapper.scrollLeft = origScrollLeft;
    canvasWrapper.scrollTop = origScrollTop;
    if (selected) selected.classList.add('selected');
    // Restore cell selections
    selectedCells.forEach(({ element }) => element.classList.add('cell-selected'));
    // Restore drag handles (they show/hide via CSS based on .selected)
    dragHandles.forEach(h => h.style.display = '');
  });
}

// ===== KEYBOARD SHORTCUTS =====
document.addEventListener('keydown', (e) => {
  // Ctrl+Z for undo
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
    e.preventDefault();
    undo();
    return;
  }

  if (e.key === 'Delete' || e.key === 'Backspace') {
    // Don't delete if editing text
    if (document.activeElement.tagName === 'TEXTAREA' ||
        document.activeElement.tagName === 'INPUT' ||
        document.activeElement.contentEditable === 'true') return;

    if (selectedElement) {
      deleteSelected();
    }
  }

  if (e.key === 'Escape') {
    clearSelection();
  }
});

// Click on page background to deselect
document.getElementById('pdfPage').addEventListener('click', (e) => {
  if (e.target.id === 'pdfPage') {
    clearSelection();
  }
});

// ===== START =====
init();
</script>

</body>
</html>
