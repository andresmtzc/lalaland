<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-GPX Editor with Mapbox</title>
    
    <!-- Mapbox CSS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet">
    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: Arial, sans-serif; 
            background: #f5f5f5;
        }
        #map { 
            position: absolute; 
            top: 0; 
            bottom: 0; 
            width: 100%; 
        } 
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1;
            width: 320px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        .control-group:last-child {
            border-bottom: none;
        }
        button {
            padding: 8px 12px;
            margin: 2px;
            border: 1px solid #ddd;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        button:hover {
            background: #e9ecef;
        }
        button.active {
            background: #4285F4;
            color: white;
            border-color: #4285F4;
        }
        .track-active {
            background: #e6f3ff !important;
            border-color: #4285F4 !important;
        }
        .status {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4285F4;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4285F4;
            cursor: pointer;
            border: none;
        }
        .tracks-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            margin-top: 5px;
        }
        .track-item {
            padding: 5px 8px;
            margin: 2px 0;
            border: 1px solid #eee;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }
        .track-item:hover {
            background: #f8f9fa;
        }
        .track-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .track-info {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }
        .track-actions {
            display: flex;
            gap: 4px;
        }
        .small-btn {
            padding: 2px 6px;
            font-size: 10px;
        }
        .stats-container {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        .file-input-container input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        .file-input-button {
            display: block;
            padding: 10px;
            background: #4285F4;
            color: white;
            text-align: center;
            border-radius: 4px;
            cursor: pointer;
        }
        .export-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .export-buttons button {
            flex: 1;
        }
        .mode-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .mode-buttons button {
            flex: 1;
            min-width: 80px;
        }
        h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }

        /* 360 Viewer Styles */
#viewer-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 50%;
    background: #000;
    z-index: 0;
}

#viewer-controls {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.7);
    padding: 10px 20px;
    border-radius: 20px;
    z-index: 1000;
    display: flex;
    gap: 20px;
    align-items: center;
    color: white;
    font-size: 14px;
}

#viewer-controls button {
    background: #4285F4;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
}

#viewer-controls button:hover {
    background: #3367d6;
}

#panorama-viewer {
    width: 100%;
    height: 100%;
    background: #1a1a1a;
}

/* Adjust map position for split screen */
#map {
    position: absolute;
    top: 50%; /* Start at 50% for bottom half */
    bottom: 0;
    width: 100%;
}

/* Adjust controls position */
#controls {
    position: absolute;
    top: 60px; /* Moved down to avoid overlapping with viewer */
    left: 10px;
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    z-index: 1;
    width: 320px;
    max-height: calc(50vh - 80px); /* Adjusted for split screen */
    overflow-y: auto;
}

/* === NEW 360 VIEWER STYLES === */
#viewer-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 50%;
    background: #0b1020;
    z-index: 0;
}

#canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    touch-action: none;
}

.viewer-controls {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.7);
    padding: 10px 20px;
    border-radius: 20px;
    z-index: 1000;
    display: flex;
    gap: 20px;
    align-items: center;
    color: white;
    font-size: 14px;
}

.viewer-controls button {
    background: #4285F4;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
}

.viewer-controls button:hover {
    background: #3367d6;
}

.image-controls {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 20;
}

.navigation-ring {
    position: relative;
    width: 160px;
    height: 160px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
}

.nav-button.ring-button {
    position: absolute;
    width: 40px;
    height: 40px;
    border: none;
    border-radius: 50%;
    background: rgba(0,0,0,0.7);
    color: #22d3ee;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    transform: translateX(-50%);
}

#nextImageBtn.ring-button {
    top: 15px;
    left: 50%;
}

#prevImageBtn.ring-button {
    bottom: 15px;
    left: 50%;
}

.nav-button.ring-button:hover {
    transform: translateX(-50%) scale(1.2);
}

.time {
    position: absolute;
    right: 20px;
    bottom: 20px;
    color: #22d3ee;
    font-weight: 600;
    font-size: 14px;
    z-index: 25;
}

.zoom-controls {
    position: absolute;
    right: 10px;
    top: 60px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 5;
}

.zoom-btn {
    width: 40px;
    height: 40px;
    background: rgba(0,0,0,0.7);
    border: 1px solid #ccc;
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
}

.zoom-btn:hover {
    background: rgba(0,0,0,0.9);
}

#viewer-loading {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 100;
    background: rgba(0,0,0,0.7);
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    color: white;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(255,255,255,0.1);
    border-radius: 50%;
    border-top: 4px solid #22d3ee;
    animation: spin 1s linear infinite;
    margin: 0 auto 10px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* View cone on map */
.mapboxgl-marker.view-cone {
    z-index: 10;
}
    </style>
</head>
<body>
    <div id="map"></div>


    <div id="controls">
    <h3>GPX Track Editor</h3>
    
    <div class="control-group">
        <div class="file-input-container">
            <div class="file-input-button">Load GPX Files</div>
            <input type="file" id="gpx-file" accept=".gpx" multiple>
        </div>
        <div class="tracks-list" id="tracks-list">
            <div style="text-align: center; padding: 10px; color: #666; font-size: 12px;">
                No tracks loaded
            </div>
        </div>
    </div>
    
    <div class="control-group">
        <button onclick="toggleEditMode()" id="edit-btn">Edit Mode: OFF</button>
        <button onclick="clearAllRoutes()">Clear All</button>
    </div>
    
    <div class="control-group">
        <div class="slider-container">
            <div class="slider-label">
                <span>Point Density:</span>
                <span id="density-value">100%</span>
            </div>
            <input type="range" min="1" max="100" value="100" class="slider" id="density-slider">
            <div class="slider-label">
                <small id="points-count">0 points</small>
                <small id="original-count"></small>
            </div>
        </div>
    </div>
    
    <div class="control-group">
        <button onclick="toggleCatmullRom()" id="catmull-btn">Catmull-Rom: OFF</button>
        <button onclick="resetCurrentTrack()">Reset Current</button>
    </div>
    
    <div class="control-group">
        <div class="mode-buttons">
            <button onclick="addPointMode()">Add Points</button>
            <button onclick="removePointMode()">Remove Points</button>
            <button onclick="movePointMode()">Move Points</button>
        </div>
    </div>
    
    <div class="control-group">
        <div class="stats-container">
            <div class="slider-label">
                <small>Distance: <span id="total-distance">0 km</span></small>
                <small>Avg Speed: <span id="avg-speed">0 km/h</span></small>
            </div>
            <div class="slider-label">
                <small>Points: <span id="stats-points">0</span></small>
                <small>Duration: <span id="total-duration">0s</span></small>
            </div>
        </div>
    </div>

<div class="control-group">
    <div class="slider-label">
        <span>Marble Controls:</span>
        <div>
            <button class="small-btn" onclick="addMarble()" title="Add marble at end">+</button>
            <button class="small-btn" onclick="removeMarble()" title="Remove last marble">-</button>
            <button class="small-btn" onclick="initializeMarbles()" title="Rebuild all marbles">Rebuild</button>
            <button class="small-btn" onclick="lockSelectedMarble()" title="Lock selected marble">🔒 Lock</button>
        </div>
    </div>
    <div class="slider-label">
        <small id="marble-count">0 marbles</small>
        <small>Spacing: <span id="marble-spacing">10</span>m</small>
    </div>
    <div class="slider-label">
        <input type="range" min="1" max="50" value="10" class="slider" id="marble-spacing-slider">
    </div>
</div>
    
    
    <div class="control-group">
        <div class="export-buttons">
            <button onclick="exportCurrentTrack()">Export Current</button>
            <button onclick="exportAllTracksAsZip()">Export All (ZIP)</button>
        </div>
    </div>

    <div class="status" id="status">Ready - Load GPX files to start</div>
</div>

<!-- NEW 360 VIEWER -->
<div id="viewer-container">
    <canvas id="canvas"></canvas>
    
    <!-- Loading spinner -->
    <div class="loading" id="viewer-loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading 360° image...</div>
    </div>
    
    <!-- Navigation controls -->
    <div class="viewer-controls">
        <button onclick="previousImage()">← Previous</button>
        <span id="viewer-info">No images loaded</span>
        <button onclick="nextImage()">Next →</button>
    </div>
    
    <!-- Navigation ring -->
    <div class="image-controls">
        <div class="navigation-ring">
            <button class="nav-button ring-button" id="nextImageBtn">▲</button>
            <button class="nav-button ring-button" id="prevImageBtn">▼</button>
        </div>
    </div>
    
    <!-- Image counter -->
    <div class="time" id="time">-/-</div>
    
    <!-- Zoom controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" id="zoomIn">+</button>
        <button class="zoom-btn" id="zoomOut">-</button>
    </div>
</div>

    <!-- Mapbox JS -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tmcw/togeojson@4.5.0/dist/togeojson.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    

<script>
    // Initialize Mapbox
    mapboxgl.accessToken = 'pk.eyJ1IjoiYW5kcmVzbXR6YyIsImEiOiJjbWN4ZWZvc3MwNjNjMnJwd3h6ZXdyOGJoIn0.ahgRYAxpOnGnnqOjQvJZTA';

    // Global variables
    let map;
    let isEditMode = false;
    let currentMode = 'view';
    let allTracks = new Map();
    let currentTrackId = null;
    let currentDensity = 100;
    let isDragging = false;
    let dragPointId = -1;
    let nextPointId = 1000;
    let nextTrackId = 1;
    let isCatmullRomEnabled = false;
    let wasCatmullRomEnabledBeforeEdit = false;
    // ===== 360 VIEWER VARIABLES =====
let scene, camera, renderer, sphere, panoGroup;
let currentYaw = 0, currentPitch = 0, currentFov = 75;
let viewerInitialized = false;
let viewConeMarker = null;



    // Marble system variables - now track-specific
    let isDraggingMarble = false;
    let dragMarbleIndex = -1;
    let selectedMarbleId = null;

    // 360 Viewer variables
    let viewer;
    let currentImages = [];
    let currentImageIndex = -1;
    let imageAssignments = new Map(); // marbleId -> imageIndex

    // Color palette for tracks
    const trackColors = [
        '#EA4335', '#4285F4', '#34A853', '#FBBC05', '#FF6D01',
        '#46BDC6', '#9334E6', '#E67C73', '#109D58', '#3F51B5'
    ];

    // Initialize map and viewer
    function initializeApp() {
        // Initialize Mapbox map
        map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/outdoors-v12',
            center: [0, 0],
            zoom: 1,
            cooperativeGestures: false
        });

        // Wait for map to load
        map.on('load', () => {
            console.log('Map loaded successfully');
            document.getElementById('gpx-file').addEventListener('change', handleGPXUpload);
            
            // Setup density slider
            const densitySlider = document.getElementById('density-slider');
            densitySlider.addEventListener('input', handleDensityChange);
            
            // Setup marble spacing slider
            const marbleSpacingSlider = document.getElementById('marble-spacing-slider');
            marbleSpacingSlider.addEventListener('input', updateMarbleSpacing);
            
            // Create sources for tracks
            map.addSource('tracks-line', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });

            map.addSource('control-points', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });

            // Create source for marbles
            map.addSource('marbles', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });

            // Add tracks line layer
            map.addLayer({
                id: 'gpx-tracks-line',
                type: 'line',
                source: 'tracks-line',
                paint: {
                    'line-color': ['get', 'color'],
                    'line-width': ['case', ['==', ['get', 'isActive'], true], 4, 2],
                    'line-opacity': ['case', ['==', ['get', 'isActive'], true], 0.8, 0.5]
                }
            });

            // Add control points layer
            map.addLayer({
                id: 'gpx-control-points',
                type: 'circle',
                source: 'control-points',
                paint: {
                    'circle-radius': 6,
                    'circle-color': '#EA4335',
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#ffffff',
                    'circle-opacity': ['case', 
                        ['all', 
                            ['==', ['get', 'isActive'], true],
                            ['==', ['get', 'isEditMode'], true]
                        ], 1, 0
                    ]
                }
            });

            // Add marbles layer - FIXED: removed broken comment
            map.addLayer({
                id: 'marbles-layer',
                type: 'circle',
                source: 'marbles',
                paint: {
                    'circle-radius': ['case',
                        ['==', ['get', 'isDragging'], true], 7,
                        ['==', ['get', 'isSelected'], true], 6,
                        ['==', ['get', 'isFixed'], true], 5,
                        ['==', ['get', 'isLocked'], true], 4.5,
                        ['==', ['get', 'hasImage'], true], 5, // Larger for marbles with images
                        4 // Smaller for marbles without images
                    ],
                    'circle-color': ['case',
                        ['==', ['get', 'isDragging'], true], '#FFD700',
                        ['==', ['get', 'isSelected'], true], '#4285F4',
                        ['==', ['get', 'isFixed'], true], '#FF0000',
                        ['==', ['get', 'isLocked'], true], '#FF6B35',
                        ['==', ['get', 'hasImage'], true], '#34A853', // GREEN for marbles with images
                        '#8B4513' // Brown for marbles without images
                    ],
                    'circle-stroke-width': ['case',
                        ['==', ['get', 'isSelected'], true], 2,
                        ['==', ['get', 'hasImage'], true], 1, // Thin stroke for marbles with images
                        0
                    ],
                    'circle-stroke-color': '#FFFFFF'
                }
            });

            // Add a symbol layer for image numbers on marbles
map.addLayer({
    id: 'marble-labels',
    type: 'symbol',
    source: 'marbles',
    layout: {
        'text-field': ['case',
            ['==', ['get', 'hasImage'], true],
            ['concat', ['get', 'imageIndex']],
            '' // No text for marbles without images
        ],
        'text-size': 10,
        'text-offset': [1, 0],
        'text-anchor': 'center'
    },
    paint: {
        'text-color': '#FFFFFF',
        'text-halo-color': '#000000',
        'text-halo-width': 1
    }
});
  // Add marble navigation buttons
    addMarbleNavigationButtons();
            setupMapInteractions();
        });

        // Initialize 360 viewer
        initializeViewer();
    }



    // Setup map interactions
    function setupMapInteractions() {
        map.on('mouseup', () => {
            if (isDragging) {
                setTimeout(() => {
                    isDragging = false;
                    dragPointId = -1;
                    map.getCanvas().style.cursor = 'move';
                    enableMapInteractions();
                }, 50);
            }
            if (isDraggingMarble) {
                stopMarbleDrag();
            }
        });
    }

    // Handle multiple GPX file upload
    function handleGPXUpload(event) {
        const files = Array.from(event.target.files);
        if (files.length === 0) return;

        files.forEach(file => {
            const reader = new FileReader();
            reader.onload = function(e) {
                const gpxContent = e.target.result;
                parseGPX(gpxContent, file.name);
            };
            reader.readAsText(file);
        });
    }

    // Parse GPX and add as new track
    function parseGPX(gpxContent, fileName) {
        try {
            const parser = new DOMParser();
            const gpxDoc = parser.parseFromString(gpxContent, 'text/xml');
            
            // Extract ALL track points with their times
            const trkpts = gpxDoc.querySelectorAll('trkpt');
            const pointsWithTime = [];
            
            trkpts.forEach((trkpt, index) => {
                const lat = parseFloat(trkpt.getAttribute('lat'));
                const lon = parseFloat(trkpt.getAttribute('lon'));
                const timeElement = trkpt.querySelector('time');
                
                pointsWithTime.push({
                    id: index,
                    coordinates: [lon, lat],
                    originalIndex: index,
                    time: timeElement ? timeElement.textContent : null
                });
            });
            
            if (pointsWithTime.length === 0) {
                alert(`No track points found in ${fileName}`);
                return;
            }
            
            // Create track with original statistics
            const trackId = `track-${nextTrackId++}`;
            const trackColor = trackColors[(nextTrackId - 2) % trackColors.length];
            
            const trackData = {
                id: trackId,
                name: fileName.replace('.gpx', ''),
                color: trackColor,
                originalPoints: pointsWithTime,
                activePoints: [],
                density: 100,
                isActive: false,
                originalStats: calculateOriginalStatsFromPoints(pointsWithTime),
                marbles: [], // Track-specific marbles
                marbleSpacing: 10 // Track-specific marble spacing
            };
            
            // Apply initial density
            applyDensityFilterToTrack(trackData, currentDensity);
            
            // Add to tracks map
            allTracks.set(trackId, trackData);
            
            // If first track, select it
            if (allTracks.size === 1) {
                selectTrack(trackId);
            } else {
                updateTracksList();
                updateAllTracksVisualization();
                setStatus(`Loaded ${fileName} with ${trackData.originalPoints.length} points`);
            }
            
        } catch (error) {
            console.error('Error parsing GPX:', error);
            alert(`Error parsing ${fileName}. Please check the file format.`);
        }
    }

    // Calculate stats directly from points array
    function calculateOriginalStatsFromPoints(points) {
        const coordinates = points.map(p => p.coordinates);
        const timeData = points.map(p => p.time).filter(t => t);
        
        const distance = calculateTotalDistance(coordinates);
        const duration = calculateDurationFromTimes(timeData);
        const avgSpeed = calculateAverageSpeedFromStats(distance, duration);
        
        return {
            distance: distance,
            duration: duration,
            avgSpeed: avgSpeed,
            pointCount: points.length
        };
    }

    // Calculate distance between two coordinates (haversine formula) in meters
    function calculateDistance(coord1, coord2) {
        const R = 6371000; // Earth radius in meters
        const dLat = (coord2[1] - coord1[1]) * Math.PI / 180;
        const dLon = (coord2[0] - coord1[0]) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(coord1[1] * Math.PI / 180) * Math.cos(coord2[1] * Math.PI / 180) *
                  Math.sin(dLon/2) * Math.sin(dLon/2);
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    // Calculate total distance of a track in meters
    function calculateTotalDistance(points) {
        if (points.length < 2) return 0;
        
        let totalDistance = 0;
        for (let i = 1; i < points.length; i++) {
            totalDistance += calculateDistance(points[i-1], points[i]);
        }
        return totalDistance;
    }

    // Calculate duration from time array
    function calculateDurationFromTimes(timeData) {
        if (timeData.length < 2) return '0s';
        
        try {
            const startTime = new Date(timeData[0]);
            const endTime = new Date(timeData[timeData.length - 1]);
            const durationMs = endTime - startTime;
            
            const hours = Math.floor(durationMs / (1000 * 60 * 60));
            const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((durationMs % (1000 * 60)) / 1000);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m ${seconds}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds}s`;
            } else {
                return `${seconds}s`;
            }
        } catch (e) {
            return '0s';
        }
    }

    // Calculate average speed from distance and duration
    function calculateAverageSpeedFromStats(distanceMeters, durationString) {
        if (durationString === '0s' || distanceMeters === 0) return 0;
        
        try {
            let totalHours = 0;
            
            if (durationString.includes('h')) {
                const hoursMatch = durationString.match(/(\d+)h/);
                const minutesMatch = durationString.match(/(\d+)m/);
                const secondsMatch = durationString.match(/(\d+)s/);
                
                const hours = hoursMatch ? parseInt(hoursMatch[1]) : 0;
                const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
                const seconds = secondsMatch ? parseInt(secondsMatch[1]) : 0;
                
                totalHours = hours + (minutes / 60) + (seconds / 3600);
            } else if (durationString.includes('m')) {
                const minutesMatch = durationString.match(/(\d+)m/);
                const secondsMatch = durationString.match(/(\d+)s/);
                
                const minutes = minutesMatch ? parseInt(minutesMatch[1]) : 0;
                const seconds = secondsMatch ? parseInt(secondsMatch[1]) : 0;
                
                totalHours = (minutes / 60) + (seconds / 3600);
            } else if (durationString.includes('s')) {
                const secondsMatch = durationString.match(/(\d+)s/);
                const seconds = secondsMatch ? parseInt(secondsMatch[1]) : 0;
                
                totalHours = seconds / 3600;
            }
            
            const distanceKm = distanceMeters / 1000;
            return totalHours > 0 ? distanceKm / totalHours : 0;
            
        } catch (e) {
            return 0;
        }
    }

    // Apply density filter to a specific track
    function applyDensityFilterToTrack(trackData, densityPercent) {
        const totalPoints = trackData.originalPoints.length;
        const targetCount = Math.max(2, Math.floor((totalPoints * densityPercent) / 100));
        
        if (targetCount >= totalPoints) {
            trackData.activePoints = trackData.originalPoints.map(p => ({...p}));
        } else {
            trackData.activePoints = selectPointsEvenlyImproved(trackData.originalPoints, targetCount);
        }
        
        trackData.density = densityPercent;
    }

    // Select points evenly distributed
    function selectPointsEvenlyImproved(points, targetCount) {
        if (points.length <= targetCount) return points.map(p => ({...p}));
        if (targetCount <= 2) return [points[0], points[points.length - 1]].map(p => ({...p}));
        
        const selected = [];
        const totalSegments = targetCount - 1;
        const segmentSize = (points.length - 1) / totalSegments;
        
        selected.push({...points[0]});
        
        for (let i = 1; i < targetCount - 1; i++) {
            const index = Math.round(i * segmentSize);
            const safeIndex = Math.min(Math.max(index, 1), points.length - 2);
            selected.push({...points[safeIndex]});
        }
        
        selected.push({...points[points.length - 1]});
        
        return removeDuplicatesPreserveOrder(selected);
    }

    // Remove duplicates while preserving order
    function removeDuplicatesPreserveOrder(points) {
        const unique = [];
        const seenIds = new Set();
        
        for (const point of points) {
            if (!seenIds.has(point.id)) {
                unique.push(point);
                seenIds.add(point.id);
            }
        }
        
        return unique;
    }

    // Calculate bounds from coordinates
    function calculateBounds(coordinates) {
        if (coordinates.length === 0) return null;
        
        const bounds = new mapboxgl.LngLatBounds();
        coordinates.forEach(coord => {
            bounds.extend(coord);
        });
        return bounds;
    }

    // Fly to track bounds
    function flyToTrack(trackData) {
        const coordinates = trackData.activePoints.map(p => p.coordinates);
        const bounds = calculateBounds(coordinates);
        
        if (bounds) {
            map.fitBounds(bounds, {
                padding: 50,
                duration: 1000,
                essential: true
            });
        }
    }

    // Select a track for editing
    function selectTrack(trackId) {
        // Deselect previous track
        if (currentTrackId && allTracks.has(currentTrackId)) {
            allTracks.get(currentTrackId).isActive = false;
        }
        
        // Select new track
        currentTrackId = trackId;
        const track = allTracks.get(trackId);
        track.isActive = true;
        
        // Update density slider to match selected track
        currentDensity = track.density;
        document.getElementById('density-slider').value = currentDensity;
        document.getElementById('density-value').textContent = currentDensity + '%';
        
        // Update marble spacing slider to match current track
        document.getElementById('marble-spacing-slider').value = track.marbleSpacing;
        document.getElementById('marble-spacing').textContent = track.marbleSpacing;
        
        // Update point counts
        document.getElementById('points-count').textContent = track.activePoints.length + ' points';
        document.getElementById('original-count').textContent = 'of ' + track.originalPoints.length;

        updateStatistics();
        
        // Reset edit mode but KEEP Catmull-Rom state
        if (isEditMode) {
            disableEditing();
            isEditMode = false;
            document.getElementById('edit-btn').textContent = 'Edit Mode: OFF';
            document.getElementById('edit-btn').classList.remove('active');
        }

        // Keep Catmull-Rom state as is
        document.getElementById('catmull-btn').textContent = isCatmullRomEnabled ? 'Catmull-Rom: ON' : 'Catmull-Rom: OFF';
        document.getElementById('catmull-btn').classList.toggle('active', isCatmullRomEnabled);
        
        // Clear marble selection state (but keep the track's marbles)
        selectedMarbleId = null;
        isDraggingMarble = false;
        dragMarbleIndex = -1;
        
        updateTracksList();
        updateAllTracksVisualization();
        updateMarbleDisplay(); // Show current track's marbles
        
        // FLY TO THE TRACK BOUNDS
        flyToTrack(track);
        
        // AUTO-LOAD IMAGES WHEN TRACK IS SELECTED
        if (currentImages.length === 0) {
            load360Images();
        }
        
        setStatus(`Selected: ${track.name} - ${track.marbles.length} marbles`);
    }

    // Update statistics display
    function updateStatistics() {
        const track = getCurrentTrack();
        if (!track) {
            clearStatistics();
            return;
        }
        
        const stats = track.originalStats;
        const distanceKm = stats.distance / 1000;
        
        document.getElementById('total-distance').textContent = 
            distanceKm < 1 ? 
            `${stats.distance.toFixed(0)} m` : 
            `${distanceKm.toFixed(2)} km`;
        
        document.getElementById('avg-speed').textContent = 
            `${stats.avgSpeed.toFixed(1)} km/h`;
        
        document.getElementById('stats-points').textContent = 
            stats.pointCount;
        
        document.getElementById('total-duration').textContent = 
            stats.duration;
    }

    // Clear statistics when no track is selected
    function clearStatistics() {
        document.getElementById('total-distance').textContent = '0 km';
        document.getElementById('avg-speed').textContent = '0 km/h';
        document.getElementById('stats-points').textContent = '0';
        document.getElementById('total-duration').textContent = '0s';
    }

    // Remove a track
    function removeTrack(trackId) {
        allTracks.delete(trackId);
        
        if (currentTrackId === trackId) {
            currentTrackId = null;
            if (allTracks.size > 0) {
                selectTrack(Array.from(allTracks.keys())[0]);
            } else {
                document.getElementById('points-count').textContent = '0 points';
                document.getElementById('original-count').textContent = '';
                isCatmullRomEnabled = false;
                document.getElementById('catmull-btn').textContent = 'Catmull-Rom: OFF';
                document.getElementById('catmull-btn').classList.remove('active');
                clearStatistics();
            }
        }
        
        updateTracksList();
        updateAllTracksVisualization();
    }

    // Update tracks list UI
    function updateTracksList() {
        const tracksList = document.getElementById('tracks-list');
        tracksList.innerHTML = '';
        
        if (allTracks.size === 0) {
            tracksList.innerHTML = '<div style="text-align: center; padding: 10px; color: #666; font-size: 12px;">No tracks loaded</div>';
            return;
        }
        
        allTracks.forEach((track, trackId) => {
            const trackItem = document.createElement('div');
            trackItem.className = `track-item ${track.isActive ? 'track-active' : ''}`;
            trackItem.innerHTML = `
                <div class="track-info">
                    <div class="track-color" style="background-color: ${track.color}"></div>
                    <span title="${track.name}">${track.name.length > 20 ? track.name.substring(0, 20) + '...' : track.name}</span>
                </div>
                <div class="track-actions">
                    <button class="small-btn" onclick="selectTrack('${trackId}')">Edit</button>
                    <button class="small-btn" onclick="exportSingleTrack('${trackId}')" title="Export this track">💾</button>
                    <button class="small-btn" onclick="removeTrack('${trackId}')">×</button>
                </div>
            `;
            
            trackItem.onclick = (e) => {
                if (!e.target.closest('.track-actions')) {
                    selectTrack(trackId);
                }
            };
            
            tracksList.appendChild(trackItem);
        });
    }

    // Get current track data
    function getCurrentTrack() {
        return currentTrackId ? allTracks.get(currentTrackId) : null;
    }

    // Get current track's marbles
    function getCurrentMarbles() {
        const track = getCurrentTrack();
        return track ? track.marbles : [];
    }

    // Update visualization of all tracks
    function updateAllTracksVisualization(fitBounds = false) {
        if (!map.getSource('tracks-line')) return;

        const features = [];
        let activeTrackCoordinates = [];
        
        allTracks.forEach(track => {
            let displayCoordinates;
            
            if (isCatmullRomEnabled) {
                displayCoordinates = catmullRomSmooth(
                    track.activePoints.map(p => p.coordinates), 
                    15, 
                    0.5
                );
            } else {
                displayCoordinates = track.activePoints.map(p => p.coordinates);
            }
            
            if (track.isActive) {
                activeTrackCoordinates = displayCoordinates;
            }
            
            features.push({
                type: 'Feature',
                geometry: {
                    type: 'LineString',
                    coordinates: displayCoordinates
                },
                properties: {
                    trackId: track.id,
                    color: track.color,
                    isActive: track.isActive
                }
            });
        });
        
        map.getSource('tracks-line').setData({
            type: 'FeatureCollection',
            features: features
        });

        // Update control points for active track
        const track = getCurrentTrack();
        if (track && isEditMode) {
            const controlPointFeatures = track.activePoints.map((point, index) => {
                return {
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: point.coordinates
                    },
                    properties: {
                        id: point.id,
                        trackId: track.id,
                        isActive: true,
                        isEditMode: isEditMode
                    }
                };
            });

            map.getSource('control-points').setData({
                type: 'FeatureCollection',
                features: controlPointFeatures
            });
        } else {
            map.getSource('control-points').setData({
                type: 'FeatureCollection',
                features: []
            });
        }

        if (fitBounds && activeTrackCoordinates.length > 0) {
            const bounds = calculateBounds(activeTrackCoordinates);
            if (bounds) {
                map.fitBounds(bounds, { padding: 50, duration: 1000 });
            }
        }
    }

    // Handle density slider change for current track
    function handleDensityChange(e) {
        currentDensity = parseInt(e.target.value);
        document.getElementById('density-value').textContent = currentDensity + '%';
        
        const track = getCurrentTrack();
        if (track) {
            wasCatmullRomEnabledBeforeEdit = isCatmullRomEnabled;
            
            applyDensityFilterToTrack(track, currentDensity);
            updateAllTracksVisualization(false);
            
            document.getElementById('points-count').textContent = track.activePoints.length + ' points';
            document.getElementById('original-count').textContent = 'of ' + track.originalPoints.length;
            
            if (wasCatmullRomEnabledBeforeEdit) {
                setTimeout(() => enableCatmullRom(), 10);
            }
        }
    }

    // Catmull-Rom smoothing
    function catmullRomSmooth(points, segments = 20, tension = 0.5) {
        if (points.length < 3) return points;
        
        const smoothed = [points[0]];
        
        for (let i = 0; i < points.length - 1; i++) {
            const p0 = i > 0 ? points[i - 1] : points[i];
            const p1 = points[i];
            const p2 = points[i + 1];
            const p3 = i < points.length - 2 ? points[i + 2] : p2;
            
            for (let t = 1; t <= segments; t++) {
                const percentage = t / segments;
                
                const x = catmullRom(percentage, p0[0], p1[0], p2[0], p3[0], tension);
                const y = catmullRom(percentage, p0[1], p1[1], p2[1], p3[1], tension);
                
                smoothed.push([x, y]);
            }
        }
        
        smoothed.push(points[points.length - 1]);
        return smoothed;
    }

    function catmullRom(t, p0, p1, p2, p3, tension) {
        const v0 = (p2 - p0) * tension;
        const v1 = (p3 - p1) * tension;
        const t2 = t * t;
        const t3 = t * t2;
        
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + 
               (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + 
               v0 * t + p1;
    }

    // Toggle Catmull-Rom for current track
    function toggleCatmullRom() {
        const track = getCurrentTrack();
        if (!track) {
            setStatus('Please select a track first!');
            return;
        }
        
        if (isCatmullRomEnabled) {
            disableCatmullRom();
        } else {
            enableCatmullRom();
        }
    }

    function enableCatmullRom() {
        isCatmullRomEnabled = true;
        document.getElementById('catmull-btn').textContent = 'Catmull-Rom: ON';
        document.getElementById('catmull-btn').classList.add('active');
        updateAllTracksVisualization(false);
        
        // Rebuild marbles on the smoothed track
        const track = getCurrentTrack();
        if (track && track.marbles.length > 0) {
            initializeMarbles();
        }
        
        setStatus('Catmull-Rom smoothing applied to current track');
    }

    function disableCatmullRom() {
        isCatmullRomEnabled = false;
        document.getElementById('catmull-btn').textContent = 'Catmull-Rom: OFF';
        document.getElementById('catmull-btn').classList.remove('active');
        updateAllTracksVisualization(false);
        
        // Rebuild marbles on the original track
        const track = getCurrentTrack();
        if (track && track.marbles.length > 0) {
            initializeMarbles();
        }
        
        setStatus('Catmull-Rom smoothing disabled');
    }

    // Clear marbles when edit mode is toggled
    function toggleEditMode() {
        const track = getCurrentTrack();
        if (!track) {
            setStatus('Please select a track first!');
            return;
        }

        isEditMode = !isEditMode;
        const btn = document.getElementById('edit-btn');
        
        if (isEditMode) {
            btn.textContent = 'Edit Mode: ON';
            btn.classList.add('active');
            enableEditing();
            
            // Clear marbles when entering edit mode
            if (track.marbles.length > 0) {
                setStatus('Editing track - marbles cleared. Rebuild after finishing edits.');
                track.marbles = [];
                updateMarbleDisplay();
            }
            
            setStatus(`Editing: ${track.name} - Marbles will be cleared`);
        } else {
            btn.textContent = 'Edit Mode: OFF';
            btn.classList.remove('active');
            disableEditing();
            setStatus('Edit mode disabled - Click "Rebuild Marbles" to add photo markers');
        }
        
        updateAllTracksVisualization(false);
    }

    // Enable editing functionality
    function enableEditing() {
        map.getCanvas().style.cursor = 'crosshair';
    }

    // Disable editing functionality
    function disableEditing() {
        map.getCanvas().style.cursor = '';
        currentMode = 'view';
        
        map.off('click', handlePointAdd);
        map.off('click', handlePointRemove);
        map.off('mousedown', startPointDrag);
        map.off('mousemove', handlePointDrag);
        map.off('mouseup', stopPointDrag);
    }

    // Set current editing mode
    function addPointMode() {
        if (!isEditMode || !getCurrentTrack()) return;
        currentMode = 'add';
        map.getCanvas().style.cursor = 'crosshair';
        setStatus('Add Points: Click on map to add points to current track');
        
        wasCatmullRomEnabledBeforeEdit = isCatmullRomEnabled;
        
        map.off('click', handlePointRemove);
        map.off('mousedown', startPointDrag);
        map.off('mousemove', handlePointDrag);
        map.off('mouseup', stopPointDrag);
        map.off('click', handlePointAdd);
        map.on('click', handlePointAdd);
    }

    function removePointMode() {
        if (!isEditMode || !getCurrentTrack()) return;
        currentMode = 'remove';
        map.getCanvas().style.cursor = 'not-allowed';
        setStatus('Remove Points: Click on points to remove them');
        
        wasCatmullRomEnabledBeforeEdit = isCatmullRomEnabled;
        
        map.off('mousedown', startPointDrag);
        map.off('mousemove', handlePointDrag);
        map.off('mouseup', stopPointDrag);
        map.off('click', handlePointAdd);
        map.off('click', handlePointRemove);
        map.on('click', handlePointRemove);
    }

    function movePointMode() {
        if (!isEditMode || !getCurrentTrack()) return;
        currentMode = 'move';
        map.getCanvas().style.cursor = 'move';
        setStatus('Move Points: Click and drag points to move them');
        
        wasCatmullRomEnabledBeforeEdit = isCatmullRomEnabled;
        
        map.off('click', handlePointAdd);
        map.off('click', handlePointRemove);
        map.off('mousedown', startPointDrag);
        map.off('mousemove', handlePointDrag);
        map.off('mouseup', stopPointDrag);
        
        enablePointDragging();
    }

    // Handle adding points to current track
    function handlePointAdd(e) {
        if (currentMode !== 'add') return;
        const track = getCurrentTrack();
        if (!track) return;
        
        if (isCatmullRomEnabled) {
            disableCatmullRom();
        }
        
        const newPoint = {
            id: nextPointId++,
            coordinates: [e.lngLat.lng, e.lngLat.lat],
            originalIndex: -1
        };
        
        const insertIndex = findBestInsertPosition(newPoint.coordinates, track.activePoints);
        track.activePoints.splice(insertIndex, 0, newPoint);
        
        updateAllTracksVisualization(false);
        
        if (wasCatmullRomEnabledBeforeEdit) {
            setTimeout(() => enableCatmullRom(), 10);
        }
        
        document.getElementById('points-count').textContent = track.activePoints.length + ' points';
        setStatus(`Point added. Total: ${track.activePoints.length}`);
    }

    // Find best position to insert point
    function findBestInsertPosition(newCoord, points) {
        if (points.length < 2) return points.length;
        
        let bestIndex = points.length - 1;
        let minDistance = Infinity;
        
        for (let i = 0; i < points.length - 1; i++) {
            const segmentStart = points[i].coordinates;
            const segmentEnd = points[i + 1].coordinates;
            const distance = distanceToSegment(newCoord, segmentStart, segmentEnd);
            
            if (distance < minDistance) {
                minDistance = distance;
                bestIndex = i + 1;
            }
        }
        
        return bestIndex;
    }

    // Calculate distance from point to line segment
    function distanceToSegment(point, segmentStart, segmentEnd) {
        const A = point[0] - segmentStart[0];
        const B = point[1] - segmentStart[1];
        const C = segmentEnd[0] - segmentStart[0];
        const D = segmentEnd[1] - segmentStart[1];

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) param = dot / lenSq;

        let xx, yy;

        if (param < 0) {
            xx = segmentStart[0];
            yy = segmentStart[1];
        } else if (param > 1) {
            xx = segmentEnd[0];
            yy = segmentEnd[1];
        } else {
            xx = segmentStart[0] + param * C;
            yy = segmentStart[1] + param * D;
        }

        const dx = point[0] - xx;
        const dy = point[1] - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // Handle removing points from current track
    function handlePointRemove(e) {
        if (currentMode !== 'remove') return;
        const track = getCurrentTrack();
        if (!track) return;
        
        if (isCatmullRomEnabled) {
            disableCatmullRom();
        }
        
        const features = map.queryRenderedFeatures(e.point, {
            layers: ['gpx-control-points']
        });
        
        if (features.length > 0) {
            const pointId = features[0].properties.id;
            const pointIndex = track.activePoints.findIndex(p => p.id === pointId);
            
            if (pointIndex !== -1 && track.activePoints.length > 2) {
                track.activePoints.splice(pointIndex, 1);
                updateAllTracksVisualization(false);
                
                if (wasCatmullRomEnabledBeforeEdit) {
                    setTimeout(() => enableCatmullRom(), 10);
                }
                
                document.getElementById('points-count').textContent = track.activePoints.length + ' points';
                setStatus(`Point removed. Total: ${track.activePoints.length}`);
            } else if (track.activePoints.length <= 2) {
                setStatus('Cannot remove point - track must have at least 2 points');
            }
        }
    }

    // Enable point dragging
    function enablePointDragging() {
        map.on('mousedown', 'gpx-control-points', startPointDrag);
        map.on('mousemove', handlePointDrag);
        map.on('mouseup', stopPointDrag);
    }

    function startPointDrag(e) {
        if (currentMode !== 'move') return;
        const track = getCurrentTrack();
        if (!track) return;
        
        if (isCatmullRomEnabled) {
            disableCatmullRom();
        }
        
        e.preventDefault();
        isDragging = true;
        dragPointId = e.features[0].properties.id;
        map.getCanvas().style.cursor = 'grabbing';
        disableMapInteractions();
    }

    function handlePointDrag(e) {
        if (!isDragging || dragPointId === -1) return;
        const track = getCurrentTrack();
        if (!track) return;
        
        const pointIndex = track.activePoints.findIndex(p => p.id === dragPointId);
        if (pointIndex !== -1) {
            track.activePoints[pointIndex].coordinates = [e.lngLat.lng, e.lngLat.lat];
            updateAllTracksVisualization(false);
        }
    }

    function stopPointDrag() {
        if (isDragging) {
            isDragging = false;
            dragPointId = -1;
            map.getCanvas().style.cursor = 'move';
            enableMapInteractions();
            
            if (wasCatmullRomEnabledBeforeEdit) {
                setTimeout(() => enableCatmullRom(), 10);
            }
            
            setStatus('Point moved');
        }
    }

    // Reset current track to original
    function resetCurrentTrack() {
        const track = getCurrentTrack();
        if (track) {
            applyDensityFilterToTrack(track, 100);
            currentDensity = 100;
            document.getElementById('density-slider').value = 100;
            document.getElementById('density-value').textContent = '100%';
            document.getElementById('points-count').textContent = track.activePoints.length + ' points';
            updateAllTracksVisualization(false);
            setStatus(`Reset ${track.name} to original`);
        }
    }

    // Clear all tracks
    function clearAllRoutes() {
        allTracks.clear();
        currentTrackId = null;
        resetState();
        updateTracksList();
        updateAllTracksVisualization(false);
        setStatus('All tracks cleared');
    }

    // Reset state
    function resetState() {
        currentDensity = 100;
        isCatmullRomEnabled = false;
        wasCatmullRomEnabledBeforeEdit = false;
        document.getElementById('density-slider').value = 100;
        document.getElementById('density-value').textContent = '100%';
        document.getElementById('catmull-btn').textContent = 'Catmull-Rom: OFF';
        document.getElementById('catmull-btn').classList.remove('active');
        document.getElementById('points-count').textContent = '0 points';
        document.getElementById('original-count').textContent = '';
        
        // Clear marble selection state
        selectedMarbleId = null;
        isDraggingMarble = false;
        dragMarbleIndex = -1;
        updateMarbleDisplay();
    }

    function setStatus(message) {
        document.getElementById('status').textContent = message;
    }

    // Map interaction control functions
    function disableMapInteractions() {
        if (isDragging) {
            map.dragPan.disable();
            map.scrollZoom.disable();
            map.dragRotate.disable();
            map.boxZoom.disable();
            map.doubleClickZoom.disable();
        }
    }

    function enableMapInteractions() {
        if (!isDragging) {
            map.dragPan.enable();
            map.scrollZoom.enable();
            map.dragRotate.enable();
            map.boxZoom.enable();
            map.doubleClickZoom.enable();
        }
    }

    // ========== MARBLE SYSTEM FUNCTIONS ==========

    function initializeMarbles() {
        const track = getCurrentTrack();
        if (!track) {
            setStatus('Please select a track first!');
            return;
        }
        
        track.marbles = [];
        const coordinates = getDisplayCoordinates(track);
        const totalDistance = calculateTotalDistance(coordinates);
        
        // Always create at least 2 marbles (start and end)
        const marbleCount = Math.max(2, Math.floor(totalDistance / track.marbleSpacing) + 1);
        
        for (let i = 0; i < marbleCount; i++) {
            let targetDistance;
            if (i === 0) {
                targetDistance = 0;
            } else if (i === marbleCount - 1) {
                targetDistance = totalDistance;
            } else {
                targetDistance = (i / (marbleCount - 1)) * totalDistance;
            }
            
            const position = findPositionAtDistance(coordinates, targetDistance);
            
            track.marbles.push({
                id: Date.now() + i,
                index: i,
                position: position,
                distanceAlongRoute: targetDistance,
                isLocked: (i === 0 || i === marbleCount - 1),
                isFixed: (i === 0 || i === marbleCount - 1),
                assignedImage: null
            });
        }
        
        updateMarbleDisplay();
        
        // AUTO-LOAD AND ASSIGN IMAGES WHEN MARBLES ARE CREATED
        load360Images(); // Always try to load images when marbles are created
        
        setStatus(`Created ${track.marbles.length} marbles - loading images...`);
    }

    function getDisplayCoordinates(track) {
        if (isCatmullRomEnabled) {
            return catmullRomSmooth(
                track.activePoints.map(p => p.coordinates), 
                15, 
                0.5
            );
        } else {
            return track.activePoints.map(p => p.coordinates);
        }
    }

function addMarble() {
    const track = getCurrentTrack();
    if (!track) {
        setStatus('Please select a track first!');
        return;
    }
    
    const marbles = track.marbles;
    const coordinates = getDisplayCoordinates(track);
    const totalDistance = calculateTotalDistance(coordinates);
    
    if (marbles.length === 0) {
        initializeMarbles();
        return;
    }
    
    // ADD AT THE END (not in the middle)
    const lastMarble = marbles[marbles.length - 1];
    const newDistance = lastMarble.distanceAlongRoute + track.marbleSpacing;
    
    // Make sure we don't exceed the track length
    const maxDistance = totalDistance;
    const safeDistance = Math.min(newDistance, maxDistance);
    
    const newMarble = {
        id: Date.now(),
        index: marbles.length,
        position: findPositionAtDistance(coordinates, safeDistance),
        distanceAlongRoute: safeDistance,
        isLocked: false,
        isFixed: false,
        assignedImage: null
    };
    
    // Add to the END of the array
    track.marbles.push(newMarble);
    
    // AUTO-RESPACE ALL MARBLES AFTER ADDING
    respaceAllMarbles();
    
    updateMarbleDisplay();
    setStatus(`Added marble - ${track.marbles.length} total (auto-respaced)`);
    
    // Auto-assign image if available
    autoAssignImageToNewMarble();
}

function autoAssignImageToNewMarble() {
    const track = getCurrentTrack();
    if (!track) return;
    
    const marbles = track.marbles;
    const newMarble = marbles[marbles.length - 1]; // The one we just added
    
    // Find the next available image
    const usedImageIndices = new Set(marbles.map(m => m.assignedImage).filter(i => i !== null));
    let nextAvailableImage = 0;
    
    while (usedImageIndices.has(nextAvailableImage) && nextAvailableImage < currentImages.length) {
        nextAvailableImage++;
    }
    
    // Assign if we have an available image
    if (nextAvailableImage < currentImages.length) {
        newMarble.assignedImage = nextAvailableImage;
        setStatus(`Assigned image ${nextAvailableImage + 1} to new marble`);
    } else {
        setStatus('No more images available for new marble');
    }
    
    updateMarbleDisplay();
}

function removeMarble() {
    const track = getCurrentTrack();
    if (!track) return;
    
    const marbles = track.marbles;
    if (marbles.length <= 2) {
        setStatus('Cannot remove - must keep start and end marbles');
        return;
    }
    
    // REMOVE FROM THE END (not from the middle)
    let removeIndex = marbles.length - 1;
    
    // Find the last removable marble (not fixed)
    while (removeIndex > 0 && marbles[removeIndex].isFixed) {
        removeIndex--;
    }
    
    // Can't remove if we're at the first marble
    if (removeIndex <= 0) {
        setStatus('Cannot remove - only fixed marbles remain');
        return;
    }
    
    const removedMarble = marbles[removeIndex];
    const removedImageIndex = removedMarble.assignedImage;
    
    // Remove from the array
    track.marbles.splice(removeIndex, 1);
    
    // AUTO-RESPACE ALL MARBLES AFTER REMOVING
    respaceAllMarbles();
    
    // Re-index all marbles
    track.marbles.forEach((marble, index) => {
        marble.index = index;
    });
    
    // SHIFT IMAGE ASSIGNMENTS DOWN
    if (removedImageIndex !== null) {
        marbles.forEach(marble => {
            // If this marble had an image index HIGHER than the removed one, shift it down
            if (marble.assignedImage !== null && marble.assignedImage > removedImageIndex) {
                marble.assignedImage = marble.assignedImage - 1;
            }
        });
        setStatus(`Removed marble with image ${removedImageIndex + 1} - shifted higher images down`);
    } else {
        setStatus(`Removed marble without image - ${track.marbles.length} total`);
    }
    
    updateMarbleDisplay();
}


function respaceAllMarbles() {
    const track = getCurrentTrack();
    if (!track || track.marbles.length < 2) return;
    
    const marbles = track.marbles;
    const coordinates = getDisplayCoordinates(track);
    const totalDistance = calculateTotalDistance(coordinates);
    
    // Simple approach: space all marbles evenly along the entire track
    for (let i = 0; i < marbles.length; i++) {
        const ratio = i / (marbles.length - 1);
        marbles[i].distanceAlongRoute = ratio * totalDistance;
        marbles[i].position = findPositionAtDistance(coordinates, marbles[i].distanceAlongRoute);
        marbles[i].index = i;
        
        // Keep first and last marbles fixed
        marbles[i].isFixed = (i === 0 || i === marbles.length - 1);
    }
}

function updateMarbleSpacing() {
    const track = getCurrentTrack();
    if (!track) return;
    
    const spacingSlider = document.getElementById('marble-spacing-slider');
    track.marbleSpacing = parseInt(spacingSlider.value);
    document.getElementById('marble-spacing').textContent = track.marbleSpacing;
    
    if (track.marbles.length > 0) {
        initializeMarbles(); // Rebuild with new spacing
    }
}

    function toggleMarbleLock(marbleId) {
        const track = getCurrentTrack();
        if (!track) return;
        
        const marbleIndex = track.marbles.findIndex(m => m.id === marbleId);
        if (marbleIndex !== -1 && marbleIndex !== 0 && marbleIndex !== track.marbles.length - 1) {
            track.marbles[marbleIndex].isLocked = !track.marbles[marbleIndex].isLocked;
            updateMarbleDisplay();
            setStatus(`Marble #${marbleIndex + 1} ${track.marbles[marbleIndex].isLocked ? 'locked' : 'unlocked'}`);
        }
    }

    // UPDATED: Handle marble click to show assigned image
function handleMarbleClick(e) {
    if (e.features.length > 0) {
        const marbleId = e.features[0].properties.id;
        
        // If Ctrl/Cmd click, toggle lock
        if (e.originalEvent.ctrlKey || e.originalEvent.metaKey) {
            toggleMarbleLock(marbleId);
            return;
        }
        
        // Regular click - select marble AND show its image
        selectMarble(marbleId);
        showMarbleImage(marbleId); // This now shows the 360 image
        
        // Also enable keyboard navigation between marbles
        enableMarbleNavigation();
    } else {
        deselectMarble();
    }
}

// Add marble keyboard navigation
function enableMarbleNavigation() {
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            navigateToAdjacentMarble(e.key === 'ArrowDown');
        }
    });
}

function navigateToAdjacentMarble(goForward) {
    const track = getCurrentTrack();
    if (!track || !selectedMarbleId) return;
    
    const marbles = track.marbles;
    const currentIndex = marbles.findIndex(m => m.id === selectedMarbleId);
    
    if (currentIndex === -1) return;
    
    let nextIndex = goForward ? currentIndex + 1 : currentIndex - 1;
    
    // Wrap around
    if (nextIndex < 0) nextIndex = marbles.length - 1;
    if (nextIndex >= marbles.length) nextIndex = 0;
    
    const nextMarble = marbles[nextIndex];
    selectMarble(nextMarble.id);
    showMarbleImage(nextMarble.id);
}

    function selectMarble(marbleId) {
        selectedMarbleId = marbleId;
        const track = getCurrentTrack();
        if (!track) return;
        
        const marbleIndex = track.marbles.findIndex(m => m.id === marbleId);
        
        if (marbleIndex !== -1) {
            updateMarbleDisplay();
            setStatus(`Selected marble #${marbleIndex + 1} - Drag to move or Ctrl+Click to lock`);
        }
    }

    function deselectMarble() {
        selectedMarbleId = null;
        updateMarbleDisplay();
        setStatus('Marble deselected');
    }

    function startMarbleDrag(marbleId) {
        // Only allow dragging if this marble is selected AND not locked
        if (marbleId !== selectedMarbleId) return;
        
        const track = getCurrentTrack();
        if (!track) return;
        
        const marbleIndex = track.marbles.findIndex(m => m.id === marbleId);
        if (marbleIndex === -1) return;
        
        const marble = track.marbles[marbleIndex];
        if (marble.isLocked) {
            setStatus('Marble is locked - cannot drag');
            return;
        }
        
        isDraggingMarble = true;
        dragMarbleIndex = marbleIndex;
        marble.isDragging = true;
        
        updateMarbleDisplay();
        setStatus(`Dragging marble #${marble.index + 1}`);
        
        // Prevent map dragging
        map.dragPan.disable();
        map.scrollZoom.disable();
        map.getCanvas().style.cursor = 'grabbing';
    }

    function handleMarbleDrag(e) {
        if (!isDraggingMarble || dragMarbleIndex === -1) return;
        
        const track = getCurrentTrack();
        if (!track) return;
        
        const coordinates = getDisplayCoordinates(track);
        const closestPoint = findClosestPointOnRoute([e.lngLat.lng, e.lngLat.lat], coordinates);
        
        if (closestPoint) {
            const totalDistance = calculateTotalDistance(coordinates);
            
            // Find boundaries: previous locked marble or start, next locked marble or end
            let prevBoundaryIndex = -1;
            let nextBoundaryIndex = -1;
            
            // Find previous boundary (locked marble or start)
            for (let i = dragMarbleIndex - 1; i >= 0; i--) {
                if (track.marbles[i].isLocked || i === 0) {
                    prevBoundaryIndex = i;
                    break;
                }
            }
            
            // Find next boundary (locked marble or end)
            for (let i = dragMarbleIndex + 1; i < track.marbles.length; i++) {
                if (track.marbles[i].isLocked || i === track.marbles.length - 1) {
                    nextBoundaryIndex = i;
                    break;
                }
            }
            
            // Constrain movement between boundaries
            const minDistance = prevBoundaryIndex !== -1 ? track.marbles[prevBoundaryIndex].distanceAlongRoute : 0;
            const maxDistance = nextBoundaryIndex !== -1 ? track.marbles[nextBoundaryIndex].distanceAlongRoute : totalDistance;
            
            const safeDistance = Math.max(minDistance, Math.min(closestPoint.distance, maxDistance));
            
            track.marbles[dragMarbleIndex].position = findPositionAtDistance(coordinates, safeDistance);
            track.marbles[dragMarbleIndex].distanceAlongRoute = safeDistance;
            
            // Redistribute only UNLOCKED marbles between boundaries
            redistributeMarbles();
            updateMarbleDisplay();
        }
    }

    function stopMarbleDrag() {
        if (isDraggingMarble) {
            isDraggingMarble = false;
            
            const track = getCurrentTrack();
            if (track && dragMarbleIndex !== -1) {
                track.marbles[dragMarbleIndex].isDragging = false;
            }
            
            dragMarbleIndex = -1;
            updateMarbleDisplay();
            
            // Re-enable map
            map.dragPan.enable();
            map.scrollZoom.enable();
            map.getCanvas().style.cursor = '';
            
            setStatus('Marble moved - still selected');
        }
    }

    function redistributeMarbles() {
        const track = getCurrentTrack();
        if (!track || track.marbles.length < 3 || dragMarbleIndex === -1) return;
        
        const movedMarble = track.marbles[dragMarbleIndex];
        const coordinates = getDisplayCoordinates(track);
        
        // Find boundaries around the moved marble
        let prevBoundaryIndex = -1;
        let nextBoundaryIndex = -1;
        
        // Find previous boundary (locked marble or start)
        for (let i = dragMarbleIndex - 1; i >= 0; i--) {
            if (track.marbles[i].isLocked || i === 0) {
                prevBoundaryIndex = i;
                break;
            }
        }
        
        // Find next boundary (locked marble or end)
        for (let i = dragMarbleIndex + 1; i < track.marbles.length; i++) {
            if (track.marbles[i].isLocked || i === track.marbles.length - 1) {
                nextBoundaryIndex = i;
                break;
            }
        }
        
        if (prevBoundaryIndex !== -1 && nextBoundaryIndex !== -1) {
            const startDistance = track.marbles[prevBoundaryIndex].distanceAlongRoute;
            const endDistance = track.marbles[nextBoundaryIndex].distanceAlongRoute;
            const segmentDistance = endDistance - startDistance;
            
            // Get UNLOCKED marbles between boundaries (excluding the moved one)
            const unlockedMarbles = [];
            for (let i = prevBoundaryIndex + 1; i < nextBoundaryIndex; i++) {
                if (i !== dragMarbleIndex && !track.marbles[i].isLocked) {
                    unlockedMarbles.push({ index: i, marble: track.marbles[i] });
                }
            }
            
            // Redistribute unlocked marbles proportionally
            if (unlockedMarbles.length > 0) {
                const beforeUnlocked = unlockedMarbles.filter(u => u.index < dragMarbleIndex);
                const afterUnlocked = unlockedMarbles.filter(u => u.index > dragMarbleIndex);
                
                // Redistribute marbles BEFORE the moved one
                if (beforeUnlocked.length > 0) {
                    const beforeSegmentDistance = movedMarble.distanceAlongRoute - startDistance;
                    beforeUnlocked.forEach((u, i) => {
                        const ratio = (i + 1) / (beforeUnlocked.length + 1);
                        u.marble.distanceAlongRoute = startDistance + (beforeSegmentDistance * ratio);
                        u.marble.position = findPositionAtDistance(coordinates, u.marble.distanceAlongRoute);
                    });
                }
                
                // Redistribute marbles AFTER the moved one
                if (afterUnlocked.length > 0) {
                    const afterSegmentDistance = endDistance - movedMarble.distanceAlongRoute;
                    afterUnlocked.forEach((u, i) => {
                        const ratio = (i + 1) / (afterUnlocked.length + 1);
                        u.marble.distanceAlongRoute = movedMarble.distanceAlongRoute + (afterSegmentDistance * ratio);
                        u.marble.position = findPositionAtDistance(coordinates, u.marble.distanceAlongRoute);
                    });
                }
            }
        }
    }

    // Find coordinate at specific distance along route
    function findPositionAtDistance(coordinates, targetDistance) {
        if (coordinates.length < 2) return coordinates[0];
        
        let accumulatedDistance = 0;
        
        for (let i = 1; i < coordinates.length; i++) {
            const segmentStart = coordinates[i-1];
            const segmentEnd = coordinates[i];
            const segmentDistance = calculateDistance(segmentStart, segmentEnd);
            
            if (accumulatedDistance + segmentDistance >= targetDistance) {
                const ratio = (targetDistance - accumulatedDistance) / segmentDistance;
                return [
                    segmentStart[0] + (segmentEnd[0] - segmentStart[0]) * ratio,
                    segmentStart[1] + (segmentEnd[1] - segmentStart[1]) * ratio
                ];
            }
            
            accumulatedDistance += segmentDistance;
        }
        
        return coordinates[coordinates.length - 1];
    }

    // Find closest point on route to a given point
    function findClosestPointOnRoute(point, coordinates) {
        let closestPoint = null;
        let minDistance = Infinity;
        let accumulatedDistance = 0;
        
        for (let i = 1; i < coordinates.length; i++) {
            const segmentStart = coordinates[i-1];
            const segmentEnd = coordinates[i];
            const segmentDistance = calculateDistance(segmentStart, segmentEnd);
            
            const closestOnSegment = findClosestPointOnSegment(point, segmentStart, segmentEnd);
            const distanceToSegment = calculateDistance(point, closestOnSegment.point);
            
            if (distanceToSegment < minDistance) {
                minDistance = distanceToSegment;
                closestPoint = {
                    point: closestOnSegment.point,
                    distance: accumulatedDistance + closestOnSegment.distance
                };
            }
            
            accumulatedDistance += segmentDistance;
        }
        
        return closestPoint;
    }

    // Find closest point on a segment
    function findClosestPointOnSegment(point, segmentStart, segmentEnd) {
        const A = point[0] - segmentStart[0];
        const B = point[1] - segmentStart[1];
        const C = segmentEnd[0] - segmentStart[0];
        const D = segmentEnd[1] - segmentStart[1];

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) param = dot / lenSq;

        let xx, yy;

        if (param < 0) {
            xx = segmentStart[0];
            yy = segmentStart[1];
        } else if (param > 1) {
            xx = segmentEnd[0];
            yy = segmentEnd[1];
        } else {
            xx = segmentStart[0] + param * C;
            yy = segmentStart[1] + param * D;
        }

        return {
            point: [xx, yy],
            distance: param * Math.sqrt(lenSq)
        };
    }

function updateMarbleDisplay() {
    const track = getCurrentTrack();
    const marbles = track ? track.marbles : [];
    
    if (marbles.length === 0) {
        map.getSource('marbles').setData({
            type: 'FeatureCollection',
            features: []
        });
        document.getElementById('marble-count').textContent = '0 marbles';
        return;
    }
    
    const marbleFeatures = marbles.map((marble, index) => {
        const hasImage = marble.assignedImage !== null;
        const imageIndex = hasImage ? marble.assignedImage + 1 : 0;
        
        return {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: marble.position
            },
            properties: {
                id: marble.id,
                index: index,
                isDragging: marble.isDragging || false,
                isLocked: marble.isLocked || false,
                isFixed: marble.isFixed || false,
                isSelected: (marble.id === selectedMarbleId),
                hasImage: hasImage,
                imageIndex: imageIndex,
                // Add position info for tooltips
                position: `${index + 1}/${marbles.length}`,
                distance: `${Math.round(marble.distanceAlongRoute)}m`
            }
        };
    });
    
    map.getSource('marbles').setData({
        type: 'FeatureCollection',
        features: marbleFeatures
    });
    
    // Update marble count with detailed info
    const marblesWithImages = marbles.filter(m => m.assignedImage !== null).length;
    const lockedMarbles = marbles.filter(m => m.isLocked).length;
    const fixedMarbles = marbles.filter(m => m.isFixed).length;
    
    document.getElementById('marble-count').textContent = 
        `${marbles.length} marbles (${marblesWithImages} with images, ${lockedMarbles} locked)`;
    
    enableMarbleDragging();
}

    function enableMarbleDragging() {
        // Clear existing handlers to avoid duplicates
        map.off('click', 'marbles-layer', handleMarbleClick);
        map.off('mousedown', 'marbles-layer', handleMarbleMouseDown);
        map.off('mousemove', handleMarbleDrag);
        map.off('mouseup', stopMarbleDrag);
        map.off('click', handleMapClickForDeselect);

        // Add new handlers
        map.on('click', 'marbles-layer', handleMarbleClick);
        map.on('mousedown', 'marbles-layer', handleMarbleMouseDown);
        map.on('mousemove', handleMarbleDrag);
        map.on('mouseup', stopMarbleDrag);
        
        // Map click to deselect
        map.on('click', handleMapClickForDeselect);
    }

    function handleMarbleMouseDown(e) {
        e.preventDefault();
        if (e.features.length > 0) {
            const marbleId = e.features[0].properties.id;
            startMarbleDrag(marbleId);
        }
    }

    function handleMapClickForDeselect(e) {
        const features = map.queryRenderedFeatures(e.point, { layers: ['marbles-layer'] });
        if (features.length === 0) {
            deselectMarble();
        }
    }

    function lockSelectedMarble() {
        if (selectedMarbleId) {
            toggleMarbleLock(selectedMarbleId);
        } else {
            setStatus('Select a marble first by clicking on it');
        }
    }

    // ========== 360 VIEWER FUNCTIONS ==========

async function load360Images() {
    try {
        setStatus('Loading 360 images from frames folder...');
        createImagesFromFramesFolder();
        
        if (currentImages.length > 0) {
            setStatus(`Loaded ${currentImages.length} images - assigning to marbles`);
            assignImagesToMarbles();
            
            // AUTO-SHOW FIRST IMAGE
            showImageByIndex(0);
            
            // START BACKGROUND PRELOADING OF ALL IMAGES
            startBackgroundPreload(3); // ← ADD THIS LINE
        }
        
    } catch (error) {
        console.error('Error loading 360 images:', error);
        setStatus('Error loading 360 images');
    }
}

    function createImagesFromFramesFolder() {
    // Clear existing images
    currentImages = [];
    
    // Use the exact image URLs from your beta
    const filenames = [
        'santte1a-00.00.00.901.jpeg',
        'santte1a-00.00.03.036.jpeg',
        'santte1a-00.00.05.105.jpeg',
        'santte1a-00.00.06.907.jpeg',
        'santte1a-00.00.08.242.jpeg',
        'santte1a-00.00.10.975.jpeg',
        'santte1a-00.00.13.347.jpeg',
        'santte1a-00.00.14.381.jpeg',
        'santte1a-00.00.16.450.jpeg',
        'santte1a-00.00.18.819.jpeg',
        'santte1a-00.00.20.354.jpeg',
        'santte1a-00.00.22.356.jpeg',
        'santte1a-00.00.24.424.jpeg',
        'santte1a-00.00.25.692.jpeg',
        'santte1a-00.00.29.096.jpeg',
        'santte1a-00.00.30.030.jpeg',
        'santte1a-00.00.31.732.jpeg',
        'santte1a-00.00.34.268.jpeg',
        'santte1a-00.00.35.802.jpeg',
        'santte1a-00.00.37.638.jpeg',
        'santte1a-00.00.40.073.jpeg',
        'santte1a-00.00.41.708.jpeg',
        'santte1a-00.00.43.310.jpeg',
        'santte1a-00.00.45.679.jpeg',
        'santte1a-00.00.47.614.jpeg',
        'santte1a-00.00.49.683.jpeg',
        'santte1a-00.00.51.618.jpeg',
        'santte1a-00.00.53.186.jpeg',
        'santte1a-00.00.55.122.jpeg',
        'santte1a-00.00.58.191.jpeg',
        'santte1a-00.00.59.359.jpeg',
        'santte1a-00.01.01.028.jpeg',
        'santte1a-00.01.03.030.jpeg',
        'santte1a-00.01.05.039.jpeg',
        'santte1a-00.01.07.034.jpeg',
        'santte1a-00.01.09.002.jpeg',
        'santte1a-00.01.10.704.jpeg',
        'santte1a-00.01.12.673.jpeg',
        'santte1a-00.01.14.474.jpeg',
        'santte1a-00.01.16.410.jpeg',
        'santte1a-00.01.18.412.jpeg',
        'santte1a-00.01.21.281.jpeg',
        'santte1a-00.01.22.849.jpeg',
        'santte1a-00.01.24.384.jpeg',
        'santte1a-00.01.25.852.jpeg',
        'santte1a-00.01.28.288.jpeg',
        'santte1a-00.01.30.390.jpeg',
        'santte1a-00.01.32.025.jpeg',
        'santte1a-00.01.33.894.jpeg',
        'santte1a-00.01.35.862.jpeg',
        'santte1a-00.01.37.764.jpeg',
        'santte1a-00.01.40.100.jpeg',
        'santte1a-00.01.41.201.jpeg',
        'santte1a-00.01.43.704.jpeg',
        'santte1a-00.01.45.706.jpeg',
        'santte1a-00.01.47.741.jpeg',
        'santte1a-00.01.49.276.jpeg',
        'santte1a-00.01.51.378.jpeg',
        'santte1a-00.01.53.180.jpeg',
        'santte1a-00.01.55.115.jpeg',
        'santte1a-00.01.57.050.jpeg'
    ];
    
    // Base URL
    const baseUrl = 'https://lalaland.mx/frames/';
    
    // Create image objects WITHOUT coordinates
    for (let i = 0; i < filenames.length; i++) {
        const filename = filenames[i];
        const imageUrl = baseUrl + filename;
        
        currentImages.push({
            url: imageUrl,
            index: i,
            filename: filename,
            timestamp: `Image ${i + 1}`,
            sequence: i
            // NO lat/lon coordinates - we'll use marble positions instead
        });
    }
    
    currentImageIndex = -1;
    setStatus(`Loaded ${currentImages.length} images from frames folder`);
    
    // Start preloading images in background
    startBackgroundPreload();
}



    function clear360Images() {
        currentImages = [];
        currentImageIndex = -1;
        updateImageCount();
        updateViewerDisplay();
        setStatus('Cleared all 360 images');
    }

    function assignImagesToMarbles() {
    const track = getCurrentTrack();
    if (!track) {
        setStatus('No track selected - cannot assign images to marbles');
        return;
    }
    
    const marbles = track.marbles;
    if (marbles.length === 0) {
        setStatus('No marbles created - create marbles first');
        return;
    }
    
    // Clear previous assignments
    marbles.forEach(marble => {
        marble.assignedImage = null;
    });
    
    // Assign images to marbles in 1:1 order
    // Marble 1 → Image 1, Marble 2 → Image 2, etc.
    const assignmentCount = Math.min(marbles.length, currentImages.length);
    
    for (let i = 0; i < assignmentCount; i++) {
        marbles[i].assignedImage = i; // Direct 1:1 mapping
    }
    
    // Update marble display to show which have images
    updateMarbleDisplay();
    
    // Show assignment summary
    if (marbles.length > currentImages.length) {
        setStatus(`Assigned ${assignmentCount} images to ${marbles.length} marbles (${marbles.length - assignmentCount} marbles without images)`);
    } else if (marbles.length < currentImages.length) {
        setStatus(`Assigned ${assignmentCount} images to ${marbles.length} marbles (${currentImages.length - assignmentCount} images unused)`);
    } else {
        setStatus(`Perfect! All ${assignmentCount} images assigned to marbles`);
    }
    
    return assignmentCount;
}











    function updateImageCount() {
        const imageCount = document.getElementById('image-count');
        const currentImage = document.getElementById('current-image');
        
        if (imageCount) {
            imageCount.textContent = `${currentImages.length} loaded`;
        }
        if (currentImage) {
            currentImage.textContent = currentImageIndex >= 0 ? `${currentImageIndex + 1}/${currentImages.length}` : '-';
        }
    }

    // Export single track by ID
    function exportSingleTrack(trackId) {
        const track = allTracks.get(trackId);
        if (track) {
            const gpxContent = generateGPX(track);
            downloadFile(gpxContent, `${track.name}_edited.gpx`, 'application/gpx+xml');
            setStatus(`Exported: ${track.name}_edited.gpx`);
        }
    }

    // Export current track
    function exportCurrentTrack() {
        const track = getCurrentTrack();
        if (!track) {
            setStatus('Please select a track first!');
            return;
        }
        exportSingleTrack(track.id);
    }

    // Export all tracks as ZIP
    async function exportAllTracksAsZip() {
        if (allTracks.size === 0) {
            setStatus('No tracks to export!');
            return;
        }

        try {
            const zip = new JSZip();
            
            allTracks.forEach(track => {
                const gpxContent = generateGPX(track);
                zip.file(`${track.name}_edited.gpx`, gpxContent);
            });
            
            const content = await zip.generateAsync({type: "blob"});
            downloadFile(content, 'edited_tracks.zip', 'application/zip');
            setStatus(`Exported ${allTracks.size} tracks as separate files`);
            
        } catch (error) {
            console.error('Error creating ZIP:', error);
            setStatus('Error creating ZIP file');
        }
    }

    // Generate GPX for a single track
    function generateGPX(track) {
        const coordinates = track.activePoints.map(p => p.coordinates);
        
        let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GPX Editor" xmlns="http://www.topografix.com/GPX/1/1">
  <trk>
    <name>${escapeXML(track.name)}_edited</name>
    <trkseg>
`;
        
        coordinates.forEach(coord => {
            gpx += `      <trkpt lat="${coord[1].toFixed(6)}" lon="${coord[0].toFixed(6)}"></trkpt>\n`;
        });
        
        gpx += `    </trkseg>
  </trk>`;
        
        // ADD MARBLES AS WAYPOINTS
        track.marbles.forEach((marble, index) => {
            const imageInfo = marble.assignedImage !== null ? 
                ` - Image ${marble.assignedImage + 1}` : '';
                
            gpx += `
  <wpt lat="${marble.position[1].toFixed(6)}" lon="${marble.position[0].toFixed(6)}">
    <name>Photo_${index + 1}${imageInfo}</name>
    <desc>Marble position along route${imageInfo}</desc>
  </wpt>`;
        });
        
        gpx += '\n</gpx>';
        return gpx;
    }

    // Escape XML special characters
    function escapeXML(str) {
        return str.replace(/&/g, '&amp;')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;')
                  .replace(/"/g, '&quot;')
                  .replace(/'/g, '&apos;');
    }

    // Download helper function
    function downloadFile(content, fileName, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // ===== 360 VIEWER INITIALIZATION =====
function initThreeJSViewer() {
    if (viewerInitialized) return;
    
    // Scene setup
    scene = new THREE.Scene();
    panoGroup = new THREE.Group();
    scene.add(panoGroup);

    // Camera
    const canvas = document.getElementById('canvas');
    camera = new THREE.PerspectiveCamera(currentFov, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    camera.position.set(0, 0, 0.1);

    // Renderer - KEEP SIMPLE but add DPR
    renderer = new THREE.WebGLRenderer({ 
        canvas: canvas,
        antialias: true,
        alpha: false,
        powerPreference: 'high-performance'
    });
    
    // ADD ONLY DPR (no tone mapping)
    const dpr = Math.min(window.devicePixelRatio || 4, 4);
    renderer.setPixelRatio(dpr);
    renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
    
    // Event listeners
    setupViewerEventListeners();
    
    // Start animation loop
    animateViewer();
    viewerInitialized = true;
    
    console.log('Three.js viewer initialized with DPR:', dpr);
}

function animateViewer() {
    requestAnimationFrame(animateViewer);
    updateNavigationRing();
    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

function updateNavigationRing() {
    const ring = document.querySelector('.navigation-ring');
    if (!ring || !sphere) return;
    
    // Rotate ring to match view
    const yawDegrees = THREE.MathUtils.radToDeg(currentYaw) + -180;
    ring.style.transform = `rotateZ(${-yawDegrees}deg)`;
}

// ===== IMAGE DISPLAY =====
function showImageInViewer(imageUrl, imageData) {
    showViewerLoading('Loading 360° image...');
    
    console.log('Loading image:', imageUrl);
    
    // Initialize viewer if needed
    if (!viewerInitialized) {
        initThreeJSViewer();
    }
    
    // Check if image is already preloaded (double-check)
    if (preloadedImages[imageUrl]) {
        console.log('Image preloaded - instant display');
        hideViewerLoading();
        applyImageToSphere(preloadedImages[imageUrl], imageData);
        preloadAdjacentImages();
        return;
    }
    
    // Load new image
    const img = new Image();
    img.crossOrigin = "Anonymous";
    
    img.onload = function() {
        console.log('Image loaded successfully:', imageUrl);
        preloadedImages[imageUrl] = img; // Add to cache
        hideViewerLoading();
        applyImageToSphere(img, imageData);
        preloadAdjacentImages();
    };
    
    img.onerror = function() {
        console.error('Failed to load image:', imageUrl);
        hideViewerLoading();
        setStatus('Failed to load 360 image: ' + imageUrl);
    };
    
    const timestamp = new Date().getTime();
    const urlWithCacheBust = imageUrl + (imageUrl.includes('?') ? '&' : '?') + 't=' + timestamp;
    img.src = urlWithCacheBust;
}

// ===== IMAGE NAVIGATION =====
function nextImage() {
    if (currentImageIndex < currentImages.length - 1) {
        currentImageIndex++;
        showImageByIndex(currentImageIndex);
    }
    updateNavigationButtons();
}

function previousImage() {
    if (currentImageIndex > 0) {
        currentImageIndex--;
        showImageByIndex(currentImageIndex);
    }
    updateNavigationButtons();
}

function showImageByIndex(index, preserveOrientation = false) {
    if (index >= 0 && index < currentImages.length) {
        const image = currentImages[index];
        
        // CHECK IF IMAGE IS PRELOADED
        if (preloadedImages[image.url]) {
            console.log('Image already preloaded - instant display');
            // INSTANT DISPLAY - no loading screen
            applyImageToSphere(preloadedImages[image.url], image);
            currentImageIndex = index;
            updateViewerUI();
            highlightMarbleWithImage(index);
        } else {
            console.log('Image not preloaded - showing loading screen');
            // NOT PRELOADED - show loading screen
            showImageInViewer(image.url, image);
            currentImageIndex = index;
            updateViewerUI();
            highlightMarbleWithImage(index);
        }
        
        // PRELOAD ADJACENT IMAGES FOR NEXT NAVIGATION
        preloadAdjacentImages();
    }
}

function applyImageToSphere(img, imageData) {
    // Remove old sphere
    if (sphere) {
        panoGroup.remove(sphere);
        if (sphere.geometry) sphere.geometry.dispose();
        if (sphere.material) {
            if (sphere.material.map) sphere.material.map.dispose();
            sphere.material.dispose();
        }
    }
    
    // Create new sphere with preloaded image
    const geometry = new THREE.SphereGeometry(100, 60, 40);
    geometry.scale(-1, 1, 1);
    
    const texture = new THREE.Texture(img);
    texture.needsUpdate = true;
    
    const material = new THREE.MeshBasicMaterial({ 
        map: texture, 
        side: THREE.DoubleSide 
    });
    
    sphere = new THREE.Mesh(geometry, material);
    panoGroup.add(sphere);
    
    // Reset orientation
    panoGroup.rotation.set(0, 0, 0);
    currentYaw = 0;
    currentPitch = 0;
    
    updateNavigationRing();
    setStatus(`Loaded image ${currentImageIndex + 1}`);
}

function preloadAdjacentImages() {
    // Quick preload of just next/previous for instant navigation
    const prevIndex = currentImageIndex - 1;
    const nextIndex = currentImageIndex + 1;
    
    if (prevIndex >= 0 && !preloadedImages[currentImages[prevIndex].url]) {
        preloadOne(prevIndex);
    }
    if (nextIndex < currentImages.length && !preloadedImages[currentImages[nextIndex].url]) {
        preloadOne(nextIndex);
    }
}

function updateViewerUI() {
    document.getElementById('time').textContent = `${currentImageIndex + 1}/${currentImages.length}`;
    document.getElementById('viewer-info').textContent = `Image ${currentImageIndex + 1}/${currentImages.length}`;
}

function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevImageBtn');
    const nextBtn = document.getElementById('nextImageBtn');
    
    if (prevBtn) prevBtn.disabled = currentImageIndex <= 0;
    if (nextBtn) nextBtn.disabled = currentImageIndex >= currentImages.length - 1;
}

// ===== MARBLE-IMAGE CONNECTION =====
function highlightMarbleWithImage(imageIndex) {
    const track = getCurrentTrack();
    if (!track) return;
    
    // Find marble with this image
    const marble = track.marbles.find(m => m.assignedImage === imageIndex);
    if (marble) {
        selectMarble(marble.id);
        // Center map on this marble
        map.flyTo({
            center: marble.position,
            zoom: 17,
            duration: 1000
        });
    }
}

// ENHANCED: Click marble to show image
function showMarbleImage(marbleId) {
    const track = getCurrentTrack();
    if (!track) return;
    
    const marble = track.marbles.find(m => m.id === marbleId);
    if (!marble) return;
    
    if (marble.assignedImage === null) {
        setStatus(`Marble ${marble.index + 1} has no image assigned`);
        return;
    }
    
    const imageIndex = marble.assignedImage;
    showImageByIndex(imageIndex, true);
    setStatus(`Showing image ${imageIndex + 1}/${currentImages.length} for marble ${marble.index + 1}`);
}

// ===== VIEW CONE =====
function updateViewCone(imageData) {
    if (!map || !imageData) return;
    
    // Remove old cone
    if (viewConeMarker) {
        viewConeMarker.remove();
    }
    
    // Get the marble that has this image to position the cone
    const track = getCurrentTrack();
    if (!track) return;
    
    const marble = track.marbles.find(m => m.assignedImage === currentImageIndex);
    if (!marble) return;
    
    // Create view cone element
    const coneElement = document.createElement('div');
    coneElement.innerHTML = `
        <div style="width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 20px solid rgba(255, 107, 107, 0.7); transform-origin: center bottom;"></div>
    `;
    
    // Add to map at marble position
    viewConeMarker = new mapboxgl.Marker(coneElement)
        .setLngLat(marble.position)
        .addTo(map);
    
    // Rotate cone based on current view
    updateViewConeRotation();
}

function updateViewConeRotation() {
    if (!viewConeMarker) return;
    
    const coneElement = viewConeMarker.getElement();
    const arrow = coneElement.querySelector('div');
    if (arrow) {
        const degrees = THREE.MathUtils.radToDeg(currentYaw);
        arrow.style.transform = `rotate(${degrees}deg)`;
    }
}

// ===== VIEWER CONTROLS =====
function setupViewerEventListeners() {
    const canvas = document.getElementById('canvas');
    
    // Mouse drag to look around
    let isDragging = false;
    let lastX = 0, lastY = 0;
    
    canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvas.style.cursor = 'grabbing';
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if (isDragging && sphere) {
            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;
            
            panoGroup.rotation.y -= deltaX * 0.01;
            panoGroup.rotation.x -= deltaY * 0.01;
            
            currentYaw = panoGroup.rotation.y;
            currentPitch = panoGroup.rotation.x;
            
            lastX = e.clientX;
            lastY = e.clientY;
            
            updateNavigationRing();
            updateViewConeRotation();
        }
    });
    
    canvas.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
    });
    
    canvas.addEventListener('mouseenter', () => {
        canvas.style.cursor = 'grab';
    });
    
    canvas.addEventListener('mouseleave', () => {
        isDragging = false;
        canvas.style.cursor = 'default';
    });
    
    // Zoom controls
    document.getElementById('zoomIn').addEventListener('click', zoomIn);
    document.getElementById('zoomOut').addEventListener('click', zoomOut);

     canvas.addEventListener('wheel', handleWheelZoom);
    
    // Navigation buttons
    document.getElementById('nextImageBtn').addEventListener('click', nextImage);
    document.getElementById('prevImageBtn').addEventListener('click', previousImage);
    
    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') previousImage();
        if (e.key === 'ArrowRight') nextImage();
    });
}

function zoomIn() {
    if (currentFov > 30) {
        currentFov -= 5;
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
    }
}

function zoomOut() {
    if (currentFov < 120) {
        currentFov += 5;
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
    }
}

function handleWheelZoom(e) {
    e.preventDefault();
    
    if (e.deltaY < 0) {
        // Scroll up - zoom in
        zoomIn();
    } else {
        // Scroll down - zoom out
        zoomOut();
    }
}

// ===== LOADING FUNCTIONS =====
function showViewerLoading(message) {
    const loading = document.getElementById('viewer-loading');
    const loadingText = document.getElementById('loading-text');
    if (loading && loadingText) {
        loadingText.textContent = message;
        loading.style.display = 'block';
    }
}

function hideViewerLoading() {
    const loading = document.getElementById('viewer-loading');
    if (loading) loading.style.display = 'none';
}

// Function to get marble by image index
function getMarbleByImageIndex(imageIndex) {
    const track = getCurrentTrack();
    if (!track) return null;
    
    return track.marbles.find(marble => marble.assignedImage === imageIndex);
}

// Function to navigate to next/previous marble WITH image
function navigateToMarbleWithImage(direction) {
    const track = getCurrentTrack();
    if (!track) return;
    
    const marbles = track.marbles;
    const marblesWithImages = marbles.filter(m => m.assignedImage !== null);
    
    if (marblesWithImages.length === 0) {
        setStatus('No marbles have images assigned');
        return;
    }
    
    let currentIndex = 0;
    if (selectedMarbleId) {
        const currentMarble = marbles.find(m => m.id === selectedMarbleId);
        if (currentMarble && currentMarble.assignedImage !== null) {
            currentIndex = marblesWithImages.findIndex(m => m.id === selectedMarbleId);
        }
    }
    
    let newIndex;
    if (direction === 'next') {
        newIndex = (currentIndex + 1) % marblesWithImages.length;
    } else {
        newIndex = (currentIndex - 1 + marblesWithImages.length) % marblesWithImages.length;
    }
    
    const nextMarble = marblesWithImages[newIndex];
    selectMarble(nextMarble.id);
    showMarbleImage(nextMarble.id);
}

// Update keyboard navigation to only navigate marbles with images
function enableMarbleNavigation() {
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            navigateToMarbleWithImage(e.key === 'ArrowDown' ? 'next' : 'prev');
        }
    });
}

// Add buttons to navigate marbles with images
function addMarbleNavigationButtons() {
    // Add these buttons to your controls HTML or create them dynamically
    const marbleNavHTML = `
        <div class="control-group">
            <div class="slider-label">
                <span>Marble Navigation:</span>
                <div>
                    <button class="small-btn" onclick="navigateToMarbleWithImage('prev')">← Prev</button>
                    <button class="small-btn" onclick="navigateToMarbleWithImage('next')">Next →</button>
                </div>
            </div>
        </div>
    `;
    
    // Add to controls (you might need to adjust the selector based on your HTML structure)
    const controls = document.getElementById('controls');
    const exportGroup = controls.querySelector('.export-buttons').parentElement;
    exportGroup.insertAdjacentHTML('beforebegin', marbleNavHTML);
}

// ===== MISSING: IMAGE PRELOADING SYSTEM =====
let preloadedImages = {}; // ADD THIS VARIABLE at the top with other globals

function startBackgroundPreload(concurrency = 3) {
    if (currentImages.length <= 1) return;
    
    const order = buildPreloadOrder(currentImageIndex, currentImages.length);
    runPreloadPool(order, concurrency);
}

function buildPreloadOrder(center, total) {
    const seq = [];
    for (let step = 1; step < total; step++) {
        const fwd = center + step;
        const back = center - step;
        if (fwd < total) seq.push(fwd);
        if (back >= 0) seq.push(back);
    }
    return seq;
}

function runPreloadPool(indexes, concurrency) {
    let i = 0;
    const workers = Array.from({ length: Math.min(concurrency, indexes.length) }, async () => {
        while (i < indexes.length) {
            const idx = indexes[i++];
            await preloadOne(idx).catch(() => {});
        }
    });
    
    Promise.all(workers).then(() => {
        console.log('Background preload complete');
    });
}

function preloadOne(index) {
    return new Promise((resolve) => {
        const item = currentImages[index];
        if (!item) return resolve();

        const src = item.url;
        if (preloadedImages[src]) return resolve(); // already cached

        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.onload = () => {
            preloadedImages[src] = img;
            resolve();
        };
        img.onerror = () => resolve(); // swallow errors; keep going
        img.src = src;

        if (img.decode) img.decode().catch(() => {});
    });
}

// ===== MISSING: UPDATE VIEWER DISPLAY =====
function updateViewerDisplay() {
    const panoImage = document.getElementById('pano-image');
    const noImage = document.getElementById('no-image');
    
    if (panoImage && noImage) {
        if (currentImages.length > 0 && currentImageIndex >= 0) {
            panoImage.style.display = 'block';
            noImage.style.display = 'none';
        } else {
            panoImage.style.display = 'none';
            noImage.style.display = 'flex';
        }
    }
}

// ===== MISSING: INITIALIZE VIEWER =====
function initializeViewer() {
    // Simple initialization - the Three.js viewer will be initialized when images are loaded
    console.log('Viewer container ready');
}

// ===== MISSING: SHOW IMAGE (legacy function) =====
function showImage(index) {
    // This is called by the old viewer controls, redirect to new system
    showImageByIndex(index);
}





    // Initialize the application
    initializeApp();
</script>

</body>
</html>
