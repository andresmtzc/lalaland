<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IG 4×5 Post Designer with Voxel Grid</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <!-- Added fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Anton&family=Barlow+Condensed:wght@400;600;800&family=Oswald:wght@400;600&family=Montserrat:wght@400;700;900&family=Playfair+Display:wght@700&family=Raleway:wght@800&family=Roboto+Condensed:wght@700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<style>
  :root{
    --edge-color:#ff8400;
    --brand-orange:#ff8400;
    --off-white:#fcfaf3;
    --off-black:#1a1a1a;
    --edge-display:block;   /* edges start visible */
    --edge-w:3px;           /* thickness of edge ring */
    --blue-top:#ffd199;
    --blue-left:#ff9a2d;
    --blue-right:#ff8400;
    --ground:#2a2a2a;
    --ground-inner:#3a3a3a;
    --grid-hover:rgba(255,255,255,.15);
  --tree-fill:#00D1B2;    /* canopy color */

  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--off-black); color:#ddd; font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    display:grid; grid-template-columns:320px 1fr; gap:20px; padding:20px;
  }

  /* Sidebar */
  .panel{background:#111; border:1px solid #262626; border-radius:16px; padding:16px; box-shadow:0 4px 24px rgba(0,0,0,.35)}
  .panel h2{margin:0 0 12px; font-size:18px; font-weight:800; color:#fff}
  .group{margin-bottom:14px}
  .group label{display:block; font-size:12px; color:#9aa0a6; margin-bottom:6px}
  .row{display:flex; gap:8px; align-items:center}
  .row > *{flex:1}
  input[type="text"], input[type="number"], select{width:100%; background:#0f0f0f; color:#e6e6e6; border:1px solid #2a2a2a; padding:10px 12px; border-radius:10px}
  input[type="range"]{width:100%}
  button{background:#1f1f1f; color:#fff; border:1px solid #2a2a2a; padding:10px 12px; border-radius:12px; cursor:pointer}
  button.primary{background:var(--brand-orange); color:#1b1b1b; border:none; font-weight:800}
  button:disabled{opacity:.5; cursor:not-allowed}
  button.active{background:var(--brand-orange); color:#1b1b1b}

  .swatch{display:flex; gap:8px}
  .dot{width:28px; height:28px; border-radius:50%; border:2px solid #2a2a2a; cursor:pointer}
  .dot[data-color="orange"]{background:var(--brand-orange)}
  .dot[data-color="offwhite"]{background:var(--off-white)}
  .dot[data-color="offblack"]{background:var(--off-black)}
  .dot.active{outline:2px solid #fff}

  /* Font style controls */
  .font-style-grid{display:grid; grid-template-columns:1fr 1fr; gap:6px; margin-top:8px}
  .style-group{background:#0a0a0a; border:1px solid #1f1f1f; border-radius:8px; padding:8px}
  .style-group label{font-size:10px; color:#888; margin-bottom:4px; display:block}
  .style-row{display:flex; gap:4px; align-items:center; margin-bottom:4px}
  .style-row:last-child{margin-bottom:0}
  .style-toggle{font-size:10px; padding:4px 6px; min-width:35px}
  .style-slider{flex:1; min-width:0}
  .mini-input{width:40px; padding:4px 6px; font-size:10px; border-radius:6px}

  /* Stage */
  .stage-wrap{display:grid; place-items:center; overflow:auto}
  .stage-bg{background:#0b0b0b; border:1px dashed #2a2a2a; border-radius:16px; padding:20px; width:100%; height:100%; min-height:80vh}

  /* 4:5 canvas holder */
  .shell{position:relative; aspect-ratio:4/5; width:min(80vh, min(80vw, 900px)); background:var(--off-white); border-radius:12px; box-shadow:0 30px 70px rgba(0,0,0,.5); overflow:hidden; z-index:0}

  .shell .badge{position:absolute; left:12px; bottom:12px; font-size:12px; color:#777; background:rgba(255,255,255,.04); padding:6px 8px; border:1px solid rgba(255,255,255,.08); border-radius:8px; backdrop-filter:blur(4px); z-index:1000}

  /* IMPORTANT: canvas must receive mouse events for dragging text */
  canvas#art{position:absolute; inset:0; width:100%; height:100%; display:block; z-index:1; pointer-events:auto; border-radius:12px}

  /* Voxels sit above canvas but below UI, and are click-through by default */
  .voxel-layer{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%) scale(1); width:1200px; height:900px; pointer-events:none; z-index:2}
  .voxel-layer *{box-sizing:border-box}
  .voxel-layer .info{color:#fff; display:none}
  .voxel-layer .viewport{width:100%; height:100%; display:flex; justify-content:center; align-items:center; position:relative}
  .voxel-layer .grid-container{position:relative; width:800px; height:400px; transform:scale(.8); transform-origin:center}
  .voxel-layer .controls{display:none}
  .guides-hint{position:absolute; top:12px; right:12px; font-size:12px; color:#a8a8a8; z-index:1000}

  /* Voxel faces */
  .voxel-layer .face{position:absolute; width:100px; height:100px}
  .voxel-layer .inner{
    position:absolute;
    left:var(--edge-w);
    top:var(--edge-w);
    width:calc(100% - 2*var(--edge-w));
    height:calc(100% - 2*var(--edge-w));
    clip-path:inherit;
    z-index:2;
  }

  /* Top/Left/Right face fill colors (inside) */
  .voxel-layer .top{clip-path:polygon(50% 0%, 100% 25%, 50% 50%, 0% 25%)}
  .voxel-layer .top .inner{background:var(--blue-top)}
  .voxel-layer .left{clip-path:polygon(0% 25%, 50% 50%, 50% 100%, 0% 75%)}
  .voxel-layer .left .inner{background:var(--blue-left)}
  .voxel-layer .right{clip-path:polygon(100% 25%, 50% 50%, 50% 100%, 100% 75%)}
  .voxel-layer .right .inner{background:var(--blue-right)}

  /* Bottom top-face (raised) */
  .voxel-layer .bottom2{clip-path:polygon(50% 0%, 100% 25%, 50% 50%, 0% 25%); transform:translateY(50px)}
  .voxel-layer .bottom2 .inner{background:var(--blue-top)}

  /* Base (ground) tile */
  .voxel-layer .bottom{background:var(--ground); clip-path:polygon(50% 0%, 100% 25%, 50% 50%, 0% 25%); transform:translateY(50px); pointer-events:none}
  .voxel-layer .bottom .inner{background:var(--ground-inner); width:98px; height:98px; left:1px; top:1px; clip-path:inherit; position:absolute}

  /* Hitbox for clicks (enabled only in voxel-edit mode) */
  .voxel-layer .hitbox{width:100px; height:100px; position:absolute; top:0; left:0; transform:translateY(50px); pointer-events:auto; z-index:2; background:transparent}
  .voxel-layer .hitbox::before{content:""; position:absolute; width:100px; height:100px; clip-path:polygon(50% 0%, 100% 25%, 50% 50%, 0% 25%); background:transparent; transition:background .2s ease; z-index:2}
  .voxel-layer .hitbox:hover::before{background:var(--grid-hover); cursor:crosshair}

  /* Edge overlays (sit UNDER the inner fill) */
  .voxel-layer .edge-top,
  .voxel-layer .edge-left,
  .voxel-layer .edge-right,
  .voxel-layer .edge-bottom2{
    position:absolute; width:100px; height:100px; z-index:1; pointer-events:none;
    display:var(--edge-display, none); background:var(--edge-color); clip-path:inherit; transform:inherit;
  }

  /* Floating handles/help — keep UI above voxels */
  .toolbar{position:absolute; top:12px; left:12px; display:flex; gap:8px; z-index:1000}
  .toolbar button{padding:8px 10px; border-radius:10px}

  /* Toast */
  .toast{
    position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,.8); color:#fff; padding:12px 20px; border-radius:8px;
    z-index:2000; opacity:0; transition:opacity .3s; pointer-events:none;
  }
  .toast.show{opacity:1}

  /* Faces shouldn't catch the mouse — let events fall through to hitboxes */
.voxel-layer .face { pointer-events: none; }

/* Hitboxes sit on top of faces inside the voxel-layer */
.voxel-layer .hitbox{
  width:100px; height:100px; position:absolute; top:0; left:0;
  transform:translateY(50px);
  pointer-events: none;       /* default OFF; JS toggles to 'auto' in edit mode */
  z-index: 9999;              /* higher than any face z-index */
  background: transparent;
}
.voxel-layer .hitbox::before{
  content:""; position:absolute; width:100px; height:100px;
  clip-path:polygon(50% 0%, 100% 25%, 50% 50%, 0% 25%);
  background:transparent; transition:background .2s ease; z-index:9999;
}



/* DOM trees */
.voxel-layer .tree{
  position:absolute;
  width:40px; height:40px; /* will be overridden inline */
  pointer-events:none;      /* clicks go to hitbox, not the tree */
}
.voxel-layer .tree .trunk{
  position:absolute;
  bottom:0; left:50%;
  transform:translateX(-50%);
  width:var(--edge-w);      /* stick uses edge thickness */
  background:var(--tree-fill);
  border-radius:999px;
}
.voxel-layer .tree .canopy{
  position:absolute;
  border-radius:50%;
  background:var(--tree-fill);
}

/* tree-only tiles: keep invisible even on hover */
.voxel-layer .hitbox.ghost::before { background: transparent !important; }
</style>
</head>
<body>
  <!-- Controls -->
  <aside class="panel" id="sidebar">
    <h2>Post Settings (4×5)</h2>

    <div class="group">
      <label>Preset Background</label>
      <div class="swatch">
        <div class="dot active" data-color="offwhite" title="Off-White"></div>
        <div class="dot" data-color="offblack" title="Off-Black"></div>
        <div class="dot" data-color="orange" title="Brand Orange"></div>
      </div>
    </div>

    <div class="group row">
      <div>
        <label>Custom BG</label>
        <input type="color" id="bgColor" value="#fcfaf3" />
      </div>
      <div>
        <label>Padding (px)</label>
        <input type="number" id="padding" value="90" min="0" max="200" />
      </div>
    </div>

    <div class="group">
      <label>Voxel Grid</label>
      <label class="row"><span>Scale</span><input type="range" id="vxScale" min="30" max="220" value="100"></label>
      <label class="row"><span>Edge W</span><input type="range" id="edgeW" min="0" max="12" value="3"></label>
      <label class="row"><span>Pos X</span><input type="range" id="vxX" min="0" max="1080" value="540"></label>
      <label class="row"><span>Pos Y</span><input type="range" id="vxY" min="0" max="1350" value="680"></label>
      <div class="row"><button id="snapCenter">Snap Center</button><button id="edgesToggle">Edges: On</button></div>
      <div class="row"><label>Cols <input type="number" id="colsInput" min="1" max="40" value="8"></label><label>Rows <input type="number" id="rowsInput" min="1" max="40" value="20"></label><button id="resizeGridBtn">Resize</button></div>
      <div class="row"><button id="levelBtn">Level: 1</button><button id="drawAllBtn">Draw All</button><button id="deleteBtn">Delete All</button></div>
      <div class="row"><button id="ideasBtn">Design Ideas</button><button id="proModeBtn">🔒 Pro Mode</button></div>
    </div>

    <div class="group">
      <label>Grid Overlay</label>
      <div class="row">
        <button id="gridToggle">Grid: On</button>
        <button id="centerToggle">Centered: On</button>
      </div>
      <label class="hint">Spacing</label>
      <input type="range" id="gridSpacing" min="20" max="220" value="120" />
      <label class="hint">Opacity</label>
      <input type="range" id="gridAlpha" min="0" max="1" step="0.05" value="0.25" />
    </div>

    <div class="group">
      <label>Voxel Colors</label>
      <div class="row"><span class="mini-label">Edges</span><input type="color" id="edgeColor" value="#ff8400" /></div>
      <div class="row"><span class="mini-label">Ground</span><input type="color" id="groundColor" value="#2a2a2a" /></div>
      <div class="row"><span class="mini-label">Ground Inset</span><input type="color" id="groundInnerColor" value="#3a3a3a" /></div>
    </div>

    <div class="group">
      <label>Headline</label>
      <input type="text" id="headline" placeholder="Your bold headline" value="HELLO, IG!" />
      <div class="row">
        <select id="hAlign"><option value="center">Center</option><option value="left">Left</option><option value="right">Right</option></select>
        <input type="number" id="hSize" value="120" min="10" max="300" />
      </div>
      <div class="row">
        <button data-hcolor="offblack">Off-Black</button>
        <button data-hcolor="offwhite">Off-White</button>
        <button data-hcolor="orange">Orange</button>
      </div>
      <div class="row">
        <select id="hFont">
          <option value="Anton">Anton Regular</option>
          <option value="Barlow Condensed">Barlow Condensed</option>
          <option value="Oswald">Oswald</option>
          <option value="Montserrat">Montserrat</option>
          <option value="Playfair Display">Playfair Display</option>
          <option value="Raleway">Raleway</option>
          <option value="Roboto Condensed">Roboto Condensed</option>
          <option value="Inter">Inter</option>
        </select>
        <button id="cycleHFont">Cycle Font</button>
      </div>
      <div class="font-style-grid">
        <div class="style-group">
          <label>Outline</label>
          <div class="style-row">
            <button class="style-toggle" id="hOutline">OFF</button>
            <input type="range" class="style-slider" id="hOutlineWidth" min="1" max="10" value="2" />
            <input type="number" class="mini-input" id="hOutlineWidthNum" min="1" max="10" value="2" />
          </div>
          <div class="style-row"><input type="color" id="hOutlineColor" value="#fcfaf3" /></div>
        </div>
        <div class="style-group">
          <label>Shadow</label>
          <div class="style-row">
            <button class="style-toggle" id="hShadow">OFF</button>
            <input type="range" class="style-slider" id="hShadowBlur" min="0" max="20" value="0" />
            <input type="number" class="mini-input" id="hShadowBlurNum" min="0" max="20" value="0" />
          </div>
          <div class="style-row">
            <input type="range" class="style-slider" id="hShadowOffsetX" min="-20" max="20" value="4" />
            <input type="range" class="style-slider" id="hShadowOffsetY" min="-20" max="20" value="4" />
          </div>
          <div class="style-row">
            <input type="color" id="hShadowColor" value="#000000" />
            <input type="range" class="style-slider" id="hShadowOpacity" min="0" max="1" step="0.1" value="0.5" />
          </div>
        </div>
      </div>
    </div>

    <div class="group">
      <label>Subtitle</label>
      <input type="text" id="subtitle" placeholder="Support text" value="Clean, bold, fast." />
      <div class="row">
        <select id="sAlign"><option value="center">Center</option><option value="left">Left</option><option value="right">Right</option></select>
        <input type="number" id="sSize" value="48" min="10" max="160" />
      </div>
      <div class="row">
        <button data-scolor="offblack">Off-Black</button>
        <button data-scolor="offwhite">Off-White</button>
        <button data-scolor="orange">Orange</button>
      </div>
      <div class="row">
        <select id="sFont">
          <option value="Anton">Anton Regular</option>
          <option value="Barlow Condensed">Barlow Condensed</option>
          <option value="Oswald">Oswald</option>
          <option value="Montserrat">Montserrat</option>
          <option value="Playfair Display">Playfair Display</option>
          <option value="Raleway">Raleway</option>
          <option value="Roboto Condensed">Roboto Condensed</option>
          <option value="Inter">Inter</option>
        </select>
        <button id="cycleSFont">Cycle Font</button>
      </div>
      <div class="font-style-grid">
        <div class="style-group">
          <label>Outline</label>
          <div class="style-row">
            <button class="style-toggle" id="sOutline">OFF</button>
            <input type="range" class="style-slider" id="sOutlineWidth" min="1" max="10" value="2" />
            <input type="number" class="mini-input" id="sOutlineWidthNum" min="1" max="10" value="2" />
          </div>
          <div class="style-row"><input type="color" id="sOutlineColor" value="#fcfaf3" /></div>
        </div>
        <div class="style-group">
          <label>Shadow</label>
          <div class="style-row">
            <button class="style-toggle" id="sShadow">OFF</button>
            <input type="range" class="style-slider" id="sShadowBlur" min="0" max="20" value="0" />
            <input type="number" class="mini-input" id="sShadowBlurNum" min="0" max="20" value="0" />
          </div>
          <div class="style-row">
            <input type="range" class="style-slider" id="sShadowOffsetX" min="-20" max="20" value="2" />
            <input type="range" class="style-slider" id="sShadowOffsetY" min="-20" max="20" value="2" />
          </div>
          <div class="style-row">
            <input type="color" id="sShadowColor" value="#000000" />
            <input type="range" class="style-slider" id="sShadowOpacity" min="0" max="1" step="0.1" value="0.5" />
          </div>
        </div>
      </div>
    </div>

    <div class="group">
      <label>Guides</label>
      <div class="row">
        <button id="safeToggle">Safe: On</button>
        <button id="ruleThirds">Rule of Thirds</button>
      </div>
    </div>

    <div class="group row">
      <button id="reset">Reset</button>
      <button id="export" class="primary">Export PNG (1080×1350)</button>
    </div>
  </aside>

  <!-- Stage -->
  <main class="stage-wrap">
    <div class="stage-bg">
      <div class="shell" id="shell">
        <div class="toolbar">
          <button id="selectHead" class="active">Move Headline</button>
          <button id="selectSub">Move Subtitle</button>
          <button id="editVox">Edit Voxels</button>
            <button id="editTree">Place Trees</button>
        </div>
        <div class="guides-hint">Drag via sliders • Pro: right-click voxel to carve</div>

        <div id="voxel" class="voxel-layer">
          <div class="info"><div id="areaInfo">Construction size: 0 m²</div><div id="priceInfo">Estimated price: $0</div></div>
          <div class="viewport"><div class="grid-container" id="grid"><div class="plot-dim dim-8m">8 m</div><div class="plot-dim dim-20m">20 m</div></div></div>
          <div class="controls" style="display:none"></div>
          <input type="file" id="importInput" accept="application/json" style="display:none" />
        </div>

        <canvas id="art" width="1080" height="1350"></canvas>
        <div class="badge">4×5 • 1080×1350 px</div>
      </div>
    </div>
  </main>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

<script>
  // Brand palette
  const ORANGE = getComputedStyle(document.documentElement).getPropertyValue('--brand-orange').trim();
  const OFFWHITE = getComputedStyle(document.documentElement).getPropertyValue('--off-white').trim();
  const OFFBLACK = getComputedStyle(document.documentElement).getPropertyValue('--off-black').trim();

  // Fonts
  const FONTS = [
    { name: "Anton", family: "Anton, sans-serif", weights: [400] },
    { name: "Barlow Condensed", family: "'Barlow Condensed', sans-serif", weights: [400, 600, 800] },
    { name: "Oswald", family: "Oswald, sans-serif", weights: [400, 600] },
    { name: "Montserrat", family: "Montserrat, sans-serif", weights: [400, 700, 900] },
    { name: "Playfair Display", family: "'Playfair Display', serif", weights: [700] },
    { name: "Raleway", family: "Raleway, sans-serif", weights: [800] },
    { name: "Roboto Condensed", family: "'Roboto Condensed', sans-serif", weights: [700] },
    { name: "Inter", family: "Inter, system-ui, sans-serif", weights: [400, 600, 800] }
  ];

  // Canvas
  const canvas = document.getElementById('art');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;   // 1080
  const H = canvas.height;  // 1350

  // State
  const state = {
    bg: OFFWHITE,
    padding: 90,
    grid: { on:true, centered:true, spacing:120, alpha:.25 },
    safeOn: true,
    thirds: false,
    head: {
      text:'HELLO, IG!', size:120, color:OFFBLACK, align:'center', x: W/2, y: H*0.2,
      font: FONTS[0], weight: 400, outline: false, outlineColor: OFFWHITE, outlineWidth: 2,
      shadow: false, shadowOffsetX: 4, shadowOffsetY: 4, shadowBlur: 0, shadowColor: '#000000', shadowOpacity: 0.5
    },
    sub: {
      text:'Clean, bold, fast.', size:48, color:OFFBLACK, align:'center', x: W/2, y: H*0.32,
      font: FONTS[1], weight: 400, outline: false, outlineColor: OFFWHITE, outlineWidth: 2,
      shadow: false, shadowOffsetX: 2, shadowOffsetY: 2, shadowBlur: 0, shadowColor: '#000000', shadowOpacity: 0.5
    },
    voxel: { x: W/2, y: H*0.5, scale: 1, edges: true, edgeW: 3 },
    mode: 'head',        // 'head' | 'sub' | 'vox'
    selection:'head'     // legacy for text dragging
  };

  // Toast
  function showToast(message){
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.classList.add('show');
    setTimeout(()=>toast.classList.remove('show'), 1600);
  }

  // Drawing
  function clear(){ ctx.clearRect(0,0,W,H) }
  function drawBackground(){ ctx.fillStyle = state.bg; ctx.fillRect(0,0,W,H); }
  function setAlign(a){ ctx.textAlign = (a==='left'?'left':a==='right'?'right':'center'); }
  function drawText(obj){
    const {text,size,color,align,x,y,font,weight,outline,outlineColor,outlineWidth,shadow,shadowOffsetX,shadowOffsetY,shadowBlur,shadowColor,shadowOpacity}=obj;
    ctx.save();
    setAlign(align); ctx.textBaseline='middle'; ctx.font=`${weight} ${size}px ${font.family}`;
    if (shadow){ ctx.save(); ctx.shadowOffsetX=shadowOffsetX; ctx.shadowOffsetY=shadowOffsetY; ctx.shadowBlur=shadowBlur; ctx.shadowColor=hexToRgba(shadowColor, shadowOpacity); ctx.fillStyle=color; ctx.fillText(text,x,y); ctx.restore(); }
    if (outline){ ctx.save(); ctx.strokeStyle=outlineColor; ctx.lineWidth=outlineWidth; ctx.lineJoin='round'; ctx.strokeText(text,x,y); ctx.restore(); }
    ctx.fillStyle=color; ctx.fillText(text,x,y);
    ctx.restore();
  }
  function drawGuides(){
    const pad = state.padding;
    if(state.safeOn){
      ctx.save(); ctx.strokeStyle = state.bg===OFFBLACK?'rgba(255,255,255,.22)':'rgba(0,0,0,.25)'; ctx.lineWidth=2; ctx.setLineDash([6,8]);
      ctx.strokeRect(pad,pad,W-2*pad,H-2*pad); ctx.restore();
    }
    if(state.thirds){
      ctx.save(); ctx.strokeStyle = state.bg===OFFBLACK?'rgba(255,255,255,.18)':'rgba(0,0,0,.18)'; ctx.lineWidth=1; ctx.setLineDash([4,8]);
      const v1=W/3,v2=2*W/3,h1=H/3,h2=2*H/3;
      ctx.beginPath();
      [v1,v2].forEach(x=>{ctx.moveTo(x,0);ctx.lineTo(x,H);});
      [h1,h2].forEach(y=>{ctx.moveTo(0,y);ctx.lineTo(W,y);});
      ctx.stroke(); ctx.restore();
    }
    if(state.grid.on){
      const s=state.grid.spacing, a=state.grid.alpha, cx=W/2, cy=H/2;
      ctx.save(); ctx.strokeStyle=`rgba(255,132,0,${a})`; ctx.lineWidth=1; ctx.beginPath();
      if(state.grid.centered){
        for(let x=cx; x<=W; x+=s){ctx.moveTo(x,0);ctx.lineTo(x,H)} for(let x=cx; x>=0; x-=s){ctx.moveTo(x,0);ctx.lineTo(x,H)}
        for(let y=cy; y<=H; y+=s){ctx.moveTo(0,y);ctx.lineTo(W,y)} for(let y=cy; y>=0; y-=s){ctx.moveTo(0,y);ctx.lineTo(W,y)}
      }else{
        for(let x=state.padding; x<=W; x+=s){ctx.moveTo(x,state.padding);ctx.lineTo(x,H-state.padding)}
        for(let y=state.padding; y<=H; y+=s){ctx.moveTo(state.padding,y);ctx.lineTo(W-state.padding,y)}
      }
      ctx.stroke(); ctx.restore();
    }
  }
  function render(){ clear(); drawBackground(); drawText(state.head); drawText(state.sub); drawGuides(); }

  // Helpers
  const $ = (id)=>document.getElementById(id);
  function pointer(e){ const r=canvas.getBoundingClientRect(); return { x:(e.clientX-r.left)*(W/r.width), y:(e.clientY-r.top)*(H/r.height) }; }
  function clamp(n,min,max){return Math.max(min, Math.min(max, n))}
  function rgbToHex(rgb){ if(rgb.startsWith('#')) return rgb; const v=rgb.match(/(\d+),\s*(\d+),\s*(\d+)/); if(!v) return '#ffffff'; const [r,g,b]=[+v[1],+v[2],+v[3]]; return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1); }
  function hexToRgba(hex,a){ const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16); return `rgba(${r},${g},${b},${a})`; }


  const editTree = $('editTree');

function placeTreeAt(x, y){
  const key = tKey(x, y);
  if (trees.has(key)) return;

  const box = tileBox(x, y);
  const trunkH = randInt(TREE_RNG.minTrunk, TREE_RNG.maxTrunk);
  const dia    = randInt(TREE_RNG.minDia,  TREE_RNG.maxDia);

  const wrap = document.createElement('div');
  wrap.className = 'tree';
  wrap.style.width  = dia + 'px';
  wrap.style.height = (trunkH + dia) + 'px';
  wrap.style.left = (box.left + 50 - dia/2) + 'px';
  wrap.style.top  = (box.top  + 50 - trunkH - dia) + 'px';
  wrap.style.zIndex = 5000 + (x + y);

  const trunk = document.createElement('div');
  trunk.className = 'trunk';
  trunk.style.height = trunkH + 'px';

  const canopy = document.createElement('div');
  canopy.className = 'canopy';
  canopy.style.width  = dia + 'px';
  canopy.style.height = dia + 'px';
  canopy.style.left   = '0px';
  canopy.style.bottom = trunkH + 'px';

  wrap.appendChild(trunk);
  wrap.appendChild(canopy);
  grid.appendChild(wrap);
  trees.set(key, wrap);
}

function regenerateTreeAt(x, y){
  removeTreeAt(x, y);
  placeTreeAt(x, y);
}

function removeTreeAt(x, y){
  const key = tKey(x, y);
  const el = trees.get(key);
  if (!el) return;
  el.remove();
  trees.delete(key);
}

/* clear all trees — call on reset and when grid size changes */
function clearAllTrees(){
  for (const el of trees.values()) el.remove();
  trees.clear();
}
/* trees stored by tile index (y*cols + x) */
const trees = new Map();

/* simple ranges for randomness */
const TREE_RNG = {
  minDia: 28,  maxDia: 82,    // canopy diameter
  minTrunk: 18, maxTrunk: 60  // trunk height
};

// Ghost ring for tree placement only (per side)
const TREE_PAD = 20;

// Unique key for any tile, supports negatives & overshoot
const tKey = (x, y) => `${x},${y}`;

function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

/* convenience to compute the tile box top/left (same math as hitbox) */
function tileBox(x, y){
  return {
    left: (x - y) * offsetX + baseLeft,
    top:  (x + y) * offsetY + baseTop
  };
}

  // ---- UI refs
  const bgColor=$('bgColor'), padding=$('padding'), gridToggle=$('gridToggle'), centerToggle=$('centerToggle'), gridSpacing=$('gridSpacing'), gridAlpha=$('gridAlpha');
  const headline=$('headline'), hAlign=$('hAlign'), hSize=$('hSize'), hFont=$('hFont'), cycleHFont=$('cycleHFont');
  const hOutline=$('hOutline'), hOutlineWidth=$('hOutlineWidth'), hOutlineWidthNum=$('hOutlineWidthNum'), hOutlineColor=$('hOutlineColor');
  const hShadow=$('hShadow'), hShadowBlur=$('hShadowBlur'), hShadowBlurNum=$('hShadowBlurNum'), hShadowOffsetX=$('hShadowOffsetX'), hShadowOffsetY=$('hShadowOffsetY'), hShadowColor=$('hShadowColor'), hShadowOpacity=$('hShadowOpacity');
  const subtitle=$('subtitle'), sAlign=$('sAlign'), sSize=$('sSize'), sFont=$('sFont'), cycleSFont=$('cycleSFont');
  const sOutline=$('sOutline'), sOutlineWidth=$('sOutlineWidth'), sOutlineWidthNum=$('sOutlineWidthNum'), sOutlineColor=$('sOutlineColor');
  const sShadow=$('sShadow'), sShadowBlur=$('sShadowBlur'), sShadowBlurNum=$('sShadowBlurNum'), sShadowOffsetX=$('sShadowOffsetX'), sShadowOffsetY=$('sShadowOffsetY'), sShadowColor=$('sShadowColor'), sShadowOpacity=$('sShadowOpacity');
  const safeToggle=$('safeToggle'), ruleThirds=$('ruleThirds'), reset=$('reset'), exportBtn=$('export');
  const selectHead=$('selectHead'), selectSub=$('selectSub'), editVox=$('editVox');
  const edgeColor=$('edgeColor'), groundColor=$('groundColor'), groundInnerColor=$('groundInnerColor');
  const edgeW=$('edgeW'), vxScale=$('vxScale'), vxX=$('vxX'), vxY=$('vxY'), snapCenter=$('snapCenter'), edgesToggle=$('edgesToggle');
  const colsInput=$('colsInput'), rowsInput=$('rowsInput'), resizeGridBtn=$('resizeGridBtn'), levelBtn=$('levelBtn'), drawAllBtn=$('drawAllBtn'), deleteBtn=$('deleteBtn'), ideasBtn=$('ideasBtn'), proModeBtn=$('proModeBtn');

  // Fonts dropdowns
  function initFontDropdowns(){
    FONTS.forEach(f=>{ const o1=document.createElement('option'); o1.value=f.name; o1.textContent=f.name; hFont.appendChild(o1);
                       const o2=document.createElement('option'); o2.value=f.name; o2.textContent=f.name; sFont.appendChild(o2); });
    hFont.value=state.head.font.name; sFont.value=state.sub.font.name;
  }

  // Swatches
  document.querySelectorAll('.dot').forEach(dot=>{
    dot.addEventListener('click',()=>{
      document.querySelectorAll('.dot').forEach(d=>d.classList.remove('active'));
      dot.classList.add('active');
      const key=dot.getAttribute('data-color');
      const colorValue = key==='orange'?ORANGE : key==='offblack'?OFFBLACK : OFFWHITE;
      state.bg=colorValue; bgColor.value=rgbToHex(colorValue); render();
    });
  });

  // Headline/Sub colors
  document.querySelectorAll('[data-hcolor]').forEach(btn=>btn.addEventListener('click',()=>{
    const key=btn.getAttribute('data-hcolor'); state.head.color= key==='orange'?ORANGE : key==='offwhite'?OFFWHITE : OFFBLACK; render();
  }));
  document.querySelectorAll('[data-scolor]').forEach(btn=>btn.addEventListener('click',()=>{
    const key=btn.getAttribute('data-scolor'); state.sub.color= key==='orange'?ORANGE : key==='offwhite'?OFFWHITE : OFFBLACK; render();
  }));

  // Voxel color pickers
  edgeColor.addEventListener('input', e=>setEdgeColor(e.target.value));
  groundColor.addEventListener('input', e=>setGround(e.target.value));
  groundInnerColor.addEventListener('input', e=>setGroundInner(e.target.value));

  // Font cycling
  cycleHFont.addEventListener('click',()=>{ const i=FONTS.findIndex(f=>f.name===state.head.font.name); const n=(i+1)%FONTS.length; state.head.font=FONTS[n]; hFont.value=state.head.font.name; showToast(`Headline font: ${state.head.font.name}`); render(); });
  cycleSFont.addEventListener('click',()=>{ const i=FONTS.findIndex(f=>f.name===state.sub.font.name); const n=(i+1)%FONTS.length; state.sub.font=FONTS[n]; sFont.value=state.sub.font.name; showToast(`Subtitle font: ${state.sub.font.name}`); render(); });

  hFont.addEventListener('change',()=>{ const f=FONTS.find(x=>x.name===hFont.value); if(f){state.head.font=f; render();} });
  sFont.addEventListener('change',()=>{ const f=FONTS.find(x=>x.name===sFont.value); if(f){state.sub.font=f; render();} });

  // Headline outline/shadow
  hOutline.addEventListener('click',()=>{ state.head.outline=!state.head.outline; hOutline.classList.toggle('active',state.head.outline); hOutline.textContent=state.head.outline?'ON':'OFF'; render(); });
  hOutlineWidth.addEventListener('input',e=>{ state.head.outlineWidth=+e.target.value; hOutlineWidthNum.value=e.target.value; render(); });
  hOutlineWidthNum.addEventListener('input',e=>{ state.head.outlineWidth=+e.target.value; hOutlineWidth.value=e.target.value; render(); });
  hOutlineColor.addEventListener('input',e=>{ state.head.outlineColor=e.target.value; render(); });

  hShadow.addEventListener('click',()=>{ state.head.shadow=!state.head.shadow; hShadow.classList.toggle('active',state.head.shadow); hShadow.textContent=state.head.shadow?'ON':'OFF'; render(); });
  hShadowBlur.addEventListener('input',e=>{ state.head.shadowBlur=+e.target.value; hShadowBlurNum.value=e.target.value; render(); });
  hShadowBlurNum.addEventListener('input',e=>{ state.head.shadowBlur=+e.target.value; hShadowBlur.value=e.target.value; render(); });
  hShadowOffsetX.addEventListener('input',e=>{ state.head.shadowOffsetX=+e.target.value; render(); });
  hShadowOffsetY.addEventListener('input',e=>{ state.head.shadowOffsetY=+e.target.value; render(); });
  hShadowColor.addEventListener('input',e=>{ state.head.shadowColor=e.target.value; render(); });
  hShadowOpacity.addEventListener('input',e=>{ state.head.shadowOpacity=+e.target.value; render(); });

  // Subtitle outline/shadow
  sOutline.addEventListener('click',()=>{ state.sub.outline=!state.sub.outline; sOutline.classList.toggle('active',state.sub.outline); sOutline.textContent=state.sub.outline?'ON':'OFF'; render(); });
  sOutlineWidth.addEventListener('input',e=>{ state.sub.outlineWidth=+e.target.value; sOutlineWidthNum.value=e.target.value; render(); });
  sOutlineWidthNum.addEventListener('input',e=>{ state.sub.outlineWidth=+e.target.value; sOutlineWidth.value=e.target.value; render(); });
  sOutlineColor.addEventListener('input',e=>{ state.sub.outlineColor=e.target.value; render(); });

  sShadow.addEventListener('click',()=>{ state.sub.shadow=!state.sub.shadow; sShadow.classList.toggle('active',state.sub.shadow); sShadow.textContent=state.sub.shadow?'ON':'OFF'; render(); });
  sShadowBlur.addEventListener('input',e=>{ state.sub.shadowBlur=+e.target.value; sShadowBlurNum.value=e.target.value; render(); });
  sShadowBlurNum.addEventListener('input',e=>{ state.sub.shadowBlur=+e.target.value; sShadowBlur.value=e.target.value; render(); });
  sShadowOffsetX.addEventListener('input',e=>{ state.sub.shadowOffsetX=+e.target.value; render(); });
  sShadowOffsetY.addEventListener('input',e=>{ state.sub.shadowOffsetY=+e.target.value; render(); });
  sShadowColor.addEventListener('input',e=>{ state.sub.shadowColor=e.target.value; render(); });
  sShadowOpacity.addEventListener('input',e=>{ state.sub.shadowOpacity=+e.target.value; render(); });

  // BG & guides
  bgColor.addEventListener('input',e=>{ state.bg=e.target.value; render(); })
  padding.addEventListener('input',e=>{ state.padding=clamp(+e.target.value,0,200); render(); })
  gridToggle.addEventListener('click',()=>{ state.grid.on=!state.grid.on; gridToggle.textContent=`Grid: ${state.grid.on?'On':'Off'}`; render(); })
  centerToggle.addEventListener('click',()=>{ state.grid.centered=!state.grid.centered; centerToggle.textContent=`Centered: ${state.grid.centered?'On':'Off'}`; render(); })
  gridSpacing.addEventListener('input',e=>{ state.grid.spacing=+e.target.value; render(); })
  gridAlpha.addEventListener('input',e=>{ state.grid.alpha=+e.target.value; render(); })
  headline.addEventListener('input',e=>{ state.head.text=e.target.value; render(); })
  hAlign.addEventListener('change',e=>{ state.head.align=e.target.value; state.head.x = e.target.value==='center'?W/2 : e.target.value==='left'?state.padding : (W-state.padding); render(); })
  hSize.addEventListener('input',e=>{ state.head.size=+e.target.value; render(); })
  subtitle.addEventListener('input',e=>{ state.sub.text=e.target.value; render(); })
  sAlign.addEventListener('change',e=>{ state.sub.align=e.target.value; state.sub.x = e.target.value==='center'?W/2 : e.target.value==='left'?state.padding : (W-state.padding); render(); })
  sSize.addEventListener('input',e=>{ state.sub.size=+e.target.value; render(); })
  safeToggle.addEventListener('click',()=>{ state.safeOn=!state.safeOn; safeToggle.textContent=`Safe: ${state.safeOn?'On':'Off'}`; render(); })
  ruleThirds.addEventListener('click',()=>{ state.thirds=!state.thirds; ruleThirds.classList.toggle('primary',state.thirds); render(); })

  // ---- Mode switch (mutually exclusive buttons)
const buttons = { head:selectHead, sub:selectSub, vox:editVox, tree:editTree };
let lastTextMode = 'head';

function setHitboxesForMode(){
  const layer = document.querySelector('.voxel-layer');
  const realHB  = layer.querySelectorAll('.hitbox:not(.ghost)');
  const ghostHB = layer.querySelectorAll('.hitbox.ghost');

  if (state.mode === 'tree'){
    layer.style.pointerEvents = 'auto';
    realHB.forEach(h => h.style.pointerEvents = 'auto');
    ghostHB.forEach(h => h.style.pointerEvents = 'auto');   // enable ghosts only in tree mode
  } else if (state.mode === 'vox'){
    layer.style.pointerEvents = 'auto';
    realHB.forEach(h => h.style.pointerEvents = 'auto');
    ghostHB.forEach(h => h.style.pointerEvents = 'none');   // KEY: disable ghosts in voxel mode
  } else {
    layer.style.pointerEvents = 'none';
    realHB.forEach(h => h.style.pointerEvents = 'none');
    ghostHB.forEach(h => h.style.pointerEvents = 'none');
  }
}


function setMode(mode){
  state.mode = mode;
  buttons.head.classList.toggle('active', mode==='head');
  buttons.sub .classList.toggle('active', mode==='sub');
  buttons.vox .classList.toggle('active', mode==='vox');
  buttons.tree.classList.toggle('active', mode==='tree');

  if (mode==='head' || mode==='sub'){
    state.selection = mode; lastTextMode = mode;
  } else {
    state.selection = null;
  }
  setHitboxesForMode();   // <- apply correct pointer-events
}

/* wire the new button */
editTree.addEventListener('click', ()=>{
  if (state.mode==='tree') setMode(lastTextMode);
  else setMode('tree');
});


  selectHead.addEventListener('click',()=>setMode('head'));
  selectSub .addEventListener('click',()=>setMode('sub'));
  editVox  .addEventListener('click',()=>{ if(state.mode==='vox') setMode(lastTextMode); else setMode('vox'); });

  // Text dragging (blocked in voxel mode)
  let dragging=false, dx=0, dy=0;
  canvas.addEventListener('mousedown',(e)=>{
    if(state.mode==='vox') return;
    dragging=true; const pt=pointer(e);
    if(state.selection==='head'){ dx=pt.x-state.head.x; dy=pt.y-state.head.y; }
    if(state.selection==='sub'){  dx=pt.x-state.sub.x;  dy=pt.y-state.sub.y;  }
  });
  window.addEventListener('mousemove',(e)=>{
    if(state.mode==='vox' || !dragging) return;
    const pt=pointer(e);
    if(state.selection==='head'){ state.head.x=pt.x-dx; state.head.y=pt.y-dy; }
    if(state.selection==='sub'){  state.sub.x=pt.x-dx;  state.sub.y=pt.y-dy;  }
    render();
  });
  window.addEventListener('mouseup',()=>dragging=false);

  // Right-click to cycle alignment (disabled in voxel mode)
  canvas.addEventListener('contextmenu',(e)=>{
    e.preventDefault();
    if(state.mode==='vox') return;
    if(state.selection==='head' || state.selection==='sub'){
      const a=['left','center','right']; const cur=state[state.selection].align; const next=a[(a.indexOf(cur)+1)%a.length];
      state[state.selection].align=next;
      state[state.selection].x = next==='center'?W/2 : next==='left'?state.padding : (W-state.padding);
      if(state.selection==='head') hAlign.value=next; else sAlign.value=next;
      showToast(`${state.selection==='head'?'Headline':'Subtitle'} alignment: ${next}`); render();
    }
  });

  // ---- Voxel grid fns
  function setVoxelScale(s){ state.voxel.scale=s; $('voxel').style.transform=`translate(-50%,-50%) scale(${s})`; }
  function setVoxelPos(x,y){ state.voxel.x=x; state.voxel.y=y; const el=$('voxel'); el.style.left=(x/W*100)+'%'; el.style.top=(y/H*100)+'%'; }

  const grid=$('grid'), areaInfo=$('areaInfo'), priceInfo=$('priceInfo');
  let cols=8, rows=20, baseLeft=0, currentLevel=1, proMode=false, lastState=[], edgesVisible=true, currentIdeaIndex=-1;
  const offsetX=50, offsetY=25, baseTop=120, voxelArea=160/18, pricePerM2=20000;
  const voxels=[], faces=[];
  const designIdeas=[
    { name:'Bridge House', data:[{"x":0,"y":0,"level":2},{"x":1,"y":0,"level":2},{"x":2,"y":0,"level":2},{"x":0,"y":1,"level":2},{"x":1,"y":1,"level":2},{"x":2,"y":1,"level":2},{"x":0,"y":2,"level":1},{"x":0,"y":3,"level":1},{"x":0,"y":4,"level":2},{"x":1,"y":4,"level":2},{"x":2,"y":4,"level":2},{"x":0,"y":5,"level":2},{"x":1,"y":5,"level":2},{"x":2,"y":5,"level":2}]},
    { name:'Hacienda Style', data:[{"x":0,"y":0,"level":2},{"x":1,"y":0,"level":2},{"x":2,"y":0,"level":2},{"x":0,"y":1,"level":2},{"x":1,"y":1,"level":2},{"x":2,"y":1,"level":2},{"x":1,"y":2,"level":2},{"x":1,"y":3,"level":2},{"x":0,"y":4,"level":3},{"x":1,"y":4,"level":3},{"x":2,"y":4,"level":1},{"x":0,"y":5,"level":3},{"x":1,"y":5,"level":3},{"x":2,"y":5,"level":1}]},
    { name:'Stairways', data:[{"x":0,"y":1,"level":2},{"x":1,"y":1,"level":2},{"x":2,"y":1,"level":2},{"x":0,"y":2,"level":2},{"x":2,"y":2,"level":2},{"x":0,"y":3,"level":2},{"x":2,"y":3,"level":2},{"x":0,"y":4,"level":2},{"x":1,"y":4,"level":2},{"x":2,"y":4,"level":2},{"x":0,"y":5,"level":1},{"x":1,"y":5,"level":1},{"x":2,"y":5,"level":1}]}
  ];

  function createFace(x,y,z,type){
    const face=document.createElement('div'); face.className=`face ${type}`;
    face.style.left=`${(x-y)*offsetX + baseLeft}px`;
    face.style.top =`${(x+y)*offsetY + baseTop - z*50}px`;
    face.style.zIndex=`${(x+y)*100 + z*10 + (type==='top'?2:1)}`;
    const inner=document.createElement('div'); inner.className='inner'; face.appendChild(inner);
    const edge=document.createElement('div'); edge.className=`edge-${type}`; face.appendChild(edge);
    grid.appendChild(face); faces.push(face);
  }
  function createBottom(x,y){
    const face=document.createElement('div'); face.className='face bottom';
    face.style.left=`${(x-y)*offsetX + baseLeft}px`; face.style.top=`${(x+y)*offsetY + baseTop}px`; face.style.zIndex='0';
    const inner=document.createElement('div'); inner.className='inner'; face.appendChild(inner);
    grid.appendChild(face);
  }
  function createBottom2(x,y){
    const face=document.createElement('div'); face.className='face bottom2';
    face.style.left=`${(x-y)*offsetX + baseLeft}px`; face.style.top=`${(x+y)*offsetY + baseTop}px`; face.style.zIndex='2';
    const inner=document.createElement('div'); inner.className='inner'; face.appendChild(inner);
    const edge=document.createElement('div'); edge.className='edge-bottom2'; face.appendChild(edge);
    grid.appendChild(face); faces.push(face);
  }
  function clearFaces(){ for(const f of faces) grid.removeChild(f); faces.length=0; }
  function buildVoxel(){
    clearFaces();
    for(const v of voxels){
      if(!v.active) continue;
      if(v.level===0){ createBottom2(v.x,v.y); }
      else{
        for(let i=v.base;i<v.base+v.level;i++){ createFace(v.x,v.y,i,'left'); createFace(v.x,v.y,i,'right'); }
        createFace(v.x,v.y,v.base+v.level-1,'top');
      }
    }
  }
  function updateStats(){
    let totalVoxels = voxels.reduce((acc,v)=>acc+v.level,0);
    const totalArea = Math.round(totalVoxels*voxelArea);
    const totalPrice = Math.round((totalArea*pricePerM2)/1000)*1000;
    if(areaInfo) areaInfo.textContent=`Construction size: ${totalArea} m²`;
    if(priceInfo) priceInfo.textContent=`Estimated price: $${totalPrice.toLocaleString()}`;
  }

  function cycleLevel(){ currentLevel=(currentLevel+1)%10; levelBtn.textContent=`Level: ${currentLevel}`;
    voxels.forEach(v=>{ if(v.active){ v.level=currentLevel; v.base=0; }}); buildVoxel(); updateStats(); }

  function handleDelete(){
    if(deleteBtn.textContent==='Undo'){
      lastState.forEach(({level,base},i)=>{ voxels[i].level=level; voxels[i].base=base; voxels[i].active=level>0; });
      deleteBtn.textContent='Delete All';
    }else{
      lastState=voxels.map(v=>({level:v.level, base:v.base}));
      voxels.forEach(v=>{ v.active=false; v.level=0; v.base=0; });
      ideasBtn.textContent='Design Ideas'; deleteBtn.textContent='Undo';
    }
    buildVoxel(); updateStats();
  }
  function drawAll(){ voxels.forEach(v=>{ v.level=currentLevel; v.base=0; v.active=true; }); buildVoxel(); updateStats();
    if(deleteBtn.textContent==='Undo') deleteBtn.textContent='Delete All'; ideasBtn.textContent='Design Ideas'; }

  function exportGrid(){ const data=voxels.filter(v=>v.active).map(v=>({x:v.x,y:v.y,level:v.level}));
    const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
    const link=document.createElement('a'); link.href=URL.createObjectURL(blob); link.download='voxel-grid.json'; link.click(); }

  function importGrid(data){
    voxels.forEach(v=>{ const m=data.find(d=>d.x===v.x && d.y===v.y);
      if(m){ v.level=m.level; v.base=0; v.active=true; } else { v.level=0; v.base=0; v.active=false; }});
    buildVoxel(); updateStats();
  }

  function buildGhostHitboxes(){
  // wipe previous ghosts if reinitializing
  grid.querySelectorAll('.hitbox.ghost').forEach(n => n.remove());

  for (let gy = -TREE_PAD; gy < rows + TREE_PAD; gy++){
    for (let gx = -TREE_PAD; gx < cols + TREE_PAD; gx++){
      // skip real tiles — we already created their hitboxes
      if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) continue;

      const hb = document.createElement('div');
      hb.className = 'hitbox ghost';
      hb.style.left = `${(gx - gy) * offsetX + baseLeft}px`;
      hb.style.top  = `${(gx + gy) * offsetY + baseTop}px`;

      // tree-only behavior
      hb.addEventListener('click', () => {
        if (state.mode !== 'tree') return;
        const key = tKey(gx, gy);
        if (trees.has(key)) regenerateTreeAt(gx, gy); else placeTreeAt(gx, gy);
      });
      hb.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        if (state.mode !== 'tree') return;
        removeTreeAt(gx, gy);
      });

      grid.appendChild(hb);
    }
  }
}

  function initGrid(){
    clearFaces(); voxels.length=0; grid.innerHTML=''; baseLeft=grid.offsetWidth/1.8;
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const voxelData={x,y,level:0,base:0,active:false}; voxels.push(voxelData);
        const hitbox=document.createElement('div'); hitbox.className='hitbox';
        hitbox.style.left=`${(x-y)*offsetX + baseLeft}px`;
        hitbox.style.top =`${(x+y)*offsetY + baseTop}px`;

hitbox.addEventListener('click', ()=>{
  // toggle behavior by mode
  if (state.mode === 'vox'){
    if(deleteBtn.textContent==='Undo') deleteBtn.textContent='Delete All';
    ideasBtn.textContent='Design Ideas';
    if(proMode){
      if(voxelData.level===0 && voxelData.base===9){ voxelData.level=1; voxelData.base=0; voxelData.active=true; }
      else if(voxelData.base>0){ voxelData.base-=1; voxelData.level+=1; voxelData.active=true; }
      else if(voxelData.level + voxelData.base < 9){ voxelData.level+=1; voxelData.active=true; }
      else { voxelData.level=0; voxelData.base=0; voxelData.active=false; }
    } else {
      voxelData.active=!voxelData.active; voxelData.level=voxelData.active?currentLevel:0; voxelData.base=0;
    }
    buildVoxel(); updateStats(); 
} else if (state.mode === 'tree'){
  const key = tKey(x, y);
  if (trees.has(key)) {
    regenerateTreeAt(x, y);   // left-click re-rolls size
  } else {
    placeTreeAt(x, y);        // left-click places new
  }
}
});

hitbox.addEventListener('contextmenu',(e)=>{
  e.preventDefault();
  if (state.mode === 'vox'){
    if(!proMode) return;
    if(deleteBtn.textContent==='Undo') deleteBtn.textContent='Delete All';
    ideasBtn.textContent='Design Ideas';
    if(voxelData.level>0){
      voxelData.level-=1; voxelData.base+=1; voxelData.active=voxelData.level>0; buildVoxel(); updateStats();
    }
  } else if (state.mode === 'tree'){
    removeTreeAt(x, y);                      // right-click deletes
  }
});

        grid.appendChild(hitbox);
        createBottom(x,y);
      }
    }
    buildVoxel(); updateStats();buildGhostHitboxes();setHitboxesForMode();
  }

  // Sidebar hooks
  levelBtn.addEventListener('click',cycleLevel);
  deleteBtn.addEventListener('click',handleDelete);
  drawAllBtn.addEventListener('click',drawAll);
  ideasBtn.addEventListener('click',()=>{
    currentIdeaIndex=(currentIdeaIndex+1)%designIdeas.length; const idea=designIdeas[currentIdeaIndex];
    voxels.forEach(v=>{ v.active=false; v.level=0; v.base=0; });
    idea.data.forEach(({x,y,level})=>{ const idx=y*cols+x; if(voxels[idx]){ voxels[idx].level=level; voxels[idx].base=0; voxels[idx].active=true; }});
    ideasBtn.textContent=idea.name; deleteBtn.textContent='Delete All'; buildVoxel(); updateStats();
  });

  proModeBtn.addEventListener('click',()=>{
    proMode=!proMode; proModeBtn.textContent=proMode?'Simple Mode':'🔒 Pro Mode'; levelBtn.disabled=proMode;
    const existingExportBtn=document.getElementById('exportBtn');
    const existingImportBtn=document.getElementById('importBtn');
    const controlsContainer=document.querySelector('.panel .group');
    if(proMode){
      if(!existingExportBtn){ const b=document.createElement('button'); b.id='exportBtn'; b.textContent='Export JSON'; b.onclick=exportGrid; controlsContainer.appendChild(b); }
      if(!existingImportBtn){ const b=document.createElement('button'); b.id='importBtn'; b.textContent='Import JSON'; b.onclick=()=>document.getElementById('importInput').click(); controlsContainer.appendChild(b); }
    }else{
      if(existingExportBtn) existingExportBtn.remove();
      if(existingImportBtn) existingImportBtn.remove();
    }
  });

  resizeGridBtn.addEventListener('click',()=>{
    const newRows=parseInt(rowsInput.value), newCols=parseInt(colsInput.value);
    if(isNaN(newRows)||isNaN(newCols)||newRows<1||newCols<1){ alert('Invalid grid size.'); return; }
    rows=newRows; cols=newCols; initGrid(); clearAllTrees();
  });

  document.getElementById('importInput').addEventListener('change',function(e){
    const file=e.target.files[0]; if(!file) return;
    const reader=new FileReader();
    reader.onload=function(e){ try{ const data=JSON.parse(e.target.result); importGrid(data); showToast('Voxel grid imported'); }catch(err){ alert('Error importing file: '+err.message); } };
    reader.readAsText(file); this.value='';
  });

  // Edge width / visibility and colors
  if(edgeW){ edgeW.value=state.voxel.edgeW; edgeW.addEventListener('input',e=>setEdgeWidth(+e.target.value)); }
  vxScale.addEventListener('input',e=>setVoxelScale(+e.target.value/100));
  vxX.addEventListener('input',e=>setVoxelPos(+e.target.value,state.voxel.y));
  vxY.addEventListener('input',e=>setVoxelPos(state.voxel.x,+e.target.value));
  snapCenter.addEventListener('click',()=>{ vxX.value=W/2; vxY.value=H/2; setVoxelPos(W/2,H/2); });
  edgesToggle.addEventListener('click',()=>{ setEdges(!state.voxel.edges); buildVoxel(); });

  // Export PNG
  exportBtn.addEventListener('click', async ()=>{
    const hint=document.querySelector('.guides-hint'); const prev=hint.style.display; hint.style.display='none';
    const shell=$('shell'); const canvasOut=await html2canvas(shell,{backgroundColor:null,useCORS:true,scale:2});
    const link=document.createElement('a'); link.download=`post_1080x1350.png`; link.href=canvasOut.toDataURL('image/png'); link.click();
    hint.style.display=prev||'';
  });

  // Utilities: edges/colors
  function setEdgeWidth(px){
    const v=Math.max(0,Math.round(px)); state.voxel.edgeW=v;
    if(state.voxel.edges){ document.documentElement.style.setProperty('--edge-w', v+'px'); }
  }
  function setEdges(on){
    state.voxel.edges=on; edgesToggle.textContent=`Edges: ${on?'On':'Off'}`;
    document.documentElement.style.setProperty('--edge-display', on?'block':'none');
    document.documentElement.style.setProperty('--edge-w', on?(state.voxel.edgeW+'px'):'0px');
  }
  function setEdgeColor(c){ document.documentElement.style.setProperty('--edge-color', c); }
  function setGround(c){ document.documentElement.style.setProperty('--ground', c); }
  function setGroundInner(c){ document.documentElement.style.setProperty('--ground-inner', c); }

  // Reset
  reset.addEventListener('click',()=>{
    Object.assign(state,{
      bg:OFFWHITE, padding:90, grid:{on:true, centered:true, spacing:120, alpha:.25}, safeOn:true, thirds:false,
      head:{ text:'HELLO, IG!', size:120, color:OFFBLACK, align:'center', x:W/2, y:H*0.2, font:FONTS[0], weight:400, outline:false, outlineColor:OFFWHITE, outlineWidth:2, shadow:false, shadowOffsetX:4, shadowOffsetY:4, shadowBlur:0, shadowColor:'#000000', shadowOpacity:0.5 },
      sub:{  text:'Clean, bold, fast.', size:48, color:OFFBLACK, align:'center', x:W/2, y:H*0.32, font:FONTS[1], weight:400, outline:false, outlineColor:OFFWHITE, outlineWidth:2, shadow:false, shadowOffsetX:2, shadowOffsetY:2, shadowBlur:0, shadowColor:'#000000', shadowOpacity:0.5 },
      voxel:{ x:W/2, y:H*0.5, scale:1, edges:true, edgeW:3 }, mode:'head', selection:'head'
    });
    document.querySelectorAll('.dot').forEach((d,i)=>d.classList.toggle('active', i===0));
    bgColor.value='#fcfaf3'; hAlign.value='center'; sAlign.value='center'; hFont.value=FONTS[0].name; sFont.value=FONTS[1].name;
    ['hOutline','hShadow','sOutline','sShadow'].forEach(id=>{ const b=$(id); b.textContent='OFF'; b.classList.remove('active'); });
    vxScale.value=100; vxX.value=W/2; vxY.value=H*0.5; setVoxelPos(state.voxel.x,state.voxel.y); setVoxelScale(1); setEdgeWidth(state.voxel.edgeW); setEdges(true);
    setEdgeColor('#ff8400'); setGround('#2a2a2a'); setGroundInner('#3a3a3a');
    if(edgeColor) edgeColor.value='#ff8400'; if(groundColor) groundColor.value='#2a2a2a'; if(groundInnerColor) groundInnerColor.value='#3a3a3a';
    colsInput.value=8; rowsInput.value=20; currentLevel=1; levelBtn.textContent='Level: 1'; deleteBtn.textContent='Delete All'; ideasBtn.textContent='Design Ideas';
    proMode=false; proModeBtn.textContent='🔒 Pro Mode'; initGrid();
    setMode('head'); render();
    clearAllTrees();
  });

  // Init
  initFontDropdowns();
  initGrid();
  setMode('head');               // default = drag text
  render();
  setEdgeWidth(state.voxel.edgeW);
  setEdges(true);
  setEdgeColor(edgeColor.value); setGround(groundColor.value); setGroundInner(groundInnerColor.value);
</script>
</body>
</html>
