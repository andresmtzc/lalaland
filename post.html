
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>IG 4×5 Post Designer with Voxel Grid</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet"/>
  <link href="https://fonts.googleapis.com/css2?family=Anton&family=Barlow+Condensed:wght@400;600;800&family=Oswald:wght@400;600&family=Montserrat:wght@400;700;900&family=Playfair+Display:wght@700&family=Raleway:wght@800&family=Roboto+Condensed:wght@700&display=swap" rel="stylesheet"/>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    :root{
      --edge-color:#ff8400;
      --brand-orange:#ff8400;
      --off-white:#fcfaf3;
      --off-black:#1a1a1a;
      --edge-display:block;
      --edge-w:3px;
      --blue-top:#ffd199;
      --blue-left:#ff9a2d;
      --blue-right:#ff8400;
      --ground:#2a2a2a;
      --ground-inner:#3a3a3a;
      --grid-hover:rgba(255,255,255,.15);
      --tree-fill:#00D1B2;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--off-black); color:#ddd; font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      display:grid; grid-template-columns:320px 1fr; gap:20px; padding:20px;
    }

    /* Sidebar */
    .panel{background:#111; border:1px solid #262626; border-radius:16px; padding:16px; box-shadow:0 4px 24px rgba(0,0,0,.35)}
    .panel h2{margin:0 0 12px; font-size:18px; font-weight:800; color:#fff}
    .group{margin-bottom:14px}
    .group label{display:block; font-size:12px; color:#9aa0a6; margin-bottom:6px}
    .row{display:flex; gap:8px; align-items:center}
    .row > *{flex:1}
    input[type="text"], input[type="number"], select{width:100%; background:#0f0f0f; color:#e6e6e6; border:1px solid #2a2a2a; padding:10px 12px; border-radius:10px}
    input[type="range"]{width:100%}
    button{background:#1f1f1f; color:#fff; border:1px solid #2a2a2a; padding:10px 12px; border-radius:12px; cursor:pointer}
    button.primary{background:var(--brand-orange); color:#1b1b1b; border:none; font-weight:800}
    button:disabled{opacity:.5; cursor:not-allowed}
    button.active{background:var(--brand-orange); color:#1b1b1b}

    .swatch{display:flex; gap:8px}
    .dot{width:28px; height:28px; border-radius:50%; border:2px solid #2a2a2a; cursor:pointer}
    .dot[data-color="orange"]{background:var(--brand-orange)}
    .dot[data-color="offwhite"]{background:var(--off-white)}
    .dot[data-color="offblack"]{background:var(--off-black)}
    .dot[data-color="teal"]{background:#00D1B2}
.dot[data-color="gray"]{background:#525252}
    .dot.active{outline:2px solid #fff}

    /* Font style controls */
    .font-style-grid{display:grid; grid-template-columns:1fr 1fr; gap:6px; margin-top:8px}
    .style-group{background:#0a0a0a; border:1px solid #1f1f1f; border-radius:8px; padding:8px}
    .style-group label{font-size:10px; color:#888; margin-bottom:4px; display:block}
    .style-row{display:flex; gap:4px; align-items:center; margin-bottom:4px}
    .style-row:last-child{margin-bottom:0}
    .style-toggle{font-size:10px; padding:4px 6px; min-width:35px}
    .style-slider{flex:1; min-width:0}
    .mini-input{width:40px; padding:4px 6px; font-size:10px; border-radius:6px}
    textarea{
      width:100%; background:#0f0f0f; color:#e6e6e6;
      border:1px solid #2a2a2a; padding:10px 12px; border-radius:10px;
      resize:vertical; min-height:44px; font:inherit; line-height:1.3;
    }

    /* Stage */
    .stage-wrap{display:grid; place-items:center; overflow:auto}
    .stage-bg{background:#0b0b0b; border:1px dashed #2a2a2a; border-radius:16px; padding:20px; width:100%; height:100%; min-height:80vh}

    /* 4:5 canvas holder */
    .shell{position:relative; aspect-ratio:4/5; width:min(80vh, min(80vw, 900px)); background:var(--off-white); border-radius:0px; box-shadow:0 30px 70px rgba(0,0,0,.5); overflow:hidden; z-index:0}
    .shell .badge{position:absolute; left:12px; bottom:12px; font-size:12px; color:#777; background:rgba(255,255,255,.04); padding:6px 8px; border:1px solid rgba(255,255,255,.08); border-radius:8px; backdrop-filter:blur(4px); z-index:1000}

    /* Canvas */
    canvas#art{position:absolute; inset:0; width:100%; height:100%; display:block; z-index:1; pointer-events:auto; border-radius:0px}

    /* Voxels */
    .voxel-layer{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%) scale(1); width:1200px; height:900px; pointer-events:none; z-index:2}
    .voxel-layer *{box-sizing:border-box}
    .voxel-layer .info{color:#fff; display:none}
    .voxel-layer .viewport{width:100%; height:100%; display:flex; justify-content:center; align-items:center; position:relative}

  .voxel-layer .grid-container{
  position:relative;
  width:800px;
  height:400px;
  --grid-scale: 0.8;                 /* <— new */
  transform: scale(var(--grid-scale));
  transform-origin: center;
}

    .voxel-layer .controls{display:none}
    .guides-hint{position:absolute; top:12px; right:12px; font-size:12px; color:#a8a8a8; z-index:1000}

    .voxel-layer .face{position:absolute; width:100px; height:100px; pointer-events:none}
    .voxel-layer .inner{
      position:absolute; left:var(--edge-w); top:var(--edge-w);
      width:calc(100% - 2*var(--edge-w)); height:calc(100% - 2*var(--edge-w));
      clip-path:inherit; z-index:2;
    }

    .voxel-layer .top{clip-path:polygon(50% 0%, 100% 25%, 50% 50%, 0% 25%)}
    .voxel-layer .top .inner{background:var(--blue-top)}
    .voxel-layer .left{clip-path:polygon(0% 25%, 50% 50%, 50% 100%, 0% 75%)}
    .voxel-layer .left .inner{background:var(--blue-left)}
    .voxel-layer .right{clip-path:polygon(100% 25%, 50% 50%, 50% 100%, 100% 75%)}
    .voxel-layer .right .inner{background:var(--blue-right)}
    .voxel-layer .bottom2{clip-path:polygon(50% 0%, 100% 25%, 50% 50%, 0% 25%); transform:translateY(50px)}
    .voxel-layer .bottom2 .inner{background:var(--blue-top)}
    .voxel-layer .bottom{background:var(--ground); clip-path:polygon(50% 0%, 100% 25%, 50% 50%, 0% 25%); transform:translateY(50px); pointer-events:none}
    .voxel-layer .bottom .inner{background:var(--ground-inner); width:98px; height:98px; left:1px; top:1px; clip-path:inherit; position:absolute}

    .voxel-layer .edge-top,
    .voxel-layer .edge-left,
    .voxel-layer .edge-right,
    .voxel-layer .edge-bottom2{
      position:absolute; width:100px; height:100px; z-index:1; pointer-events:none;
      display:var(--edge-display, none); background:var(--edge-color); clip-path:inherit; transform:inherit;
    }

    /* Hitboxes (enabled per mode) */
    .voxel-layer .hitbox{
      width:100px; height:100px; position:absolute; top:0; left:0;
      transform:translateY(50px);
      pointer-events:none; /* JS toggles */
      z-index:9999; background:transparent;
    }
    .voxel-layer .hitbox::before{
      content:""; position:absolute; width:100px; height:100px;
      clip-path:polygon(50% 0%, 100% 25%, 50% 50%, 0% 25%);
      background:transparent; transition:background .2s ease; z-index:9999;
    }
    .voxel-layer .hitbox:hover::before{background:var(--grid-hover); cursor:crosshair}
    .voxel-layer .hitbox.ghost::before{background:transparent !important}

    /* Toolbar */
    .toolbar{position:absolute; top:12px; left:12px; display:flex; gap:8px; z-index:1000}
    .toolbar button{padding:8px 10px; border-radius:10px}

    /* Toast */
    .toast{
      position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,.8); color:#fff; padding:12px 20px; border-radius:8px;
      z-index:2000; opacity:0; transition:opacity .3s; pointer-events:none;
    }
    .toast.show{opacity:1}

    /* Trees (DOM) */
.voxel-layer .tree{
  position:absolute;
  width:40px;           /* JS overrides per-tree */
  height:40px;          /* JS overrides per-tree */
  pointer-events:none;  /* let clicks go to hitboxes */
}
.voxel-layer .tree .trunk{
  position:absolute;
  bottom:0;
  left:50%;
  transform:translateX(-50%);
  width:var(--edge-w);          /* skinny trunk */
  background:var(--tree-fill);  /* uses --tree-fill variable */
  border-radius:999px;
}
.voxel-layer .tree .canopy{
  position:absolute;
  border-radius:50%;
  background:var(--tree-fill);
}

.dot[data-tcolor="orange"]  { background:#ff8400 }
.dot[data-tcolor="offwhite"]{ background:#fcfaf3 }
.dot[data-tcolor="offblack"]{ background:#1a1a1a }
.dot[data-tcolor="teal"]    { background:#00D1B2 }
.dot[data-tcolor="gray"]    { background:#525252 }

.row .dot {
  flex: 0 0 auto;   /* don't stretch */
  width: 28px;
  height: 28px;
  border-radius: 50%;
}


  </style>
</head>
<body>
  <!-- Sidebar -->
  <aside class="panel" id="sidebar">
    <h2>Post Settings (4×5)</h2>

    <div class="group">
      <label>Persistence</label>
      <div class="row">
  <button id="saveFileBtn">Save to File</button>
  <button id="loadFileBtn">Load from File</button>
  <input type="file" id="loadFileInput" accept="application/json" style="display:none"/>
</div>

    </div>

    <div class="group">
      <label>Preset Background</label>
<div class="swatch">
  <div class="dot active" data-color="offwhite" title="Off-White"></div>
  <div class="dot" data-color="offblack" title="Off-Black"></div>
  <div class="dot" data-color="orange" title="Brand Orange"></div>
  <div class="dot" data-color="teal" title="Teal"></div>        <!-- NEW -->
  <div class="dot" data-color="gray" title="Dark Gray"></div>   <!-- NEW -->
</div>
    </div>

    <div class="group row">
      <div>
        <label>Custom BG</label>
        <input type="color" id="bgColor" value="#fcfaf3"/>
      </div>
      <div>
        <label>Padding (px)</label>
        <input type="number" id="padding" value="90" min="0" max="200"/>
      </div>
    </div>

    <div class="group">
      <label>Voxel Grid</label>
      <label class="row"><span>Scale</span><input type="range" id="vxScale" min="30" max="220" value="100"></label>
      <label class="row"><span>Edge W</span><input type="range" id="edgeW" min="0" max="12" value="3"></label>
      <label class="row"><span>Pos X</span><input type="range" id="vxX" min="0" max="1080" value="540"></label>
      <label class="row"><span>Pos Y</span><input type="range" id="vxY" min="0" max="1350" value="680"></label>
      <div class="row"><button id="snapCenter">Snap Center</button><button id="edgesToggle">Edges: On</button></div>
      <div class="row">
        <label>Cols <input type="number" id="colsInput" min="1" max="40" value="8"></label>
        <label>Rows <input type="number" id="rowsInput" min="1" max="40" value="20"></label>
        <button id="resizeGridBtn">Resize</button>
      </div>
      <div class="row"><button id="levelBtn">Level: 1</button><button id="drawAllBtn">Draw All</button><button id="deleteBtn">Delete All</button></div>
      <div class="row"><button id="ideasBtn">Design Ideas</button><button id="proModeBtn">🔒 Pro Mode</button></div>
    </div>

    <div class="group">
      <label>Grid Overlay</label>
      <div class="row">
        <button id="gridToggle">Grid: On</button>
        <button id="centerToggle">Centered: On</button>
      </div>
      <label class="hint">Spacing</label>
      <input type="range" id="gridSpacing" min="20" max="220" value="120"/>
      <label class="hint">Opacity</label>
      <input type="range" id="gridAlpha" min="0" max="1" step="0.05" value="0.25"/>
    </div>

    <div class="group">
      <label>Voxel Colors</label>
      <div class="row"><span class="mini-label">Edges</span><input type="color" id="edgeColor" value="#ff8400"/></div>
      <div class="row"><span class="mini-label">Ground</span><input type="color" id="groundColor" value="#2a2a2a"/></div>
      <div class="row"><span class="mini-label">Ground Inset</span><input type="color" id="groundInnerColor" value="#3a3a3a"/></div>
    </div>

    <!-- Tree Controls -->
<div class="group" id="treeControls" style="display:none;">
  <label>Trees</label>
  <div class="row">
    <label>Trunk H (min)
      <input type="number" id="treeTrunkMin" value="18" min="0" max="300">
    </label>
    <label>Max
      <input type="number" id="treeTrunkMax" value="60" min="0" max="300">
    </label>
  </div>
  <div class="row">
    <label>Canopy Ø (min)
      <input type="number" id="treeDiaMin" value="28" min="0" max="300">
    </label>
    <label>Max
      <input type="number" id="treeDiaMax" value="82" min="0" max="300">
    </label>
  </div>
  <div class="row">
    <input type="color" id="treeColor" title="Tree color" value="#00D1B2">
    <button id="rerollTreesBtn">Regenerate Sizes</button>
    <button id="deleteTreesBtn">🗑️ Clear Trees</button>
  </div>
</div>


    <!-- Generic Text Panel -->
    <div class="group" id="textControls">
      <label>Text <span id="tWho" style="color:#9aa0a6"></span></label>
      <textarea id="tText" rows="3" placeholder="Type text"></textarea>

      <div class="row">
        <select id="tAlign">
          <option value="center">Center</option>
          <option value="left">Left</option>
          <option value="right">Right</option>
        </select>
        <input type="number" id="tSize" value="80" min="10" max="300"/>
      </div>

<div class="group">
  <label>Text Color</label>
  <div class="swatch row" id="tColorSwatch">
    <div class="dot" data-tcolor="offblack" title="Off-Black"></div>
    <div class="dot" data-tcolor="offwhite" title="Off-White"></div>
    <div class="dot" data-tcolor="orange"   title="Orange"></div>
    <div class="dot" data-tcolor="teal"     title="Teal"></div>
    <div class="dot" data-tcolor="gray"     title="Dark Gray"></div>
  </div>
</div>

      <div class="row">
        <select id="tFont">
          <option value="Anton">Anton</option>
          <option value="Barlow Condensed">Barlow Condensed</option>
          <option value="Oswald">Oswald</option>
          <option value="Montserrat">Montserrat</option>
          <option value="Playfair Display">Playfair Display</option>
          <option value="Raleway">Raleway</option>
          <option value="Roboto Condensed">Roboto Condensed</option>
          <option value="Inter">Inter</option>
        </select>
        <button id="cycleTFont">Cycle Font</button>
      </div>

      <div class="font-style-grid">
        <div class="style-group">
          <label>Outline</label>
          <div class="style-row">
            <button class="style-toggle" id="tOutline">OFF</button>
            <input type="range" class="style-slider" id="tOutlineWidth" min="1" max="10" value="2"/>
            <input type="number" class="mini-input" id="tOutlineWidthNum" min="1" max="10" value="2"/>
          </div>
          <div class="style-row"><input type="color" id="tOutlineColor" value="#fcfaf3"/></div>
        </div>
        <div class="style-group">
          <label>Shadow</label>
          <div class="style-row">
            <button class="style-toggle" id="tShadow">OFF</button>
            <input type="range" class="style-slider" id="tShadowBlur" min="0" max="20" value="0"/>
            <input type="number" class="mini-input" id="tShadowBlurNum" min="0" max="20" value="0"/>
          </div>
          <div class="style-row">
            <input type="range" class="style-slider" id="tShadowOffsetX" min="-20" max="20" value="2"/>
            <input type="range" class="style-slider" id="tShadowOffsetY" min="-20" max="20" value="2"/>
          </div>
          <div class="style-row">
            <input type="color" id="tShadowColor" value="#000000"/>
            <input type="range" class="style-slider" id="tShadowOpacity" min="0" max="1" step="0.1" value="0.5"/>
          </div>
        </div>
        <div class="style-group">
  <label>Highlighter</label>
  <div class="style-row">
    <button class="style-toggle" id="tHLToggle">OFF</button>
    <label class="row" style="gap:6px; align-items:center;">
      <input type="color" id="tHLColor" value="#fff200" style="max-width:70px">
      <input type="range" class="style-slider" id="tHLOpacity" min="0" max="1" step="0.05" value="0.6">
    </label>
  </div>
  <div class="style-row">
    <input type="range" class="style-slider" id="tHLPX" min="0" max="60" value="16" title="Pad X">
    <input type="range" class="style-slider" id="tHLPY" min="0" max="60" value="8"  title="Pad Y">
  </div>
  <div class="style-row">
    <input type="range" class="style-slider" id="tHLRadius" min="0" max="40" value="10" title="Radius">
    <label class="row" style="gap:6px;">
      <input type="checkbox" id="tHLPerLine" checked>
      <span style="font-size:10px;color:#9aa0a6;">Per-line</span>
    </label>
  </div>
</div>
      </div>
    </div>

    <div class="group">
      <label>Guides</label>
      <div class="row">
        <button id="safeToggle">Safe: On</button>
        <button id="ruleThirds">Rule of Thirds</button>
      </div>
    </div>

    <div class="group row">
      <button id="reset">Reset</button>
      <button id="export" class="primary">Export PNG (1080×1350)</button>
    </div>
  </aside>

  <!-- Stage -->
  <main class="stage-wrap">
    <div class="stage-bg">
      <div class="shell" id="shell">
        <div class="toolbar" data-export-exclude>
          <button id="selectHead" class="active">Move Headline</button>
          <button id="selectSub">Move Subtitle</button>
          <button id="editVox">Edit Voxels</button>
          <button id="editTree">Place Trees</button>
          <button id="addTextBtn">+ Add Text</button>
        </div>
        <div class="guides-hint" data-export-exclude>Drag via sliders • Pro: right-click voxel to carve</div>

        <div id="voxel" class="voxel-layer">

          <div class="viewport">
            <div class="grid-container" id="grid"></div>
          </div>
          <div class="controls" style="display:none"></div>
          <input type="file" id="importInput" accept="application/json" style="display:none"/>
        </div>

        <canvas id="art" width="1080" height="1350"></canvas>
        <div class="badge" data-export-exclude>4×5 • 1080×1350 px</div>
      </div>
    </div>
  </main>

  <div class="toast" id="toast"></div>

<script>
/* ====== Constants & Fonts ====== */
const ORANGE   = getComputedStyle(document.documentElement).getPropertyValue('--brand-orange').trim();
const OFFWHITE = getComputedStyle(document.documentElement).getPropertyValue('--off-white').trim();
const OFFBLACK = getComputedStyle(document.documentElement).getPropertyValue('--off-black').trim();

const FONTS = [
  { name:"Anton",             family:"Anton, sans-serif",                         weights:[400] },
  { name:"Barlow Condensed",  family:"'Barlow Condensed', sans-serif",            weights:[400,600,800] },
  { name:"Oswald",            family:"Oswald, sans-serif",                        weights:[400,600] },
  { name:"Montserrat",        family:"Montserrat, sans-serif",                    weights:[400,700,900] },
  { name:"Playfair Display",  family:"'Playfair Display', serif",                 weights:[700] },
  { name:"Raleway",           family:"Raleway, sans-serif",                       weights:[800] },
  { name:"Roboto Condensed",  family:"'Roboto Condensed', sans-serif",            weights:[700] },
  { name:"Inter",             family:"Inter, system-ui, sans-serif",              weights:[400,600,800] }
];

/* ====== Canvas ====== */
const canvas = document.getElementById('art');
const ctx = canvas.getContext('2d');
const W = canvas.width;  // 1080
const H = canvas.height; // 1350

/* ====== State ====== */
const state = {
  bg: OFFWHITE,
  padding: 90,
  grid: { on:true, centered:true, spacing:120, alpha:.25 },
  safeOn: true,
  thirds: false,
head: {
  id:'head', label:'Headline',
  text:'HELLO, IG!', size:120, color:OFFBLACK, align:'center', x:W/2, y:H*0.2,
  font:FONTS[0], weight:400,
  outline:false, outlineColor:OFFWHITE, outlineWidth:2,
  shadow:false, shadowOffsetX:4, shadowOffsetY:4, shadowBlur:0, shadowColor:'#000000', shadowOpacity:0.5,
  highlight:{ on:false, color:'#fff200', opacity:0.6, padX:16, padY:8, radius:10, perLine:true }
},
sub: {
  id:'sub', label:'Subtitle',
  text:'Clean, bold, fast.', size:48, color:OFFBLACK, align:'center', x:W/2, y:H*0.32,
  font:FONTS[1], weight:400,
  outline:false, outlineColor:OFFWHITE, outlineWidth:2,
  shadow:false, shadowOffsetX:2, shadowOffsetY:2, shadowBlur:0, shadowColor:'#000000', shadowOpacity:0.5,
  highlight:{ on:false, color:'#fff200', opacity:0.6, padX:16, padY:8, radius:10, perLine:true }
},
  texts: [],             // filled below
  activeTextId: 'head',  // which text is controlled by the panel
  voxel: { x:W/2, y:H*0.5, scale:1, edges:true, edgeW:3 },
  mode: 'text'           // 'text' | 'vox' | 'tree'
};
state.texts = [state.head, state.sub];

/* ====== UI Refs (declare BEFORE using) ====== */
const $ = (id)=>document.getElementById(id);

//highlighter
const tHLToggle  = $('tHLToggle');
const tHLColor   = $('tHLColor');
const tHLOpacity = $('tHLOpacity');
const tHLPX      = $('tHLPX');
const tHLPY      = $('tHLPY');
const tHLRadius  = $('tHLRadius');
const tHLPerLine = $('tHLPerLine');

/* toolbar */
const toolbar     = document.querySelector('.toolbar');
const selectHead  = $('selectHead');
const selectSub   = $('selectSub');
const editVox     = $('editVox');
const editTree    = $('editTree');
const addTextBtn  = $('addTextBtn');

/* generic text panel */
const textControls      = $('textControls');
const tWho              = $('tWho');
const tText             = $('tText');
const tAlign            = $('tAlign');
const tSize             = $('tSize');
const tFont             = $('tFont');
const cycleTFont        = $('cycleTFont');
const tOutline          = $('tOutline');
const tOutlineWidth     = $('tOutlineWidth');
const tOutlineWidthNum  = $('tOutlineWidthNum');
const tOutlineColor     = $('tOutlineColor');
const tShadow           = $('tShadow');
const tShadowBlur       = $('tShadowBlur');
const tShadowBlurNum    = $('tShadowBlurNum');
const tShadowOffsetX    = $('tShadowOffsetX');
const tShadowOffsetY    = $('tShadowOffsetY');
const tShadowColor      = $('tShadowColor');
const tShadowOpacity    = $('tShadowOpacity');

/* other controls */
const bgColor=$('bgColor'), padding=$('padding'), gridToggle=$('gridToggle'), centerToggle=$('centerToggle'), gridSpacing=$('gridSpacing'), gridAlpha=$('gridAlpha');
const safeToggle=$('safeToggle'), ruleThirds=$('ruleThirds'), reset=$('reset'), exportBtn=$('export');
const edgeColor=$('edgeColor'), groundColor=$('groundColor'), groundInnerColor=$('groundInnerColor');
const edgeW=$('edgeW'), vxScale=$('vxScale'), vxX=$('vxX'), vxY=$('vxY'), snapCenter=$('snapCenter'), edgesToggle=$('edgesToggle');
const colsInput=$('colsInput'), rowsInput=$('rowsInput'), resizeGridBtn=$('resizeGridBtn'), levelBtn=$('levelBtn'), drawAllBtn=$('drawAllBtn'), deleteBtn=$('deleteBtn'), ideasBtn=$('ideasBtn'), proModeBtn=$('proModeBtn');

/* tree controls */
const treeControls   = $('treeControls');
const treeTrunkMin   = $('treeTrunkMin');
const treeTrunkMax   = $('treeTrunkMax');
const treeDiaMin     = $('treeDiaMin');
const treeDiaMax     = $('treeDiaMax');
const treeColor      = $('treeColor');
const rerollTreesBtn = $('rerollTreesBtn');
const deleteTreesBtn = $('deleteTreesBtn');

/* voxel DOM */
const grid = $('grid'), areaInfo=$('areaInfo'), priceInfo=$('priceInfo');

/* ====== Toast ====== */
function showToast(message){
  const toast = document.getElementById('toast');
  toast.textContent = message;
  toast.classList.add('show');
  setTimeout(()=>toast.classList.remove('show'), 1600);
}

//highlight
function roundRect(ctx, x, y, w, h, r){
  const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
  ctx.beginPath();
  ctx.moveTo(x + rr, y);
  ctx.arcTo(x + w, y,     x + w, y + h, rr);
  ctx.arcTo(x + w, y + h, x,     y + h, rr);
  ctx.arcTo(x,     y + h, x,     y,     rr);
  ctx.arcTo(x,     y,     x + w, y,     rr);
  ctx.closePath();
}


/* ====== Drawing ====== */
function clear(){ ctx.clearRect(0,0,W,H); }
function drawBackground(){ ctx.fillStyle = state.bg; ctx.fillRect(0,0,W,H); }
function setAlign(a){ ctx.textAlign = (a==='left'?'left':a==='right'?'right':'center'); }

function wrapLines(text, maxWidth, ctx){
  const paragraphs = String(text ?? '').split('\n');
  const out = [];
  for (const p of paragraphs){
    const words = p.split(/\s+/);
    let line = '';
    for (const w of words){
      const test = line ? line + ' ' + w : w;
      const width = ctx.measureText(test).width;
      if (width <= maxWidth){
        line = test;
      } else {
        if (line) out.push(line);
        if (ctx.measureText(w).width > maxWidth){
          let chunk = '';
          for (const ch of w){
            const t2 = chunk + ch;
            if (ctx.measureText(t2).width <= maxWidth) chunk = t2;
            else { out.push(chunk); chunk = ch; }
          }
          line = chunk;
        } else {
          line = w;
        }
      }
    }
    out.push(line);
  }
  return out;
}

function hexToRgba(hex,a){
  const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${a})`;
}

function drawText(obj){
  const {
    text, size, color, align, x, y, font, weight,
    outline, outlineColor, outlineWidth,
    shadow, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, shadowOpacity
  } = obj;

  ctx.save();
  ctx.textBaseline = 'alphabetic';
  ctx.font = `${weight} ${size}px ${font.family}`;
  setAlign(align);

  const maxWidth = W - 2 * state.padding;
  const lines = wrapLines(text, maxWidth, ctx);
  const lineHeight = Math.round(size * 1.15);
  const totalH = lineHeight * lines.length;
  let startY = y - (totalH - lineHeight) / 2;

// === Highlighter (behind text) ===
if (obj.highlight?.on) {
  const { color:hlc, opacity:hop, padX, padY, radius, perLine } = obj.highlight;

  const metrics = lines.map(str => {
    const m = ctx.measureText(str);
    const asc = m.actualBoundingBoxAscent ?? size * 0.8;
    const des = m.actualBoundingBoxDescent ?? size * 0.2;
    return { width: m.width, asc, des };
  });

  const rects = [];
  if (perLine) {
    for (let i = 0; i < lines.length; i++) {
      const { width, asc, des } = metrics[i];
      const ly  = startY + i * lineHeight; // baseline
      const top = ly - asc - padY;
      const h   = asc + des + padY * 2;
      let left;
      if (align === 'center') left = x - width/2 - padX;
      else if (align === 'right') left = x - width - padX;
      else left = x - padX;
      rects.push({ x:left, y:top, w:width + padX*2, h });
    }
  } else {
    const maxW = Math.max(...metrics.map(m => m.width));
    const asc0 = metrics[0]?.asc ?? size*0.8;
    const desL = metrics.at(-1)?.des ?? size*0.2;
    const top  = startY - asc0 - padY;
    const h    = (lineHeight * (lines.length - 1)) + (asc0 + desL) + padY * 2;
    let left;
    if (align === 'center') left = x - maxW/2 - padX;
    else if (align === 'right') left = x - maxW - padX;
    else left = x - padX;
    rects.push({ x:left, y:top, w:maxW + padX*2, h });
  }

  ctx.save();
  ctx.fillStyle = hexToRgba(hlc, hop);
  for (const r of rects) { roundRect(ctx, r.x, r.y, r.w, r.h, radius); ctx.fill(); }
  ctx.restore();
}
// === end Highlighter ===

  for (let i = 0; i < lines.length; i++) {
    const ly = startY + i * lineHeight;

    if (shadow) {
      ctx.save();
      ctx.shadowOffsetX = shadowOffsetX;
      ctx.shadowOffsetY = shadowOffsetY;
      ctx.shadowBlur = shadowBlur;
      ctx.shadowColor = hexToRgba(shadowColor, shadowOpacity);
      ctx.fillStyle = color;
      ctx.fillText(lines[i], x, ly);
      ctx.restore();
    }

    if (outline) {
      ctx.save();
      ctx.strokeStyle = outlineColor;
      ctx.lineWidth = outlineWidth;
      ctx.lineJoin = 'round';
      ctx.strokeText(lines[i], x, ly);
      ctx.restore();
    }

    ctx.fillStyle = color;
    ctx.fillText(lines[i], x, ly);
  }

  ctx.restore();
}

function drawGuides(){
  const pad = state.padding;
  if(state.safeOn){
    ctx.save(); ctx.strokeStyle = state.bg===OFFBLACK?'rgba(255,255,255,.22)':'rgba(0,0,0,.25)'; ctx.lineWidth=2; ctx.setLineDash([6,8]);
    ctx.strokeRect(pad,pad,W-2*pad,H-2*pad); ctx.restore();
  }
  if(state.thirds){
    ctx.save(); ctx.strokeStyle = state.bg===OFFBLACK?'rgba(255,255,255,.18)':'rgba(0,0,0,.18)'; ctx.lineWidth=1; ctx.setLineDash([4,8]);
    const v1=W/3,v2=2*W/3,h1=H/3,h2=2*H/3;
    ctx.beginPath();
    [v1,v2].forEach(x=>{ctx.moveTo(x,0);ctx.lineTo(x,H);});
    [h1,h2].forEach(y=>{ctx.moveTo(0,y);ctx.lineTo(W,y);});
    ctx.stroke(); ctx.restore();
  }
  if(state.grid.on){
    const s=state.grid.spacing, a=state.grid.alpha, cx=W/2, cy=H/2;
    ctx.save(); ctx.strokeStyle=`rgba(255,132,0,${a})`; ctx.lineWidth=1; ctx.beginPath();
    if(state.grid.centered){
      for(let x=cx; x<=W; x+=s){ctx.moveTo(x,0);ctx.lineTo(x,H)} for(let x=cx; x>=0; x-=s){ctx.moveTo(x,0);ctx.lineTo(x,H)}
      for(let y=cy; y<=H; y+=s){ctx.moveTo(0,y);ctx.lineTo(W,y)} for(let y=cy; y>=0; y-=s){ctx.moveTo(0,y);ctx.lineTo(W,y)}
    }else{
      for(let x=state.padding; x<=W; x+=s){ctx.moveTo(x,state.padding);ctx.lineTo(x,H-state.padding)}
      for(let y=state.padding; y<=H; y+=s){ctx.moveTo(state.padding,y);ctx.lineTo(W-state.padding,y)}
    }
    ctx.stroke(); ctx.restore();
  }
}

function render(){
  clear();
  drawBackground();
  drawGuides();
  state.texts.forEach(t => drawText(t));
}

/* ====== Text management (Add Text) ====== */
let textSeq = 3; // head=1 sub=2 in spirit, next is 3
const textButtons = { head: selectHead, sub: selectSub };

function getActiveText(){
  return state.texts.find(t => t.id === state.activeTextId) || state.texts[0];
}

function makeDefaultText(label){
  return {
    id:`text${textSeq}`, label,
    text: label,
    size: 48,
    color: OFFBLACK,
    align: 'center',
    x: W/2, y: H*0.6,
    font: FONTS[1], weight: 400,
    outline: false, outlineColor: OFFWHITE, outlineWidth: 2,
    shadow: false, shadowOffsetX: 2, shadowOffsetY: 2, shadowBlur: 0, shadowColor: '#000000', shadowOpacity: 0.5,
    highlight: { on:false, color:'#fff200', opacity:0.6, padX:16, padY:8, radius:10, perLine:true }
  };
}

function addMoveButton(t){
  const btn = document.createElement('button');
  btn.textContent = `Move ${t.label}`;
  btn.addEventListener('click', ()=>{ setActiveById(t.id); setMode('text'); });
  toolbar.insertBefore(btn, addTextBtn);
  textButtons[t.id] = btn;
}

function rebuildTextButtons(){
  // remove dynamic ones (keep head/sub/add)
  Object.keys(textButtons).forEach(k=>{
    if (k!=='head' && k!=='sub'){
      textButtons[k].remove();
      delete textButtons[k];
    }
  });
  state.texts.forEach(t=>{
    if (t.id!=='head' && t.id!=='sub') addMoveButton(t);
  });
  updateTextButtonsActive();
}

addTextBtn.addEventListener('click', () => {
  const { id, label } = nextTextIdLabel();
  // build a default text object with that id/label
  const t = {
    ...makeDefaultText(label),
    id,
    label
  };
  state.texts.push(t);
  addMoveButton(t);
  setActiveById(t.id);
  setMode('text');
});


function setActiveById(id){
  if (!state.texts.some(t => t.id === id)) return;
  state.activeTextId = id;
  syncPanelToActive();
  updateTextButtonsActive();
  render();
}

function syncPanelToActive(){
  const t = getActiveText();
  if (!t) return;
  tWho.textContent = `(${t.label || t.id})`;
  tText.value = t.text || '';
  tAlign.value = t.align || 'center';
  tSize.value = t.size || 80;
  tFont.value = t.font?.name || FONTS[0].name;

  // outline
  tOutline.textContent = t.outline ? 'ON' : 'OFF';
  tOutline.classList.toggle('active', !!t.outline);
  tOutlineWidth.value = t.outlineWidth ?? 2;
  tOutlineWidthNum.value = t.outlineWidth ?? 2;
  tOutlineColor.value = t.outlineColor || OFFWHITE;

  // shadow
  tShadow.textContent = t.shadow ? 'ON' : 'OFF';
  tShadow.classList.toggle('active', !!t.shadow);
  tShadowBlur.value = t.shadowBlur ?? 0;
  tShadowBlurNum.value = t.shadowBlur ?? 0;
  tShadowOffsetX.value = t.shadowOffsetX ?? 2;
  tShadowOffsetY.value = t.shadowOffsetY ?? 2;
  tShadowColor.value = t.shadowColor || '#000000';
  tShadowOpacity.value = t.shadowOpacity ?? 0.5;

  //highlighter
  tHLToggle.textContent = t.highlight?.on ? 'ON' : 'OFF';
tHLToggle.classList.toggle('active', !!t.highlight?.on);
tHLColor.value   = t.highlight?.color   ?? '#fff200';
tHLOpacity.value = t.highlight?.opacity ?? 0.6;
tHLPX.value      = t.highlight?.padX    ?? 16;
tHLPY.value      = t.highlight?.padY    ?? 8;
tHLRadius.value  = t.highlight?.radius  ?? 10;
tHLPerLine.checked = t.highlight?.perLine ?? true;
}

function updateTextFromPanel(){
  const t = getActiveText();
  if (!t) return;

  t.text = tText.value;
  t.align = tAlign.value;
  t.size = +tSize.value;
  const f = FONTS.find(x => x.name === tFont.value);
  if (f) t.font = f;

  t.outline = tOutline.textContent === 'ON';
  t.outlineWidth = +tOutlineWidth.value;
  t.outlineColor = tOutlineColor.value;

  t.shadow = tShadow.textContent === 'ON';
  t.shadowBlur = +tShadowBlur.value;
  t.shadowOffsetX = +tShadowOffsetX.value;
  t.shadowOffsetY = +tShadowOffsetY.value;
  t.shadowColor = tShadowColor.value;
  t.shadowOpacity = +tShadowOpacity.value;

t.highlight = t.highlight || {};
t.highlight.on      = (tHLToggle.textContent === 'ON');
t.highlight.color   = tHLColor.value;
t.highlight.opacity = +tHLOpacity.value;
t.highlight.padX    = +tHLPX.value;
t.highlight.padY    = +tHLPY.value;
t.highlight.radius  = +tHLRadius.value;
t.highlight.perLine = !!tHLPerLine.checked;



  render();
}

/* Bind generic text panel */
tText.addEventListener('input', updateTextFromPanel);
tAlign.addEventListener('change', ()=>{
  const t = getActiveText(); if (!t) return;
  t.align = tAlign.value;
  t.x = t.align==='center' ? W/2 : (t.align==='left' ? state.padding : (W - state.padding));
  updateTextFromPanel();
});
tSize.addEventListener('input', updateTextFromPanel);
tFont.addEventListener('change', updateTextFromPanel);
cycleTFont.addEventListener('click', ()=>{
  const t = getActiveText(); if (!t) return;
  const i = FONTS.findIndex(f=>f.name === (t.font?.name || ''));
  const n = (i>=0 ? i+1 : 0) % FONTS.length;
  t.font = FONTS[n]; tFont.value = t.font.name;
  showToast(`Font: ${t.font.name}`); render();
});

// quick text color buttons
document.querySelectorAll('[data-tcolor]').forEach(dot=>{
  dot.addEventListener('click', ()=>{
    const t = getActiveText(); if (!t) return;

    // Remove .active from all in the row
    dot.parentNode.querySelectorAll('.dot').forEach(d=>d.classList.remove('active'));
    dot.classList.add('active');

    const key = dot.getAttribute('data-tcolor');
    t.color =
      key==='orange'   ? ORANGE   :
      key==='offwhite' ? OFFWHITE :
      key==='offblack' ? OFFBLACK :
      key==='teal'     ? '#00D1B2':
      key==='gray'     ? '#525252':
      OFFBLACK;

    render();
  });
});

// outline
tOutline.addEventListener('click', ()=>{
  const t = getActiveText(); if (!t) return;
  t.outline = !t.outline; tOutline.classList.toggle('active', t.outline);
  tOutline.textContent = t.outline ? 'ON' : 'OFF';
  render();
});
tOutlineWidth.addEventListener('input', e=>{ tOutlineWidthNum.value = e.target.value; updateTextFromPanel(); });
tOutlineWidthNum.addEventListener('input', e=>{ tOutlineWidth.value = e.target.value; updateTextFromPanel(); });
tOutlineColor.addEventListener('input', updateTextFromPanel);

// shadow
tShadow.addEventListener('click', ()=>{
  const t = getActiveText(); if (!t) return;
  t.shadow = !t.shadow; tShadow.classList.toggle('active', t.shadow);
  tShadow.textContent = t.shadow ? 'ON' : 'OFF';
  render();
});
tShadowBlur.addEventListener('input', e=>{ tShadowBlurNum.value = e.target.value; updateTextFromPanel(); });
tShadowBlurNum.addEventListener('input', e=>{ tShadowBlur.value = e.target.value; updateTextFromPanel(); });
tShadowOffsetX.addEventListener('input', updateTextFromPanel);
tShadowOffsetY.addEventListener('input', updateTextFromPanel);
tShadowColor.addEventListener('input', updateTextFromPanel);
tShadowOpacity.addEventListener('input', updateTextFromPanel);

//highlighter
tHLToggle.addEventListener('click', () => {
  const t = getActiveText(); if (!t) return;
  t.highlight = t.highlight || {};
  t.highlight.on = !t.highlight.on;
  tHLToggle.textContent = t.highlight.on ? 'ON' : 'OFF';
  tHLToggle.classList.toggle('active', t.highlight.on);
  render();
});
[tHLColor, tHLOpacity, tHLPX, tHLPY, tHLRadius].forEach(el => el.addEventListener('input', updateTextFromPanel));
tHLPerLine.addEventListener('change', updateTextFromPanel);


/* ====== BG & Guides ====== */
function clamp(n,min,max){return Math.max(min, Math.min(max, n))}

function rgbToHex(rgb){
  if(rgb.startsWith('#')) return rgb;
  const v=rgb.match(/(\d+),\s*(\d+),\s*(\d+)/);
  if(!v) return '#ffffff';
  const [r,g,b]=[+v[1],+v[2],+v[3]];
  return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
}

bgColor.addEventListener('input', e=>{ state.bg=e.target.value; render(); });
padding.addEventListener('input', e=>{ state.padding=clamp(+e.target.value,0,200); render(); });
gridToggle.addEventListener('click', ()=>{ state.grid.on=!state.grid.on; gridToggle.textContent=`Grid: ${state.grid.on?'On':'Off'}`; render(); });
centerToggle.addEventListener('click', ()=>{ state.grid.centered=!state.grid.centered; centerToggle.textContent=`Centered: ${state.grid.centered?'On':'Off'}`; render(); });
gridSpacing.addEventListener('input', e=>{ state.grid.spacing=+e.target.value; render(); });
gridAlpha.addEventListener('input', e=>{ state.grid.alpha=+e.target.value; render(); });
safeToggle.addEventListener('click', ()=>{ state.safeOn=!state.safeOn; safeToggle.textContent=`Safe: ${state.safeOn?'On':'Off'}`; render(); });
ruleThirds.addEventListener('click', ()=>{ state.thirds=!state.thirds; ruleThirds.classList.toggle('primary', state.thirds); render(); });

/* ====== Mode switching & dragging ====== */
const modeButtons = { vox: editVox, tree: editTree };
let lastTextId = 'head';

function setHitboxesForMode(){
  const layer = document.querySelector('.voxel-layer');
  const realHB  = layer.querySelectorAll('.hitbox:not(.ghost)');
  const ghostHB = layer.querySelectorAll('.hitbox.ghost');

  if (state.mode === 'tree'){
    layer.style.pointerEvents = 'auto';
    realHB.forEach(h => h.style.pointerEvents = 'auto');
    ghostHB.forEach(h => h.style.pointerEvents = 'auto');
  } else if (state.mode === 'vox'){
    layer.style.pointerEvents = 'auto';
    realHB.forEach(h => h.style.pointerEvents = 'auto');
    ghostHB.forEach(h => h.style.pointerEvents = 'none');
  } else {
    layer.style.pointerEvents = 'none';
    realHB.forEach(h => h.style.pointerEvents = 'none');
    ghostHB.forEach(h => h.style.pointerEvents = 'none');
  }
}

function setMode(mode){
  state.mode = mode; // 'text' | 'vox' | 'tree'
treeControls.style.display = (mode === 'tree') ? '' : 'none';
  // button states
  Object.values(modeButtons).forEach(b => b.classList.remove('active'));
  Object.values(textButtons).forEach(b => b.classList.remove('active'));

  if (mode === 'text'){
    const b = textButtons[state.activeTextId];
    if (b) b.classList.add('active');
  } else {
    modeButtons[mode]?.classList.add('active');
  }

  setHitboxesForMode();

  // show/hide text panel
  textControls.style.display = (mode === 'text') ? '' : 'none';

  if (mode === 'text') lastTextId = state.activeTextId;
}

function updateTextButtonsActive(){
  Object.values(textButtons).forEach(b => b.classList.remove('active'));
  if (state.mode === 'text'){
    const b = textButtons[state.activeTextId];
    if (b) b.classList.add('active');
  }
}

selectHead.addEventListener('click', ()=>{ setActiveById('head'); setMode('text'); });
selectSub .addEventListener('click', ()=>{ setActiveById('sub');  setMode('text'); });
editVox  .addEventListener('click', ()=>{ setMode(state.mode==='vox' ? 'text' : 'vox'); if(state.mode==='text') setActiveById(lastTextId); });
editTree .addEventListener('click', ()=>{ setMode(state.mode==='tree' ? 'text' : 'tree'); if(state.mode==='text') setActiveById(lastTextId); });

/* dragging on canvas for active text */
function pointer(e){
  const r=canvas.getBoundingClientRect();
  return { x:(e.clientX-r.left)*(W/r.width), y:(e.clientY-r.top)*(H/r.height) };
}
let dragging=false, dx=0, dy=0;
canvas.addEventListener('mousedown',(e)=>{
  if(state.mode!=='text') return;
  dragging = true;
  const pt = pointer(e);
  const t = getActiveText();
  dx = pt.x - t.x;
  dy = pt.y - t.y;
});
window.addEventListener('mousemove',(e)=>{
  if(state.mode!=='text' || !dragging) return;
  const pt = pointer(e);
  const t = getActiveText();
  t.x = pt.x - dx;
  t.y = pt.y - dy;
  render();
});
window.addEventListener('mouseup',()=> dragging=false);

// right-click cycles alignment for active text
canvas.addEventListener('contextmenu',(e)=>{
  e.preventDefault();
  if(state.mode!=='text') return;
  const t = getActiveText();
  const a = ['left','center','right'];
  const next = a[(a.indexOf(t.align)+1)%a.length];
  t.align = next;
  t.x = next==='center' ? W/2 : (next==='left' ? state.padding : (W - state.padding));
  tAlign.value = next;
  showToast(`Alignment: ${next}`);
  render();
});

/* ====== Voxel grid & trees ====== */
let cols=8, rows=20, baseLeft=0, currentLevel=1, proMode=false, lastState=[], currentIdeaIndex=-1;
const offsetX=50, offsetY=25, baseTop=120, voxelArea=160/18, pricePerM2=20000;
const voxels=[], faces=[];

/* Trees */
const trees = new Map();
const TREE_RNG = { minDia:28, maxDia:82, minTrunk:18, maxTrunk:60 };
const TREE_PAD = 20;
const tKey = (x,y)=>`${x},${y}`;
function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }
function tileBox(x, y){ return { left:(x-y)*offsetX + baseLeft, top:(x+y)*offsetY + baseTop }; }

function clampNum(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
function ensureMinMax(minEl, maxEl){
  let a = +minEl.value, b = +maxEl.value;
  if (a > b) { [a,b] = [b,a]; minEl.value = a; maxEl.value = b; }
  return [a,b];
}
function updateTreeRngFromInputs(){
  const [tmin, tmax] = ensureMinMax(treeTrunkMin, treeTrunkMax);
  const [dmin, dmax] = ensureMinMax(treeDiaMin, treeDiaMax);
  TREE_RNG.minTrunk = clampNum(tmin, 0, 1000);
  TREE_RNG.maxTrunk = clampNum(tmax, 0, 1000);
  TREE_RNG.minDia   = clampNum(dmin, 0, 1000);
  TREE_RNG.maxDia   = clampNum(dmax, 0, 1000);
}
function updateDeleteTreesAvailability() {
  deleteTreesBtn.disabled = (trees.size === 0);
}

function placeTreeAt(x,y, trunkHOverride=null, diaOverride=null){
  const key = tKey(x, y);
  if (trees.has(key)) return;
  const box = tileBox(x, y);
  const trunkH = trunkHOverride ?? randInt(TREE_RNG.minTrunk, TREE_RNG.maxTrunk);
  const dia    = diaOverride ?? randInt(TREE_RNG.minDia,    TREE_RNG.maxDia);

  const wrap = document.createElement('div');
  wrap.className = 'tree';
  wrap.style.width  = dia + 'px';
  wrap.style.height = (trunkH + dia) + 'px';
  wrap.style.left = (box.left + 50 - dia/2) + 'px';
  wrap.style.top  = (box.top  + 50 - trunkH - dia) + 'px';
  wrap.style.zIndex = 5000 + (x + y);

  const trunk = document.createElement('div');
  trunk.className = 'trunk';
  trunk.style.height = trunkH + 'px';

  const canopy = document.createElement('div');
  canopy.className = 'canopy';
  canopy.style.width  = dia + 'px';
  canopy.style.height = dia + 'px';
  canopy.style.left   = '0px';
  canopy.style.bottom = trunkH + 'px';

  wrap.appendChild(trunk);
  wrap.appendChild(canopy);
  grid.appendChild(wrap);
  trees.set(key, wrap);
    updateDeleteTreesAvailability();
}
function regenerateTreeAt(x,y){ removeTreeAt(x,y); placeTreeAt(x,y); }
function removeTreeAt(x,y){
  const el = trees.get(tKey(x,y)); if (!el) return;
  el.remove(); trees.delete(tKey(x,y));
  updateDeleteTreesAvailability();
}

function clearAllTrees(){
  for (const el of trees.values()) el.remove();
  trees.clear();
  updateDeleteTreesAvailability();
}

function createFace(x,y,z,type){
  const face=document.createElement('div'); face.className=`face ${type}`;
  face.style.left=`${(x-y)*offsetX + baseLeft}px`;
  face.style.top =`${(x+y)*offsetY + baseTop - z*50}px`;
  face.style.zIndex=`${(x+y)*100 + z*10 + (type==='top'?2:1)}`;
  const inner=document.createElement('div'); inner.className='inner'; face.appendChild(inner);
  const edge=document.createElement('div'); edge.className=`edge-${type}`; face.appendChild(edge);
  grid.appendChild(face); faces.push(face);
}
function createBottom(x,y){
  const face=document.createElement('div'); face.className='face bottom';
  face.style.left=`${(x-y)*offsetX + baseLeft}px`; face.style.top=`${(x+y)*offsetY + baseTop}px`; face.style.zIndex='0';
  const inner=document.createElement('div'); inner.className='inner'; face.appendChild(inner);
  grid.appendChild(face);
}
function createBottom2(x,y){
  const face=document.createElement('div'); face.className='face bottom2';
  face.style.left=`${(x-y)*offsetX + baseLeft}px`; face.style.top=`${(x+y)*offsetY + baseTop}px`; face.style.zIndex='2';
  const inner=document.createElement('div'); inner.className='inner'; face.appendChild(inner);
  const edge=document.createElement('div'); edge.className='edge-bottom2'; face.appendChild(edge);
  grid.appendChild(face); faces.push(face);
}
function clearFaces(){ for(const f of faces) grid.removeChild(f); faces.length=0; }
function buildVoxel(){
  clearFaces();
  for(const v of voxels){
    if(!v.active) continue;
    if(v.level===0){ createBottom2(v.x,v.y); }
    else{
      for(let i=v.base;i<v.base+v.level;i++){ createFace(v.x,v.y,i,'left'); createFace(v.x,v.y,i,'right'); }
      createFace(v.x,v.y,v.base+v.level-1,'top');
    }
  }
}
function updateStats(){
  let totalVoxels = voxels.reduce((acc,v)=>acc+v.level,0);
  const totalArea = Math.round(totalVoxels*voxelArea);
  const totalPrice = Math.round((totalArea*pricePerM2)/1000)*1000;
  if(areaInfo) areaInfo.textContent=`Construction size: ${totalArea} m²`;
  if(priceInfo) priceInfo.textContent=`Estimated price: $${totalPrice.toLocaleString()}`;
}

function cycleLevel(){ currentLevel=(currentLevel+1)%10; levelBtn.textContent=`Level: ${currentLevel}`;
  voxels.forEach(v=>{ if(v.active){ v.level=currentLevel; v.base=0; }}); buildVoxel(); updateStats(); }

function handleDelete(){
  if(deleteBtn.textContent==='Undo'){
    lastState.forEach(({level,base},i)=>{ voxels[i].level=level; voxels[i].base=base; voxels[i].active=level>0; });
    deleteBtn.textContent='Delete All';
  }else{
    lastState=voxels.map(v=>({level:v.level, base:v.base}));
    voxels.forEach(v=>{ v.active=false; v.level=0; v.base=0; });
    ideasBtn.textContent='Design Ideas'; deleteBtn.textContent='Undo';
  }
  buildVoxel(); updateStats();
}
function drawAll(){ voxels.forEach(v=>{ v.level=currentLevel; v.base=0; v.active=true; }); buildVoxel(); updateStats();
  if(deleteBtn.textContent==='Undo') deleteBtn.textContent='Delete All'; ideasBtn.textContent='Design Ideas'; }

function exportGrid(){
  const data=voxels.filter(v=>v.active).map(v=>({x:v.x,y:v.y,level:v.level}));
  const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
  const link=document.createElement('a'); link.href=URL.createObjectURL(blob); link.download='voxel-grid.json'; link.click();
}
function importGrid(data){
  voxels.forEach(v=>{ const m=data.find(d=>d.x===v.x && d.y===v.y);
    if(m){ v.level=m.level; v.base=0; v.active=true; } else { v.level=0; v.base=0; v.active=false; }});
  buildVoxel(); updateStats();
}

function buildGhostHitboxes(){
  grid.querySelectorAll('.hitbox.ghost').forEach(n => n.remove());
  for (let gy = -TREE_PAD; gy < rows + TREE_PAD; gy++){
    for (let gx = -TREE_PAD; gx < cols + TREE_PAD; gx++){
      if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) continue;
      const hb = document.createElement('div');
      hb.className = 'hitbox ghost';
      hb.style.left = `${(gx - gy) * offsetX + baseLeft}px`;
      hb.style.top  = `${(gx + gy) * offsetY + baseTop}px`;
      hb.addEventListener('click', () => {
        if (state.mode !== 'tree') return;
        const key = tKey(gx, gy);
        if (trees.has(key)) regenerateTreeAt(gx, gy); else placeTreeAt(gx, gy);
      });
      hb.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        if (state.mode !== 'tree') return;
        removeTreeAt(gx, gy);
      });
      grid.appendChild(hb);
    }
  }
}

function initGrid(){
  clearFaces(); voxels.length=0; grid.innerHTML=''; baseLeft=grid.offsetWidth/1.8;
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const voxelData={x,y,level:0,base:0,active:false}; voxels.push(voxelData);
      const hitbox=document.createElement('div'); hitbox.className='hitbox';
      hitbox.style.left=`${(x-y)*offsetX + baseLeft}px`;
      hitbox.style.top =`${(x+y)*offsetY + baseTop}px`;

      hitbox.addEventListener('click', ()=>{
        if (state.mode === 'vox'){
          if(deleteBtn.textContent==='Undo') deleteBtn.textContent='Delete All';
          ideasBtn.textContent='Design Ideas';
          if(proMode){
            if(voxelData.level===0 && voxelData.base===9){ voxelData.level=1; voxelData.base=0; voxelData.active=true; }
            else if(voxelData.base>0){ voxelData.base-=1; voxelData.level+=1; voxelData.active=true; }
            else if(voxelData.level + voxelData.base < 9){ voxelData.level+=1; voxelData.active=true; }
            else { voxelData.level=0; voxelData.base=0; voxelData.active=false; }
          } else {
            voxelData.active=!voxelData.active; voxelData.level=voxelData.active?currentLevel:0; voxelData.base=0;
          }
          buildVoxel(); updateStats();
        } else if (state.mode === 'tree'){
          const key = tKey(x, y);
          if (trees.has(key)) regenerateTreeAt(x, y); else placeTreeAt(x, y);
        }
      });

      hitbox.addEventListener('contextmenu',(e)=>{
        e.preventDefault();
        if (state.mode === 'vox'){
          if(!proMode) return;
          if(deleteBtn.textContent==='Undo') deleteBtn.textContent='Delete All';
          ideasBtn.textContent='Design Ideas';
          if(voxelData.level>0){
            voxelData.level-=1; voxelData.base+=1; voxelData.active=voxelData.level>0; buildVoxel(); updateStats();
          }
        } else if (state.mode === 'tree'){
          removeTreeAt(x, y);
        }
      });

      grid.appendChild(hitbox);
      createBottom(x,y);
    }
  }
  buildVoxel(); updateStats(); buildGhostHitboxes(); setHitboxesForMode();
}

/* ====== Sidebar hooks ====== */
levelBtn.addEventListener('click',cycleLevel);
deleteBtn.addEventListener('click',handleDelete);
drawAllBtn.addEventListener('click',drawAll);

const designIdeas=[
  { name:'Bridge House', data:[{"x":0,"y":0,"level":2},{"x":1,"y":0,"level":2},{"x":2,"y":0,"level":2},{"x":0,"y":1,"level":2},{"x":1,"y":1,"level":2},{"x":2,"y":1,"level":2},{"x":0,"y":2,"level":1},{"x":0,"y":3,"level":1},{"x":0,"y":4,"level":2},{"x":1,"y":4,"level":2},{"x":2,"y":4,"level":2},{"x":0,"y":5,"level":2},{"x":1,"y":5,"level":2},{"x":2,"y":5,"level":2}]},
  { name:'Hacienda Style', data:[{"x":0,"y":0,"level":2},{"x":1,"y":0,"level":2},{"x":2,"y":0,"level":2},{"x":0,"y":1,"level":2},{"x":1,"y":1,"level":2},{"x":2,"y":1,"level":2},{"x":1,"y":2,"level":2},{"x":1,"y":3,"level":2},{"x":0,"y":4,"level":3},{"x":1,"y":4,"level":3},{"x":2,"y":4,"level":1},{"x":0,"y":5,"level":3},{"x":1,"y":5,"level":3},{"x":2,"y":5,"level":1}]},
  { name:'Stairways', data:[{"x":0,"y":1,"level":2},{"x":1,"y":1,"level":2},{"x":2,"y":1,"level":2},{"x":0,"y":2,"level":2},{"x":2,"y":2,"level":2},{"x":0,"y":3,"level":2},{"x":2,"y":3,"level":2},{"x":0,"y":4,"level":2},{"x":1,"y":4,"level":2},{"x":2,"y":4,"level":2},{"x":0,"y":5,"level":1},{"x":1,"y":5,"level":1},{"x":2,"y":5,"level":1}]}
];
ideasBtn.addEventListener('click',()=>{
  currentIdeaIndex=(currentIdeaIndex+1)%designIdeas.length; const idea=designIdeas[currentIdeaIndex];
  voxels.forEach(v=>{ v.active=false; v.level=0; v.base=0; });
  idea.data.forEach(({x,y,level})=>{ const idx=y*cols+x; if(voxels[idx]){ voxels[idx].level=level; voxels[idx].base=0; voxels[idx].active=true; }});
  ideasBtn.textContent=idea.name; deleteBtn.textContent='Delete All'; buildVoxel(); updateStats();
});

proModeBtn.addEventListener('click',()=>{
  proMode=!proMode; proModeBtn.textContent=proMode?'Simple Mode':'🔒 Pro Mode'; levelBtn.disabled=proMode;
  const existingExportBtn=document.getElementById('exportBtn');
  const existingImportBtn=document.getElementById('importBtn');
  const controlsContainer=document.querySelector('.panel .group');
  if(proMode){
    if(!existingExportBtn){ const b=document.createElement('button'); b.id='exportBtn'; b.textContent='Export JSON'; b.onclick=exportGrid; controlsContainer.appendChild(b); }
    if(!existingImportBtn){ const b=document.createElement('button'); b.id='importBtn'; b.textContent='Import JSON'; b.onclick=()=>document.getElementById('importInput').click(); controlsContainer.appendChild(b); }
  }else{
    if(existingExportBtn) existingExportBtn.remove();
    if(existingImportBtn) existingImportBtn.remove();
  }
});

resizeGridBtn.addEventListener('click',()=>{
  const newRows=parseInt(rowsInput.value), newCols=parseInt(colsInput.value);
  if(isNaN(newRows)||isNaN(newCols)||newRows<1||newCols<1){ alert('Invalid grid size.'); return; }
  rows=newRows; cols=newCols; initGrid(); clearAllTrees();
});

[treeTrunkMin, treeTrunkMax, treeDiaMin, treeDiaMax].forEach(el=>{
  el.addEventListener('input', updateTreeRngFromInputs);
});

treeColor.addEventListener('input', (e)=>{
  document.documentElement.style.setProperty('--tree-fill', e.target.value);
  trees.forEach(el=>{
    el.querySelector('.trunk').style.background = e.target.value;
    el.querySelector('.canopy').style.background = e.target.value;
  });
});

rerollTreesBtn.addEventListener('click', ()=>{
  const coords = Array.from(trees.keys()).map(k => {
    const [x,y] = k.split(',').map(Number); return {x,y};
  });
  coords.forEach(({x,y}) => regenerateTreeAt(x,y));
  showToast('Trees regenerated with new sizes');
  updateDeleteTreesAvailability();
});

deleteTreesBtn.addEventListener('click', ()=>{
  clearAllTrees();
  showToast('All trees removed');
});


document.getElementById('importInput').addEventListener('change',function(e){
  const file=e.target.files[0]; if(!file) return;
  const reader=new FileReader();
  reader.onload=function(e){
    try{ const data=JSON.parse(e.target.result); importGrid(data); showToast('Voxel grid imported'); }
    catch(err){ alert('Error importing file: '+err.message); }
  };
  reader.readAsText(file); this.value='';
});

/* Edge width / visibility and colors */
function setEdgeWidth(px){
  const v=Math.max(0,Math.round(px)); state.voxel.edgeW=v;
  if(state.voxel.edges){ document.documentElement.style.setProperty('--edge-w', v+'px'); }
}
function setEdges(on){
  state.voxel.edges=on; edgesToggle.textContent=`Edges: ${on?'On':'Off'}`;
  document.documentElement.style.setProperty('--edge-display', on?'block':'none');
  document.documentElement.style.setProperty('--edge-w', on?(state.voxel.edgeW+'px'):'0px');
}
function setEdgeColor(c){ document.documentElement.style.setProperty('--edge-color', c); }
function setGround(c){ document.documentElement.style.setProperty('--ground', c); }
function setGroundInner(c){ document.documentElement.style.setProperty('--ground-inner', c); }

if(edgeW){ edgeW.value=state.voxel.edgeW; edgeW.addEventListener('input',e=>setEdgeWidth(+e.target.value)); }
vxScale.addEventListener('input',e=>{ state.voxel.scale=+e.target.value/100; document.getElementById('voxel').style.transform=`translate(-50%,-50%) scale(${state.voxel.scale})`; });
vxX.addEventListener('input',e=>{ state.voxel.x=+e.target.value; const el=$('voxel'); el.style.left=(state.voxel.x/W*100)+'%'; });
vxY.addEventListener('input',e=>{ state.voxel.y=+e.target.value; const el=$('voxel'); el.style.top=(state.voxel.y/H*100)+'%'; });
snapCenter.addEventListener('click',()=>{ vxX.value=W/2; vxY.value=H/2; state.voxel.x=W/2; state.voxel.y=H/2; const el=$('voxel'); el.style.left='50%'; el.style.top='50%'; });
edgesToggle.addEventListener('click',()=>{ setEdges(!state.voxel.edges); buildVoxel(); });

edgeColor.addEventListener('input', e=>setEdgeColor(e.target.value));
groundColor.addEventListener('input', e=>setGround(e.target.value));
groundInnerColor.addEventListener('input', e=>setGroundInner(e.target.value));



/* ====== Unified save/load to support file versions ====== */

// 2.1 Build a complete payload (shared by local + file)
function buildPayload(){
  const css = getComputedStyle(document.documentElement);

  // voxels snapshot
  const voxDump = voxels.map(v => ({
    x:v.x, y:v.y, level:v.level, base:v.base, active:!!v.active
  }));

  // trees snapshot (keep trunk height & canopy diameter)
  const treeDump = Array.from(trees.entries()).map(([key, el])=>{
    const [xStr,yStr] = key.split(',');
    const trunkH = parseFloat(el.querySelector('.trunk').style.height) || 0;
    const dia    = parseFloat(el.querySelector('.canopy').style.width)  || 0;
    return { x:+xStr, y:+yStr, trunkH, dia };
  });

  // texts snapshot
const textsDump = state.texts.map(t => ({
  id:t.id, label:t.label, text:t.text, size:t.size, color:t.color, align:t.align, x:t.x, y:t.y,
  font: t.font?.name || FONTS[0].name, weight:t.weight,
  outline:t.outline, outlineColor:t.outlineColor, outlineWidth:t.outlineWidth,
  shadow:t.shadow, shadowOffsetX:t.shadowOffsetX, shadowOffsetY:t.shadowOffsetY,
  shadowBlur:t.shadowBlur, shadowColor:t.shadowColor, shadowOpacity:t.shadowOpacity,
  highlight: t.highlight
}));


  return {
    schema: "ig-post-designer",
    version: 2,
    savedAt: new Date().toISOString(),

    rows, cols, currentLevel, proMode,

    stateMisc: {
      bg: state.bg,
      padding: state.padding,
      grid: state.grid,
      safeOn: state.safeOn,
      thirds: state.thirds,
      voxel: state.voxel
    },

    activeTextId: state.activeTextId,
    texts: textsDump,

    ui: { vxScale: +vxScale.value, vxX: +vxX.value, vxY: +vxY.value, edgeW: +edgeW.value },

    colors: {
      edgeCol: edgeColor.value,
      groundCol: groundColor.value,
      groundIn: groundInnerColor.value,
      treeFill: css.getPropertyValue('--tree-fill').trim()
    },

    voxels: voxDump,
    trees: treeDump
  };
}

// 2.2 Load from a data object (shared by local + file)
function loadFromData(data){
  if (!data || data.schema !== "ig-post-designer") {
    showToast('Invalid or unknown project file'); return false;
  }

  // grid size
  if (Number.isFinite(data.cols) && Number.isFinite(data.rows)){
    cols = data.cols; rows = data.rows;
    colsInput.value = cols; rowsInput.value = rows;
  }
  initGrid();
  if (typeof buildGhostHitboxes === 'function') buildGhostHitboxes();

  // colors
  if (data.colors){
    if (data.colors.edgeCol)   { edgeColor.value = data.colors.edgeCol; setEdgeColor(data.colors.edgeCol); }
    if (data.colors.groundCol) { groundColor.value = data.colors.groundCol; setGround(data.colors.groundCol); }
    if (data.colors.groundIn)  { groundInnerColor.value = data.colors.groundIn; setGroundInner(data.colors.groundIn); }
    if (data.colors.treeFill)  { document.documentElement.style.setProperty('--tree-fill', data.colors.treeFill); }
  }

  // misc state
  if (data.stateMisc){
    const s = data.stateMisc;
    state.bg = s.bg;              bgColor.value = rgbToHex(state.bg);
    state.padding = s.padding;    padding.value = s.padding;

    state.grid = { ...s.grid };
    gridToggle.textContent  = `Grid: ${state.grid.on?'On':'Off'}`;
    centerToggle.textContent= `Centered: ${state.grid.centered?'On':'Off'}`;
    gridSpacing.value = state.grid.spacing;
    gridAlpha.value   = state.grid.alpha;

    state.safeOn = s.safeOn;  safeToggle.textContent = `Safe: ${state.safeOn?'On':'Off'}`;
    state.thirds = s.thirds;  ruleThirds.classList.toggle('primary', state.thirds);

    state.voxel = { ...s.voxel };
    vxScale.value = Math.round(state.voxel.scale*100);
    $('voxel').style.transform = `translate(-50%,-50%) scale(${state.voxel.scale})`;
    vxX.value = state.voxel.x;  vxY.value = state.voxel.y;
    const vEl = $('voxel');
    vEl.style.left = (state.voxel.x/W*100)+'%';
    vEl.style.top  = (state.voxel.y/H*100)+'%';
    edgeW.value = state.voxel.edgeW; setEdgeWidth(state.voxel.edgeW);
    setEdges(!!state.voxel.edges);
  }

  // texts
  if (Array.isArray(data.texts) && data.texts.length){
    state.texts = data.texts.map(d => ({ ...d, font: FONTS.find(f=>f.name===d.font) || FONTS[0] }));
    const head = state.texts.find(t=>t.id==='head');
    const sub  = state.texts.find(t=>t.id==='sub');
    if (head) state.head = head;
    if (sub)  state.sub  = sub;
  } else {
    state.texts = [state.head, state.sub];
  }
  state.activeTextId = data.activeTextId || (state.texts[0]?.id);
  rebuildTextButtons();
  syncPanelToActive();

  // voxels
  if (Array.isArray(data.voxels)){
    voxels.forEach(v => { v.active=false; v.level=0; v.base=0; });
    data.voxels.forEach(sv=>{
      if (sv.x<0 || sv.x>=cols || sv.y<0 || sv.y>=rows) return;
      const v = voxels[sv.y*cols + sv.x]; if (!v) return;
      v.level  = +sv.level || 0;
      v.base   = +sv.base  || 0;
      v.active = !!sv.active;
    });
    buildVoxel(); updateStats();
  }

  // trees
  clearAllTrees();
  if (Array.isArray(data.trees)){
    data.trees.forEach(t=> placeTreeAt(t.x, t.y, t.trunkH, t.dia));
  }

  render();
  showToast('Project loaded');
  return true;
}


// Return the largest numeric suffix among existing text items (ids like "text7" or labels like "Text 7")
function getLargestTextNumber() {
  let max = 2; // head/sub conceptually 1/2
  for (const t of state.texts) {
    // from id
    const m1 = typeof t.id === 'string' && t.id.match(/^text(\d+)$/i);
    if (m1) { max = Math.max(max, +m1[1]); continue; }
    // from label (fallback)
    const m2 = typeof t.label === 'string' && t.label.match(/^text\s+(\d+)$/i);
    if (m2) { max = Math.max(max, +m2[1]); }
  }
  return max;
}

// Compute a unique id/label for the next text
function nextTextIdLabel() {
  let n = getLargestTextNumber() + 1;
  // ensure uniqueness even if there are weird ids
  let id = `text${n}`;
  const existingIds = new Set(state.texts.map(t => t.id));
  while (existingIds.has(id)) { n++; id = `text${n}`; }
  return { id, label: `Text ${n}` };
}


// 2.3 Keep your existing local save/load, but refactor to use the helpers
function saveToLocal(){
  localStorage.setItem(LS_KEY, JSON.stringify(buildPayload()));
  showToast('Saved locally!');
}
function loadFromLocal(){
  const raw = localStorage.getItem(LS_KEY);
  if(!raw){ showToast('No local save found'); return false; }
  try{ return loadFromData(JSON.parse(raw)); }
  catch(e){ showToast('Corrupt local save'); return false; }
}

// 2.4 File save / load (many versions)
function saveToFile(){
  const payload = buildPayload();
  const blob = new Blob([JSON.stringify(payload,null,2)], { type:'application/json' });
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `ig-post-${ts}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
  showToast('Project file saved');
}

function loadFromFile(file){
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const data = JSON.parse(e.target.result);
      loadFromData(data);
    } catch(err){
      alert('Error reading project file: ' + err.message);
    }
  };
  reader.readAsText(file);
}

// 2.5 Wire up the new buttons
$('saveFileBtn').addEventListener('click', saveToFile);
$('loadFileBtn').addEventListener('click', () => $('loadFileInput').click());
$('loadFileInput').addEventListener('change', (e) => {
  const file = e.target.files?.[0];
  if (file) loadFromFile(file);
  e.target.value = ''; // allow re-selecting same file later
});



/* ====== Export PNG ====== */
exportBtn.addEventListener('click', async () => {
  showToast('Exporting... Please wait');

  const shell = $('shell');
  const voxelLayer = document.getElementById('voxel');
  const gridEl = document.querySelector('.grid-container'); // NEW: reuse this ref

  // Store original styles
  const originalStyles = {
    shell: {
      width: shell.style.width,
      height: shell.style.height,
      position: shell.style.position,
      overflow: shell.style.overflow
    },
    voxel: {
      left: voxelLayer.style.left,
      top: voxelLayer.style.top,
      transform: voxelLayer.style.transform,
      width: voxelLayer.style.width,
      height: voxelLayer.style.height
    },
    body: { overflow: document.body.style.overflow },
    grid: {
      // Keep the computed custom prop; fallback to '0.8' if blank
      scaleVar: gridEl ? (getComputedStyle(gridEl).getPropertyValue('--grid-scale') || '0.8') : '0.8'
    }
  };

  try {
    // Prepare for export
    document.body.style.overflow = 'hidden';

    // Exact shell dimensions
    shell.style.width = '1080px';
    shell.style.height = '1350px';
    shell.style.position = 'absolute';
    shell.style.left = '0';
    shell.style.top = '0';
    shell.style.overflow = 'visible';

    // ---- Bake .grid-container scale into the outer #voxel transform (live DOM) ----
    const pctLeft = (state.voxel.x / W) * 100;
    const pctTop  = (state.voxel.y / H) * 100;

    let gridScaleNum = 1;
    if (gridEl) {
      const cs = getComputedStyle(gridEl);
      const gs = cs.getPropertyValue('--grid-scale') || '1';
      gridScaleNum = parseFloat(gs) || 1;
      gridEl.style.setProperty('--grid-scale', '1'); // neutralize inner for snapshot
    }

    voxelLayer.style.left = pctLeft + '%';
    voxelLayer.style.top  = pctTop  + '%';
    voxelLayer.style.transform =
      `translate(-50%, -50%) scale(${state.voxel.scale * gridScaleNum})`;

    // Ensure DOM updates
    await new Promise(r => setTimeout(r, 100));

    const canvasOut = await html2canvas(shell, {
      backgroundColor: null,
      useCORS: true,
      scale: Math.max(2, window.devicePixelRatio || 1),
      logging: false,
      ignoreElements: el => el?.hasAttribute?.('data-export-exclude'),
      foreignObjectRendering: true,
      width: 1080,
      height: 1350,
      x: 0,
      y: 0,
      scrollX: 0,
      scrollY: 0,
      windowWidth: document.documentElement.clientWidth,
      windowHeight: document.documentElement.clientHeight,
      onclone: function (clonedDoc) {
        const clonedShell = clonedDoc.getElementById('shell');
        if (clonedShell) {
          clonedShell.style.width = '1080px';
          clonedShell.style.height = '1350px';
          clonedShell.style.overflow = 'visible';
        }

        // --- same baking on the cloned DOM ---
        const clonedGrid = clonedDoc.querySelector('.grid-container');
        let gridScaleNumClone = 1;
        if (clonedGrid) {
          const ccs = clonedDoc.defaultView.getComputedStyle(clonedGrid);
          const gs = ccs.getPropertyValue('--grid-scale') || '1';
          gridScaleNumClone = parseFloat(gs) || 1;
          clonedGrid.style.setProperty('--grid-scale', '1'); // neutralize inner
        }

        const clonedVoxel = clonedDoc.getElementById('voxel');
        if (clonedVoxel) {
          const pctLeft = (state.voxel.x / W) * 100;
          const pctTop  = (state.voxel.y / H) * 100;
          clonedVoxel.style.left = pctLeft + '%';
          clonedVoxel.style.top  = pctTop  + '%';
          clonedVoxel.style.transform =
            `translate(-50%, -50%) scale(${state.voxel.scale * gridScaleNumClone})`;
        }
      }
    });

    const a = document.createElement('a');
    a.download = 'post_1080x1350.png';
    a.href = canvasOut.toDataURL('image/png');
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    showToast('Exported successfully!');
  } catch (error) {
    console.error('Export error:', error);
    showToast('Export failed. Please try again.');
  } finally {
    // Restore original styles
    shell.style.width = originalStyles.shell.width;
    shell.style.height = originalStyles.shell.height;
    shell.style.position = originalStyles.shell.position;
    shell.style.overflow = originalStyles.shell.overflow;
    shell.style.left = '';
    shell.style.top = '';

    voxelLayer.style.left = originalStyles.voxel.left;
    voxelLayer.style.top = originalStyles.voxel.top;
    voxelLayer.style.transform = originalStyles.voxel.transform;
    voxelLayer.style.width = originalStyles.voxel.width;
    voxelLayer.style.height = originalStyles.voxel.height;

    document.body.style.overflow = originalStyles.body.overflow;

    // NEW: restore --grid-scale
    if (gridEl) {
      gridEl.style.setProperty('--grid-scale', originalStyles.grid.scaleVar.trim() || '0.8');
    }

    render();
  }
});


/* ====== Reset ====== */
reset.addEventListener('click', ()=>{
  // core state
  state.bg=OFFWHITE;
  state.padding=90;
  state.grid={on:true, centered:true, spacing:120, alpha:.25};
  state.safeOn=true;
  state.thirds=false;
  state.voxel={ x:W/2, y:H*0.5, scale:1, edges:true, edgeW:3 };
  state.mode='text';

// texts
state.head = {
  id:'head', label:'Headline',
  text:'HELLO, IG!', size:120, color:OFFBLACK, align:'center', x:W/2, y:H*0.2,
  font:FONTS[0], weight:400,
  outline:false, outlineColor:OFFWHITE, outlineWidth:2,
  shadow:false, shadowOffsetX:4, shadowOffsetY:4, shadowBlur:0, shadowColor:'#000000', shadowOpacity:0.5,
  highlight: {
    on: false,
    color: '#fff200',
    opacity: 0.6,
    padX: 16,
    padY: 8,
    radius: 10,
    perLine: true
  }
};
state.sub = {
  id:'sub', label:'Subtitle',
  text:'Clean, bold, fast.', size:48, color:OFFBLACK, align:'center', x:W/2, y:H*0.32,
  font:FONTS[1], weight:400,
  outline:false, outlineColor:OFFWHITE, outlineWidth:2,
  shadow:false, shadowOffsetX:2, shadowOffsetY:2, shadowBlur:0, shadowColor:'#000000', shadowOpacity:0.5,
  highlight: {
    on: false,
    color: '#fff200',
    opacity: 0.6,
    padX: 16,
    padY: 8,
    radius: 10,
    perLine: true
  }
};
state.texts = [state.head, state.sub];
state.activeTextId = 'head';
textSeq = 3;


  // UI resets
  document.querySelectorAll('.dot').forEach((d,i)=>d.classList.toggle('active', i===0));
  bgColor.value='#fcfaf3';
  vxScale.value=100; vxX.value=W/2; vxY.value=H*0.5;
  document.getElementById('voxel').style.transform=`translate(-50%,-50%) scale(1)`;
  const vEl = document.getElementById('voxel'); vEl.style.left='50%'; vEl.style.top='50%';
  setEdgeWidth(state.voxel.edgeW); setEdges(true);
  setEdgeColor('#ff8400'); setGround('#2a2a2a'); setGroundInner('#3a3a3a');
  if(edgeColor) edgeColor.value='#ff8400';
  if(groundColor) groundColor.value='#2a2a2a';
  if(groundInnerColor) groundInnerColor.value='#3a3a3a';

  colsInput.value=8; rowsInput.value=20; currentLevel=1; levelBtn.textContent='Level: 1';
  deleteBtn.textContent='Delete All'; ideasBtn.textContent='Design Ideas';
  proMode=false; proModeBtn.textContent='🔒 Pro Mode';

  initGrid();
  clearAllTrees();

  rebuildTextButtons();
  setActiveById('head');
  setMode('text');
  syncPanelToActive();
  render();
});

/* ====== Init ====== */
(function init(){
  // color swatches
  document.querySelectorAll('.dot').forEach(dot=>{
    dot.addEventListener('click',()=>{
      document.querySelectorAll('.dot').forEach(d=>d.classList.remove('active'));
      dot.classList.add('active');
      const key=dot.getAttribute('data-color');
     const colorValue =
  key==='orange'   ? ORANGE   :
  key==='offblack' ? OFFBLACK :
  key==='teal'     ? '#00D1B2':
  key==='gray'     ? '#525252':
  OFFWHITE;
      state.bg=colorValue; bgColor.value=rgbToHex(colorValue); render();
    });
  });

  initGrid();
  rebuildTextButtons();
  setActiveById('head');
  setMode('text');
  syncPanelToActive();
  render();

  // set CSS edge width/color
  setEdgeWidth(state.voxel.edgeW);
  setEdges(true);
  setEdgeColor(edgeColor.value); setGround(groundColor.value); setGroundInner(groundInnerColor.value);
})();
</script>
</body> 
</html>
 
