<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Image Viewer with Mapbox</title>
    <!-- Mapbox GL JS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <style>
        :root {
            --bg: #0b1020;
            --panel: #0f172a;
            --accent: #22d3ee;
            --muted: #94a3b8;
            --error: #ef4444;
            --success: #10b981;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            height: 100vh;
            margin: 0;
            background: var(--bg);
            color: #e2e8f0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
            overflow: hidden;
            touch-action: none;
        }
        
        .app {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 16px;
            height: 50px;
            border-bottom: 1px solid #1f2937;
            background: linear-gradient(180deg, rgba(34,211,238,0.06), rgba(34,211,238,0));
            flex-shrink: 0;
        }
        
        header h1 {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
        }
        
        header .pill {
            padding: 4px 8px;
            border: 1px solid #233045;
            border-radius: 999px;
            font-size: 11px;
            color: var(--muted);
        }
        
        #map {
            width: 100%;
            height: 50vh;
            flex-shrink: 0;
        }
        
        .viewer-container {
            position: relative;
            background: var(--panel);
            height: 50vh;
            flex-grow: 1;
            overflow: hidden;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        
        .legend {
            position: absolute;
            bottom: 12px;
            left: 12px;
            font-size: 12px;
            color: #cbd5e1;
            background: rgba(2,6,23,.65);
            border: 1px solid #263247;
            padding: 8px 10px;
            border-radius: 10px;
            z-index: 4;
        }
        
        .toast {
            position: absolute;
            top: 60px;
            right: 16px;
            background: #0b1220;
            border: 1px solid #263247;
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 12px;
            color: #cbd5e1;
            z-index: 10;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .toast.error {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.3);
        }
        
        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top: 4px solid var(--accent);
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .image-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 5;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 10px;
            align-items: center;
        }
        
        button.icon {
            background: #0b1220;
            border: 1px solid #263247;
            color: #cbd5e1;
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button.icon:hover {
            border-color: #33445f;
            background: #131d33;
        }
        
        .progress-container {
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            cursor: pointer;
            position: relative;
            flex-grow: 1;
            min-width: 100px;
        }
        
        .progress-bar {
            height: 100%;
            background: #ff6b6b;
            border-radius: 5px;
            width: 0%;
        }
        
        .time {
            margin: 0 10px;
            font-variant-numeric: tabular-nums;
            min-width: 60px;
            text-align: center;
            font-size: 14px;
        }
        
        .current-location-marker {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ff6b6b;
            border: 2px solid white;
            box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.5);
        }
        
        .zoom-controls {
            position: absolute;
            right: 10px;
            bottom: 80px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 5;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #263247;
            color: #cbd5e1;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
        }
        
        .zoom-btn:hover {
            background: rgba(0,0,0,0.7);
        }
        
        .reset-view {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
        }
        
        .preload-status {
            position: absolute;
            bottom: 80px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
        }
        
        @media (min-width: 768px) {
            .app {
                flex-direction: row;
                height: 100vh;
            }
            
            header {
                display: none;
            }
            
            #map {
                width: 50%;
                height: 100%;
            }
            
            .viewer-container {
                width: 50%;
                height: 100%;
            }
            
            .mobile-header {
                display: none;
            }
        }
        
        .mobile-header {
            padding: 10px;
            text-align: center;
            background: rgba(15,23,42,.7);
            border-bottom: 1px solid #1f2937;
        }
        
        .debug-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
            display: none;
        }
        
        .zoom-level {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="app">
        <div id="map"></div>
        
        <div class="viewer-container">
            <div class="mobile-header">
                <h2>360° Viewer</h2>
            </div>
            
            <canvas id="canvas"></canvas>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div id="loading-text">Loading 360° images...</div>
            </div>
            
            <div class="legend">
                Drag to look around. Pinch to zoom. Tap on the map to navigate.
            </div>
            
            <div class="toast" id="toast"></div>
            
            <div class="debug-info" id="debug-info"></div>
            
            <div class="zoom-level" id="zoom-level">Zoom: 75°</div>
            
            <div class="preload-status" id="preload-status">Preloading: 0%</div>
            
            <div class="reset-view">
                <button class="icon" id="resetView">Reset View</button>
            </div>
            
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomIn">+</button>
                <button class="zoom-btn" id="zoomOut">-</button>
            </div>
            
            <div class="image-controls" id="imageControls">
                <button class="icon" id="prevImage">◀</button>
                <div class="progress-container" id="progress-container">
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
                <div class="time" id="time">1/12</div>
                <button class="icon" id="nextImage">▶</button>
            </div>
        </div>
    </div>

    <script>
        // ===== 0) CONFIG =====
        const MAPBOX_TOKEN = 'pk.eyJ1IjoiYW5kcmVzbXR6YyIsImEiOiJjbWN4ZWZvc3MwNjNjMnJwd3h6ZXdyOGJoIn0.ahgRYAxpOnGnnqOjQvJZTA';
        
        // Image data with coordinates and orientation
         let IMAGE_DATA = [];
        
          async function loadManifest(url) {
  try {
    const u = new URL(url, location.href);
    u.searchParams.set('t', Date.now()); // evita caché en desarrollo
    const res = await fetch(u.toString(), { method: 'GET', cache: 'no-store' });

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`HTTP ${res.status} ${res.statusText} – Body: ${text?.slice(0, 200)}`);
    }

    const jsonText = await res.text();
    let arr = null;

    try {
      const json = JSON.parse(jsonText);

      if (Array.isArray(json)) {
        arr = json;
      } else if (Array.isArray(json.images)) {
        arr = json.images;
      } else if (Array.isArray(json.nodes)) {
        arr = json.nodes;
      }

      if (!arr) {
        throw new Error('Invalid format: expected array or { images: [] } or { nodes: [] }');
      }

      const base = new URL('.', u); // base path del manifest
      arr = arr.map((it, i) => {
        ['id', 'src', 'lat', 'lon'].forEach((k) => {
          if (!(k in it)) throw new Error(`Item ${i} missing key "${k}"`);
        });
        const srcAbs = /^https?:\/\//i.test(it.src) ? it.src : new URL(it.src, base).toString();
        return { ...it, src: srcAbs };
      });

      showToast(`Manifest OK (${arr.length} frames)`, 1500);
      return arr;
    } catch (parseErr) {
      throw new Error(
        `JSON.parse error: ${parseErr.message}\nPrimeros 200 chars:\n${jsonText.slice(0, 200)}`
      );
    }
  } catch (e) {
    console.error('[loadManifest] Error:', e);
    showToast(e.message, 6000, true);
    throw e;
  }
}
  
// === Route-based heading ===
const CAMERA_HEADING_OFFSET_DEG = 0; // if your camera points 90° right of travel, set 90

// Bearing in degrees (0..360, 0 = North, clockwise)
function bearingDeg(fromLat, fromLon, toLat, toLon) {
  const φ1 = degToRad(fromLat), φ2 = degToRad(toLat);
  const Δλ = degToRad(toLon - fromLon);
  const y = Math.sin(Δλ) * Math.cos(φ2);
  const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
  return (radToDeg(Math.atan2(y, x)) + 360) % 360;
}

// Compute per-point route headings (simple forward bearing)
function computeRouteYawSimple(data, offsetDeg = 0) {
  const n = data.length;
  const yaw = new Array(n).fill(0);
  if (n === 0) return yaw;
  if (n === 1) { yaw[0] = (offsetDeg + 360) % 360; return yaw; }

  for (let i = 0; i < n; i++) {
    let a = i, b = Math.min(i + 1, n - 1);
    if (i === n - 1) { a = n - 2; b = n - 1; } // last one looks back
    const A = data[a], B = data[b];
    const h = bearingDeg(A.lat, A.lon, B.lat, B.lon);
    yaw[i] = (h + offsetDeg + 360) % 360;
  }
  return yaw;
}
 
// Globals cache of route headings
let ROUTE_YAWS = [];
// Fine-tune how the pano texture is aligned relative to the route
const TEXTURE_YAW_OFFSET_DEG = 210; // tweak (+/-). 0 means no shift. OFFSET HERE
let panoGroup = null;              // parent of the sphere
        let currentImageIndex = 0;
        let currentYaw = 0;
        let currentPitch = 0;
        let currentFov = 75; // Default field of view
        let preloadedImages = {}; // Cache for preloaded images
        let preloadQueue = []; // Queue for preloading images
        let bgPreloadStarted = false;
        
        // ===== 1) MAPBOX INIT =====
        mapboxgl.accessToken = MAPBOX_TOKEN;
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/dark-v11',
            center: [-100.29, 25.66],
            zoom: 17,
            attributionControl: false
        });
        
        // Add navigation control
        map.addControl(new mapboxgl.NavigationControl({ showCompass: false }), 'top-left');
        
        // ===== 2) THREE.JS SETUP =====
        let scene, camera, renderer, sphere;
        
        function initThreeJS() {
            // Set up scene
            scene = new THREE.Scene();
            panoGroup = new THREE.Group();
scene.add(panoGroup);
            // Set up camera with initial FOV
            const canvas = document.getElementById('canvas');
            camera = new THREE.PerspectiveCamera(currentFov, canvas.offsetWidth / canvas.offsetHeight, 0.1, 1000);
            camera.position.set(0, 0, 0.1);
            
            // Set up renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Update zoom level display
            updateZoomDisplay();
            
            // Start animation loop
            animate();
        }
        
        function onWindowResize() {
            const canvas = document.getElementById('canvas');
            camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            updateViewCone();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        // ===== 3) IMAGE PRELOADING =====
function startBackgroundPreload(concurrency = 3) {
  if (bgPreloadStarted || IMAGE_DATA.length <= 1) return;
  bgPreloadStarted = true;

  const order = buildPreloadOrder(currentImageIndex, IMAGE_DATA.length);
  runPreloadPool(order, concurrency);
}

// Interleave around the current index: +1, -1, +2, -2, ...
function buildPreloadOrder(center, total) {
  const seq = [];
  for (let step = 1; step < total; step++) {
    const fwd = center + step;
    const back = center - step;
    if (fwd < total) seq.push(fwd);
    if (back >= 0) seq.push(back);
  }
  return seq;
}

function runPreloadPool(indexes, concurrency) {
  let i = 0;
  const workers = Array.from({ length: Math.min(concurrency, indexes.length) }, async () => {
    while (i < indexes.length) {
      const idx = indexes[i++];
      await preloadOne(idx).catch(() => {});
    }
  });
  // No await needed; let it run in the background
  Promise.all(workers).then(() => {
    // optional: showToast('Preload complete', 1200);
  });
}

function preloadOne(index) {
  return new Promise((resolve) => {
    const item = IMAGE_DATA[index];
    if (!item) return resolve();

    const src = item.src;
    if (preloadedImages[src]) return resolve(); // already cached

    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.onload = () => {
      preloadedImages[src] = img;
      resolve();
    };
    img.onerror = () => resolve(); // swallow errors; keep going
    // important: no cache-busting here
    img.src = src;

    // Decode hint (non-blocking) if supported
    if (img.decode) img.decode().catch(() => {});
  });
}
        
        function updatePreloadStatus(percent) {
            const preloadStatus = document.getElementById('preload-status');
            preloadStatus.textContent = `Preloading: ${percent}%`;
            preloadStatus.style.display = 'block';
        }
        
        function preloadAdjacentImages() {
            // Clear any existing preload queue
            preloadQueue = [];
            
            // Preload next and previous images for smoother navigation
            const prevIndex = currentImageIndex - 1;
            const nextIndex = currentImageIndex + 1;
            
            if (prevIndex >= 0 && !preloadedImages[IMAGE_DATA[prevIndex].src]) {
                preloadQueue.push(prevIndex);
            }
            
            if (nextIndex < IMAGE_DATA.length && !preloadedImages[IMAGE_DATA[nextIndex].src]) {
                preloadQueue.push(nextIndex);
            }
            
            // Process preload queue
            processPreloadQueue();
        }
        
        function processPreloadQueue() {
            if (preloadQueue.length === 0) return;
            
            const index = preloadQueue.shift();
            const imageData = IMAGE_DATA[index];
            
            if (preloadedImages[imageData.src]) {
                // Image already loaded, process next in queue
                processPreloadQueue();
                return;
            }
            
            const img = new Image();
            img.crossOrigin = "Anonymous";
            
            img.onload = function() {
                preloadedImages[imageData.src] = img;
                processPreloadQueue();
            };
            
            img.onerror = function() {
                console.error('Failed to preload image:', imageData.src);
                processPreloadQueue();
            };
            
            // Add a timestamp to bypass cache
            const timestamp = new Date().getTime();
            const url = imageData.src + '?t=' + timestamp;
            img.src = url;
        }
        
        // ===== ORIENTATION HELPERS =====
function radToDeg(r) { return r * 180 / Math.PI; }
function degToRad(d) { return d * Math.PI / 180; }
function normDeg(d) { d = d % 360; return d < 0 ? d + 360 : d; }
function fmt(n, p = 1) { return Number.isFinite(n) ? n.toFixed(p) : '—'; }


function getHorizontalFovDeg() {
  // THREE.PerspectiveCamera FOV is vertical; convert to horizontal using aspect
  const vRad = THREE.MathUtils.degToRad(currentFov);
  const hRad = 2 * Math.atan(Math.tan(vRad / 2) * camera.aspect);
  return THREE.MathUtils.radToDeg(hRad);
}

// Forward geodesic (bearing+distance -> dest lon/lat)
function destFromBearingDistance(lat, lon, bearingDeg, distMeters) {
  const R = 6378137;
  const brng = degToRad(bearingDeg);
  const φ1 = degToRad(lat), λ1 = degToRad(lon);
  const φ2 = Math.asin(Math.sin(φ1) * Math.cos(distMeters / R) +
                       Math.cos(φ1) * Math.sin(distMeters / R) * Math.cos(brng));
  const λ2 = λ1 + Math.atan2(
    Math.sin(brng) * Math.sin(distMeters / R) * Math.cos(φ1),
    Math.cos(distMeters / R) - Math.sin(φ1) * Math.sin(φ2)
  );
  return [radToDeg(λ2), radToDeg(φ2)];
}

// Build a polygon ring for a FOV cone
function makeViewConeRing(lat, lon, headingDeg, fovDeg, radiusMeters = 40, steps = 24) {
  const half = Math.max(0, Math.min(179, fovDeg/2)); // guard
  const start = headingDeg - half;
  const end   = headingDeg + half;

  const ring = [[lon, lat]]; // start at origin
  for (let s = 0; s <= steps; s++) {
    const t = s / steps;
    const brg = start + (end - start) * t;
    ring.push(destFromBearingDistance(lat, lon, brg, radiusMeters));
  }
  ring.push([lon, lat]); // close polygon
  return ring;
}

// Update the map polygon to match current yaw + FOV CONE DIMENSION
function updateViewCone() {
  if (!map || !map.getSource('view-cone')) return;
  const img = IMAGE_DATA[currentImageIndex];
  if (!img) return;

  const headingDeg = normDeg(radToDeg(currentYaw));
  const fovH = getHorizontalFovDeg();         // use horizontal FOV for the cone
  const ring = makeViewConeRing(img.lat, img.lon, headingDeg, fovH, /*radius*/ 7, /*steps*/24);

  map.getSource('view-cone').setData({
    type: 'Feature',
    geometry: { type: 'Polygon', coordinates: [ring] }
  });
}

// Updates the box in the top-right with FOV, Yaw, Pitch, Heading, Lat/Lon
// Updates the box with FOV, dynamic Heading, Pitch, and the frame's original Heading + Lat/Lon
function updateStatusBox() {
  const el = document.getElementById('zoom-level');
  if (!el) return;

  const img = IMAGE_DATA[currentImageIndex] || {};
  const yawDegDynamic = normDeg(radToDeg(currentYaw));
  const pitchDeg = radToDeg(currentPitch);
  const frameHeading =
    (ROUTE_YAWS[currentImageIndex] != null) ? ROUTE_YAWS[currentImageIndex] : null;

  el.innerHTML = `
    <div style="line-height:1.25">
      <div><strong>Zoom</strong>: ${fmt(currentFov,0)}°</div>
      <div><strong>Heading</strong>: ${fmt(yawDegDynamic)}°</div>
      <div><strong>Pitch</strong>: ${fmt(pitchDeg)}°</div>
      <div><strong>Route Heading</strong>: ${frameHeading != null ? fmt(frameHeading) + '°' : '—'}</div>
      <div><strong>Lat</strong>: ${img.lat != null ? fmt(img.lat,6) : '—'}</div>
      <div><strong>Lon</strong>: ${img.lon != null ? fmt(img.lon,6) : '—'}</div>
    </div>
  `;
}  
 

// 16-point compass for nice labels (N, NNE, NE, ...)
function degToCompass(d) {
    const dirs = ["N","NNE","NE","ENE","E","ESE","SE","SSE",
                  "S","SSW","SW","WSW","W","WNW","NW","NNW"];
    const i = Math.round(normDeg(d) / 22.5) % 16;
    return dirs[i];
}

        // ===== 4) ZOOM CONTROLS =====
        function zoomIn() {
            if (currentFov > 30) {
                currentFov -= 5;
                camera.fov = currentFov;
                camera.updateProjectionMatrix();
                updateZoomDisplay();
                showToast(`Zoomed in (${currentFov}°)`, 1000);
            }
        }
        
        function zoomOut() {
            if (currentFov < 120) {
                currentFov += 5;
                camera.fov = currentFov;
                camera.updateProjectionMatrix();
                updateZoomDisplay();
                showToast(`Zoomed out (${currentFov}°)`, 1000);
            }
        }
        
function updateZoomDisplay() {
    document.getElementById('zoom-level').textContent = `Zoom: ${currentFov}°`;
    updateStatusBox(); // NEW
}
        
        function handlePinchZoom(e) {
            if (e.touches.length !== 2) return;
            
            e.preventDefault();
            
            // Calculate distance between two fingers
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const distance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            if (!this.lastPinchDistance) {
                this.lastPinchDistance = distance;
                return;
            }
            
            // Determine zoom direction
            const zoomFactor = distance / this.lastPinchDistance;
            
            if (zoomFactor > 1.05) {
                // Pinch out - zoom in
                zoomIn();
                this.lastPinchDistance = distance;
            } else if (zoomFactor < 0.95) {
                // Pinch in - zoom out
                zoomOut();
                this.lastPinchDistance = distance;
            }
        }
        
        function handleWheelZoom(e) {
            e.preventDefault();
            
            if (e.deltaY < 0) {
                // Scroll up - zoom in
                zoomIn();
            } else {
                // Scroll down - zoom out
                zoomOut();
            }
        }
        
        // ===== 5) IMAGE LOADING =====
        function loadImage(index, preserveOrientation = false) {
            if (index < 0 || index >= IMAGE_DATA.length) return;
            
            showLoading('Loading image ' + (index + 1) + '...');
            currentImageIndex = index;
            
            const imageData = IMAGE_DATA[index];
            updateDebugInfo('Loading: ' + imageData.src);
            
            // Check if image is already preloaded
            if (preloadedImages[imageData.src]) {
                updateDebugInfo('Using preloaded image: ' + imageData.src);
                applyImageToScene(preloadedImages[imageData.src], imageData, preserveOrientation);
                preloadAdjacentImages(); // Preload next/previous images
                return;
            }
            
            // Image not preloaded, load it now
            const img = new Image();
            img.crossOrigin = "Anonymous";
            
            img.onload = function() {
                updateDebugInfo('Image loaded successfully: ' + imageData.src);
                preloadedImages[imageData.src] = img; // Add to cache
                applyImageToScene(img, imageData, preserveOrientation);
                preloadAdjacentImages(); // Preload next/previous images
            };
            
            img.onerror = function() {
                updateDebugInfo('Failed to load: ' + imageData.src);
                showToast('Failed to load image ' + (index + 1), 3000, true);
                
                // Try to load the next image if this one fails
                setTimeout(() => {
                    if (index < IMAGE_DATA.length - 1) {
                        loadImage(index + 1, preserveOrientation);
                    } else if (index > 0) {
                        loadImage(index - 1, preserveOrientation);
                    } else {
                        hideLoading();
                        showToast('All images failed to load', 5000, true);
                    }
                }, 1000);
            };
            
            // Add a timestamp to bypass cache
            const timestamp = new Date().getTime();
            const url = imageData.src + '?t=' + timestamp;
            updateDebugInfo('Trying to load: ' + url);
            
            img.src = url;
        }
        
       function applyImageToScene(img, imageData, preserveOrientation) {
  // Remove previous sphere (but keep the group)
  if (sphere) {
    panoGroup.remove(sphere);
    sphere.geometry?.dispose?.();
    sphere.material?.map?.dispose?.();
    sphere.material?.dispose?.();
  }

  const geometry = new THREE.SphereGeometry(100, 60, 40);
  geometry.scale(-1, 1, 1);

  const texture = new THREE.Texture(img);
  texture.needsUpdate = true;

  const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
  sphere = new THREE.Mesh(geometry, material);

  // Add sphere inside the group
  panoGroup.add(sphere);

  // --- Apply the constant visual shift ONLY to the sphere ---
  const textureOffsetRad = THREE.MathUtils.degToRad(TEXTURE_YAW_OFFSET_DEG);
  sphere.rotation.set(0, textureOffsetRad, 0);
  // If it looks mirrored, use: sphere.rotation.set(0, -textureOffsetRad, 0);

  // --- Apply logical heading ONLY to the group ---
  if (preserveOrientation) {
    panoGroup.rotation.y = currentYaw;
    panoGroup.rotation.x = currentPitch;
  } else {
    const headingDeg = ROUTE_YAWS[currentImageIndex] ?? 0;
    const headingRad = THREE.MathUtils.degToRad(headingDeg);
    panoGroup.rotation.y = headingRad;  // or -headingRad if needed globally
    panoGroup.rotation.x = 0;
    currentYaw = panoGroup.rotation.y;
    currentPitch = 0;
  }

  updateUI();
  updateMapMarker();
  updateStatusBox();

updateViewCone();
  hideLoading();
  showToast('Loaded image ' + (currentImageIndex + 1), 1000);
}

        
        // ===== 6) MAP FUNCTIONS =====
        function initMap() {
  const coordinates = IMAGE_DATA.map(img => [img.lon, img.lat]);

  const addMapContent = () => {
    // Don’t add twice if we ever re-run
    if (!map.getSource('route')) {
      map.addSource('route', {
        type: 'geojson',
        data: {
          type: 'Feature',
          properties: {},
          geometry: { type: 'LineString', coordinates }
        }
      });

      map.addLayer({
        id: 'route',
        type: 'line',
        source: 'route',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 'line-color': '#22d3ee', 'line-width': 4, 'line-opacity': 0.7 }
      });
    }

if (!map.getSource('view-cone')) {
  map.addSource('view-cone', {
    type: 'geojson',
    data: { type: 'Feature', geometry: { type: 'Polygon', coordinates: [[[0,0],[0,0],[0,0]]] } }
  });

  map.addLayer({
    id: 'view-cone-fill',
    type: 'fill',
    source: 'view-cone',
    paint: { 'fill-color': '#ff6b6b', 'fill-opacity': 0.2 }
  });

  map.addLayer({
    id: 'view-cone-outline',
    type: 'line',
    source: 'view-cone',
    paint: { 'line-color': '#ff6b6b', 'line-width': 2, 'line-opacity': 0.8 }
  });

  updateViewCone(); // <- draw once the source exists
}


    // Fit once we know coords and style is ready
    if (coordinates.length) {
      const bounds = coordinates.reduce(
        (b, c) => b.extend(c),
        new mapboxgl.LngLatBounds(coordinates[0], coordinates[0])
      );
      map.fitBounds(bounds, { padding: 40, maxZoom: 19.5 });
    }

    // Create click-through DOM markers (once)
    if (!window.__imageMarkersAdded) {
      IMAGE_DATA.forEach((img, index) => {
        const el = document.createElement('div');
        el.className = 'map-marker';
        el.innerHTML = `<div style="width:16px;height:16px;border-radius:50%;background:#22d3ee;border:2px solid white;cursor:pointer;"></div>`;
        el.dataset.index = index;
        new mapboxgl.Marker(el).setLngLat([img.lon, img.lat]).addTo(map);
        el.addEventListener('click', () => loadImage(index, true));
      });
      window.__imageMarkersAdded = true;
    }

    // Current location marker (create once, then we update it elsewhere)
    if (!window.currentLocationMarker && IMAGE_DATA[0]) {
      const currentLocationEl = document.createElement('div');
      currentLocationEl.className = 'current-location-marker';
      window.currentLocationMarker = new mapboxgl.Marker(currentLocationEl)
        .setLngLat([IMAGE_DATA[0].lon, IMAGE_DATA[0].lat])
        .addTo(map);
    }

    // Map click handler (only add once)
    if (!window.__mapClickBound) {
      map.on('click', (e) => {
        const features = map.queryRenderedFeatures(e.point);
        const clickedOnMarker = features.some(f => f.layer && f.layer.id && (f.layer.id.includes('marker') || (f.source && f.source.includes && f.source.includes('marker'))));
        if (clickedOnMarker) return;

        const clicked = e.lngLat;
        let closestIndex = 0, minDist = Infinity;
        IMAGE_DATA.forEach((img, i) => {
          const d = getDistance(clicked, [img.lon, img.lat]);
          if (d < minDist) { minDist = d; closestIndex = i; }
        });
        if (minDist < 15) loadImage(closestIndex, true);
      });
      window.__mapClickBound = true;
    }
  };

  // If the map’s style is already loaded, run now; otherwise wait once
  if (map.isStyleLoaded && map.isStyleLoaded()) {
    addMapContent();
  } else {
    map.once('load', addMapContent);
  }
}

        
        function updateMapMarker() {
            if (!window.currentLocationMarker || !IMAGE_DATA[currentImageIndex]) return;
            
            const currentImage = IMAGE_DATA[currentImageIndex];
            window.currentLocationMarker.setLngLat([currentImage.lon, currentImage.lat]);
        }
        
        function getDistance(lngLat1, lngLat2) {
            const R = 6371000;
            const dLat = (lngLat2[1] - lngLat1[1]) * Math.PI / 180;
            const dLon = (lngLat2[0] - lngLat1[0]) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lngLat1[1] * Math.PI / 180) * Math.cos(lngLat2[1] * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }



        
        // ===== 7) UI FUNCTIONS =====
        function updateUI() {
            document.getElementById('time').textContent = `${currentImageIndex + 1}/${IMAGE_DATA.length}`;
            document.getElementById('progress-bar').style.width = `${(currentImageIndex / (IMAGE_DATA.length - 1)) * 100}%`;
        }
        
        function showToast(msg, ms=1500, isError=false) {
            const t = document.getElementById('toast');
            t.textContent = msg; 
            t.className = isError ? 'toast error' : 'toast';
            t.style.display = 'block';
            clearTimeout(t._to); 
            t._to = setTimeout(() => t.style.display = 'none', ms);
        }
        
        function showLoading(message) {
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loading-text');
            loadingText.textContent = message;
            loading.style.display = 'block';
        }
        
        function hideLoading() {
            const loading = document.getElementById('loading');
            loading.style.display = 'none';
        }
        
        function updateDebugInfo(message) {
            const debugInfo = document.getElementById('debug-info');
            debugInfo.textContent = message;
            debugInfo.style.display = 'block';
            
            setTimeout(() => {
                debugInfo.style.display = 'none';
            }, 5000);
        }
        
        // ===== 8) EVENT HANDLERS =====
        function setupEventListeners() {
            // Navigation buttons
            document.getElementById('prevImage').addEventListener('click', () => {
                loadImage(currentImageIndex - 1, true);
            });
            
            document.getElementById('nextImage').addEventListener('click', () => {
                loadImage(currentImageIndex + 1, true);
            });
            
            // Reset view button
            document.getElementById('resetView').addEventListener('click', () => {
                loadImage(currentImageIndex, false);
                // Reset zoom to default
                currentFov = 75;
                camera.fov = currentFov;
                camera.updateProjectionMatrix();
                updateZoomDisplay();
            });
            
            // Zoom buttons
            document.getElementById('zoomIn').addEventListener('click', zoomIn);
            document.getElementById('zoomOut').addEventListener('click', zoomOut);
            
            // Progress bar click
            document.getElementById('progress-container').addEventListener('click', (e) => {
                const rect = e.currentTarget.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                const newIndex = Math.floor(percent * (IMAGE_DATA.length - 1));
                loadImage(newIndex, true);
            });
            
            // Touch events for mobile dragging
            const canvas = document.getElementById('canvas');
            let isDragging = false;
            let previousPosition = { x: 0, y: 0 };
            
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    previousPosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                }
                e.preventDefault();
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isDragging && sphere) {
                    const currentPosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                    
                    const deltaX = currentPosition.x - previousPosition.x;
                    const deltaY = currentPosition.y - previousPosition.y;
                    
panoGroup.rotation.y -= deltaX * 0.01;
panoGroup.rotation.x -= deltaY * 0.01;
                    
                    // Update current orientation
currentYaw = panoGroup.rotation.y;
currentPitch = panoGroup.rotation.x;
                    updateStatusBox(); // NEW
           
                    updateViewCone();
                    previousPosition = currentPosition;
                }
                e.preventDefault();
            });
            
            canvas.addEventListener('touchend', () => {
                isDragging = false;
            });
            
            // Pinch to zoom
            canvas.addEventListener('touchmove', handlePinchZoom);
            
            // Mouse events for desktop dragging
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousPosition = {
                    x: e.clientX,
                    y: e.clientY
                };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging && sphere) {
                    const currentPosition = {
                        x: e.clientX,
                        y: e.clientY
                    };
                    
                    const deltaX = currentPosition.x - previousPosition.x;
                    const deltaY = currentPosition.y - previousPosition.y;
                    
panoGroup.rotation.y -= deltaX * 0.01;
panoGroup.rotation.x -= deltaY * 0.01;
                    
                    // Update current orientation
currentYaw = panoGroup.rotation.y;
currentPitch = panoGroup.rotation.x;
                    updateStatusBox(); // NEW
               
                    updateViewCone();
                    previousPosition = currentPosition;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // Mouse wheel zoom
            canvas.addEventListener('wheel', handleWheelZoom);
        }
        
        // ===== 9) INITIALIZATION =====
async function init() {
  try {
    IMAGE_DATA = await loadManifest('https://lalaland.mx/manifest.json');
    ROUTE_YAWS = computeRouteYawSimple(IMAGE_DATA, CAMERA_HEADING_OFFSET_DEG);

    initThreeJS();
    setupEventListeners();
    initMap();

    // Show something immediately
    await loadImage(0, /*preserveOrientation*/ false);

    // Start background preloading once the first image is on screen
    startBackgroundPreload();

  } catch (err) {
    console.error(err);
    showToast('Failed to load manifest.json', 4000, true);
  }
}
        
        // Start the application
        init();
    </script>
</body>
</html>
