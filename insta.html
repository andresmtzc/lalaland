<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Image Viewer with Mapbox</title>
    <!-- Mapbox GL JS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
        <!-- ROTATE HERE -- OFFSET RING OFFSET TEXTURE -->
    <style>
      
        :root {
            --bg: #0b1020;
            --panel: #0f172a;
            --accent: #22d3ee;
            --muted: #94a3b8;
            --error: #ef4444;
            --success: #10b981;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            height: 100vh;
            margin: 0;
            background: var(--bg);
            color: #e2e8f0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
            overflow: hidden;
            touch-action: none;
        }
        
        .app {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 16px;
            height: 50px;
            border-bottom: 1px solid #1f2937;
            background: linear-gradient(180deg, rgba(34,211,238,0.06), rgba(34,211,238,0));
            flex-shrink: 0;
        }
        
        header h1 {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
        }
        
        header .pill {
            padding: 4px 8px;
            border: 1px solid #233045;
            border-radius: 999px;
            font-size: 11px;
            color: var(--muted);
        }
        
        #map {
            width: 100%;
            height: 50vh;
            flex-shrink: 0;
        }
        
        .viewer-container {
            position: relative;
            background: var(--panel);
            height: 50vh;
            flex-grow: 1;
            overflow: hidden;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        
        .legend {
            position: absolute;
            bottom: 12px;
            left: 12px;
            font-size: 12px;
            color: #cbd5e1;
            background: rgba(2,6,23,.65);
            border: 1px solid #263247;
            padding: 8px 10px;
            border-radius: 10px;
            z-index: 4;
        }
        
        .toast {
            position: absolute;
            top: 60px;
            right: 16px;
            background: #0b1220;
            border: 1px solid #263247;
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 12px;
            color: #cbd5e1;
            z-index: 10;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .toast.error {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.3);
        }
        
        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top: 4px solid var(--accent);
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
.image-controls {
  position: absolute;
  bottom: -15px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  background: transparent;
  z-index: 20;
  
}

.navigation-ring {
  position: relative;
  width: 160px;
  height: 160px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transform-style: preserve-3d;
  /* Add these properties to prevent text selection */
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
      background: transparent;
}

.nav-button.ring-button {
  position: absolute;
  width: 40px;
  height: 40px;
  border: none;
  border-radius: 50%;
  background: transparent;
  color: #22d3ee;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
  cursor: pointer;
  transition: all 0.3s ease;
  z-index: 2;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  /* Add a wrapper transform for positioning */
  transform: translateX(-50%);
}

/* Up button at the top */
#nextImage.ring-button {
  top: 15px;
  left: 50%;
}

/* Down button at the bottom */
#prevImage.ring-button {
  bottom: 15px;
  left: 50%;
}

.nav-button.ring-button:hover {

  /* Use scale only for hover, not transform */
  transform: translateX(-50%) scale(1.3);
}


.nav-button.ring-button:active {
  transform: translateX(-50%) scale(0.95);
}
 
/* Time indicator at bottom right */
.time {
  position: fixed;
  right:20px;
  bottom: 20px;
  color: #22d3ee;
  font-weight: 600;
  font-size: 14px;
  font-variant-numeric: tabular-nums;
  z-index: 25;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
        
button.icon {
  width: 50px;
  height: 50px;
  background: linear-gradient(145deg, rgba(34, 211, 238, 0.15), rgba(34, 211, 238, 0.05));
  border: 2px solid rgba(34, 211, 238, 0.4);
  color: #22d3ee;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  font-weight: bold;
}
        
button.icon:hover {
  background: linear-gradient(145deg, rgba(34, 211, 238, 0.25), rgba(34, 211, 238, 0.15));
  border-color: #22d3ee;
  transform: scale(1.1);
  box-shadow: 0 0 15px rgba(34, 211, 238, 0.4);
}

button.icon:active {
  transform: scale(0.95);
}

button.icon:disabled {
  opacity: 0.3;
  
  transform: none;
  box-shadow: none;
}
        

        
        .current-location-marker {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ff6b6b;
            border: 2px solid white;
            box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.5);
        }
        
        .zoom-controls {
            position: absolute;
            right: 10px;
            top: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 5;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #263247;
            color: #cbd5e1;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
        }
        
        .zoom-btn:hover {
            background: rgba(0,0,0,0.7);
        }
        


        
        @media (min-width: 768px) {
            .app {
                flex-direction: row;
                height: 100vh;
            }
            
            header {
                display: none;
            }
            
            #map {
                width: 50%;
                height: 100%;
            }
            
            .viewer-container {
                width: 50%;
                height: 100%;
            }
            
            .mobile-header {
                display: none;
            }
        }
        
        .mobile-header {
            padding: 10px;
            text-align: center;
            background: rgba(15,23,42,.7);
            border-bottom: 1px solid #1f2937;
        }
        
        .debug-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
            display: none;
        }
        
        .zoom-level {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
        }

        /* Minimal UI: hide legend, toast, debug box, zoom-status box */
.legend,
.toast,
#toast,
.debug-info,
.zoom-level,
.zoom-controls {
  display: none !important;
}

        .image-controls,
        .navigation-ring,
        .nav-button.ring-button {
            pointer-events: none;
        }

                .nav-button.ring-button {
            pointer-events: auto;
        }

                .event-capture-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 15;
            pointer-events: auto;
            display: none;
        }
    </style>
</head>
<body>
    <div class="app">
        <div id="map"></div>
        
        <div class="viewer-container">
            <div class="mobile-header">
                <h2>360° Viewer</h2>
            </div>
            
            <canvas id="canvas"></canvas>
            
            <!-- Add a transparent overlay for capturing events -->
            <div class="event-capture-overlay" id="eventOverlay"></div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div id="loading-text">Loading 360° images...</div>
            </div>
            
            <div class="legend">
                Drag to look around. Pinch to zoom. Tap on the map to navigate.
            </div>
            
            <div class="toast" id="toast"></div>
            
            <div class="debug-info" id="debug-info"></div>
            
            <div class="zoom-level" id="zoom-level">Zoom: 75°</div>
            
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomIn">+</button>
                <button class="zoom-btn" id="zoomOut">-</button>
            </div>
            
            <div class="image-controls" id="imageControls">
                <div class="navigation-ring">
                    <button class="nav-button ring-button" id="nextImage">▲</button>
                    <button class="nav-button ring-button" id="prevImage">▼</button>
                </div>
            </div>
            
            <div class="time" id="time">1/12</div>
        </div>
    </div>


    <script>
        // ===== 0) CONFIG =====
        const MAPBOX_TOKEN = 'pk.eyJ1IjoiYW5kcmVzbXR6YyIsImEiOiJjbWN4ZWZvc3MwNjNjMnJwd3h6ZXdyOGJoIn0.ahgRYAxpOnGnnqOjQvJZTA';
        
        // Image data with coordinates and orientation
         let IMAGE_DATA = [];
        
          async function loadManifest(url) {
  try {
    const u = new URL(url, location.href);
    u.searchParams.set('t', Date.now()); // evita caché en desarrollo
    const res = await fetch(u.toString(), { method: 'GET', cache: 'no-store' });

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`HTTP ${res.status} ${res.statusText} – Body: ${text?.slice(0, 200)}`);
    }

    const jsonText = await res.text();
    let arr = null;

    try {
      const json = JSON.parse(jsonText);

      if (Array.isArray(json)) {
        arr = json;
      } else if (Array.isArray(json.images)) {
        arr = json.images;
      } else if (Array.isArray(json.nodes)) {
        arr = json.nodes;
      }

      if (!arr) {
        throw new Error('Invalid format: expected array or { images: [] } or { nodes: [] }');
      }

      const base = new URL('.', u); // base path del manifest
      arr = arr.map((it, i) => {
        ['id', 'src', 'lat', 'lon'].forEach((k) => {
          if (!(k in it)) throw new Error(`Item ${i} missing key "${k}"`);
        });
        const srcAbs = /^https?:\/\//i.test(it.src) ? it.src : new URL(it.src, base).toString();
        return { ...it, src: srcAbs };
      });

      showToast(`Manifest OK (${arr.length} frames)`, 1500);
      return arr;
    } catch (parseErr) {
      throw new Error(
        `JSON.parse error: ${parseErr.message}\nPrimeros 200 chars:\n${jsonText.slice(0, 200)}`
      );
    }
  } catch (e) {
    console.error('[loadManifest] Error:', e);
    showToast(e.message, 6000, true);
    throw e;
  }
}
  
// === Route-based heading ===
const CAMERA_HEADING_OFFSET_DEG = 0; // if your camera points 90° right of travel, set 90

// Bearing in degrees (0..360, 0 = North, clockwise)
function bearingDeg(fromLat, fromLon, toLat, toLon) {
  const φ1 = degToRad(fromLat), φ2 = degToRad(toLat);
  const Δλ = degToRad(toLon - fromLon);
  const y = Math.sin(Δλ) * Math.cos(φ2);
  const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
  return (radToDeg(Math.atan2(y, x)) + 360) % 360;
}

// Compute per-point route headings (simple forward bearing)
function computeRouteYawSimple(data, offsetDeg = 0) {
  const n = data.length;
  const yaw = new Array(n).fill(0);
  if (n === 0) return yaw;
  if (n === 1) { yaw[0] = (offsetDeg + 360) % 360; return yaw; }

  for (let i = 0; i < n; i++) {
    let a = i, b = Math.min(i + 1, n - 1);
    if (i === n - 1) { a = n - 2; b = n - 1; } // last one looks back
    const A = data[a], B = data[b];
    const h = bearingDeg(A.lat, A.lon, B.lat, B.lon);
    yaw[i] = (h + offsetDeg + 360) % 360;
  }
  return yaw;
}
  
  //ROTATE HERE TO FIX TEXTURE
// Globals cache of route headings
let ROUTE_YAWS = [];
// Fine-tune how the pano texture is aligned relative to the route
const TEXTURE_YAW_OFFSET_DEG = -25; // tweak (+/-). 0 means no shift. OFFSET HERE
let panoGroup = null;              // parent of the sphere
        let currentImageIndex = 0;
        let currentYaw = 0;
        let currentPitch = 0;
        let currentFov = 75; // Default field of view
        let preloadedImages = {}; // Cache for preloaded images
        let preloadQueue = []; // Queue for preloading images
        let bgPreloadStarted = false;
        
        let coneZoomDebounce = null;

function requestConeUpdateAfterZoom(delay = 180) {
  clearTimeout(coneZoomDebounce);
  coneZoomDebounce = setTimeout(() => {
    updateViewCone();   // uses currentFov -> horizontal FOV
  }, delay);
}

        // ===== 1) MAPBOX INIT =====
        mapboxgl.accessToken = MAPBOX_TOKEN;
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/dark-v11',
            center: [-100.29, 25.66],
            zoom: 17,
            attributionControl: false
        });
        
        // Add navigation control
        map.addControl(new mapboxgl.NavigationControl({ showCompass: false }), 'top-left');
        
        // ===== 2) THREE.JS SETUP =====
        let scene, camera, renderer, sphere;
        
        function setRendererSize() {
  const canvas = document.getElementById('canvas');
  const dpr = Math.min(window.devicePixelRatio || 1, 2); // cap at 2 for perf
  renderer.setPixelRatio(dpr);
  renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
}

function canvasAspect() {
  const canvas = document.getElementById('canvas');
  return canvas.clientWidth / canvas.clientHeight;
}

function initThreeJS() {
  scene = new THREE.Scene();
  panoGroup = new THREE.Group();
  scene.add(panoGroup);

  const canvas = document.getElementById('canvas');

  // Camera uses client sizes (not offset) for accuracy on mobile
  camera = new THREE.PerspectiveCamera(currentFov, canvasAspect(), 0.1, 1000);
  camera.position.set(0, 0, 0.1);

  // High-quality renderer; preserveDrawingBuffer=false for better perf
  renderer = new THREE.WebGLRenderer({
    canvas,
    antialias: true,
    alpha: false,
    powerPreference: 'high-performance',
    preserveDrawingBuffer: false
  });

  // IMPORTANT for Three r0.132: sRGB
  renderer.outputEncoding = THREE.sRGBEncoding;

  // Size at device pixel ratio
  setRendererSize();

  window.addEventListener('resize', onWindowResize);

  updateZoomDisplay();
  animate();
}
        
 function onWindowResize() {
  camera.aspect = canvasAspect();
  camera.updateProjectionMatrix();
  setRendererSize();
  updateViewCone();
}
        
function animate() {
    requestAnimationFrame(animate);
    
    // Update navigation ring rotation
    updateNavigationRing();
    
    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}
        
        // ===== 3) IMAGE PRELOADING =====
function startBackgroundPreload(concurrency = 3) {
  if (bgPreloadStarted || IMAGE_DATA.length <= 1) return;
  bgPreloadStarted = true;

  const order = buildPreloadOrder(currentImageIndex, IMAGE_DATA.length);
  runPreloadPool(order, concurrency);
}

// Interleave around the current index: +1, -1, +2, -2, ...
function buildPreloadOrder(center, total) {
  const seq = [];
  for (let step = 1; step < total; step++) {
    const fwd = center + step;
    const back = center - step;
    if (fwd < total) seq.push(fwd);
    if (back >= 0) seq.push(back);
  }
  return seq;
}

function runPreloadPool(indexes, concurrency) {
  let i = 0;
  const workers = Array.from({ length: Math.min(concurrency, indexes.length) }, async () => {
    while (i < indexes.length) {
      const idx = indexes[i++];
      await preloadOne(idx).catch(() => {});
    }
  });
  // No await needed; let it run in the background
  Promise.all(workers).then(() => {
    // optional: showToast('Preload complete', 1200);
  });
}

function preloadOne(index) {
  return new Promise((resolve) => {
    const item = IMAGE_DATA[index];
    if (!item) return resolve();

    const src = item.src;
    if (preloadedImages[src]) return resolve(); // already cached

    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.onload = () => {
      preloadedImages[src] = img;
      resolve();
    };
    img.onerror = () => resolve(); // swallow errors; keep going
    // important: no cache-busting here
    img.src = src;

    // Decode hint (non-blocking) if supported
    if (img.decode) img.decode().catch(() => {});
  });
}
        

        
        function preloadAdjacentImages() {
            // Clear any existing preload queue
            preloadQueue = [];
            
            // Preload next and previous images for smoother navigation
            const prevIndex = currentImageIndex - 1;
            const nextIndex = currentImageIndex + 1;
            
            if (prevIndex >= 0 && !preloadedImages[IMAGE_DATA[prevIndex].src]) {
                preloadQueue.push(prevIndex);
            }
            
            if (nextIndex < IMAGE_DATA.length && !preloadedImages[IMAGE_DATA[nextIndex].src]) {
                preloadQueue.push(nextIndex);
            }
            
            // Process preload queue
            processPreloadQueue();
        }
        
        function processPreloadQueue() {
            if (preloadQueue.length === 0) return;
            
            const index = preloadQueue.shift();
            const imageData = IMAGE_DATA[index];
            
            if (preloadedImages[imageData.src]) {
                // Image already loaded, process next in queue
                processPreloadQueue();
                return;
            }
            
            const img = new Image();
            img.crossOrigin = "Anonymous";
            
            img.onload = function() {
                preloadedImages[imageData.src] = img;
                processPreloadQueue();
            };
            
            img.onerror = function() {
                console.error('Failed to preload image:', imageData.src);
                processPreloadQueue();
            };
            
            // Add a timestamp to bypass cache
            const timestamp = new Date().getTime();
            const url = imageData.src + '?t=' + timestamp;
            img.src = url;
        }
        
        // ===== ORIENTATION HELPERS =====
function radToDeg(r) { return r * 180 / Math.PI; }
function degToRad(d) { return d * Math.PI / 180; }
function normDeg(d) { d = d % 360; return d < 0 ? d + 360 : d; }
function fmt(n, p = 1) { return Number.isFinite(n) ? n.toFixed(p) : '—'; }

// ===== NAVIGATION RING =====
function updateNavigationRing() {
    const ring = document.querySelector('.navigation-ring');
    if (!ring) return;
    
    const RING_OFFSET_DEG = 70; // tweak this to rotate the whole circle

    // Convert yaw to degrees for full 360° rotation with 90° offset . starting offset circle //ROTATE HERE TO FIX RING
    const yawDegrees = THREE.MathUtils.radToDeg(currentYaw) + RING_OFFSET_DEG;
    
    // Apply full rotation to match the sphere with offset
    ring.style.transform = `perspective(500px) rotateZ(${-yawDegrees}deg)`;
    
    // Add subtle tilt based on pitch for 3D effect
    const tilt = THREE.MathUtils.radToDeg(currentPitch) * 0.5;
    ring.style.transform += ` rotateX(${tilt}deg)`;
    
    // Subtle position adjustment for parallax effect
    const translateX = Math.sin(currentYaw) * 0;
    const translateY = Math.sin(currentPitch) * 0;
    ring.style.transform += ` translate(${translateX}px, ${translateY}px)`;
}


function getHorizontalFovDeg() {
  // THREE.PerspectiveCamera FOV is vertical; convert to horizontal using aspect
  const vRad = THREE.MathUtils.degToRad(currentFov);
  const hRad = 2 * Math.atan(Math.tan(vRad / 2) * camera.aspect);
  return THREE.MathUtils.radToDeg(hRad);
}
  
// Forward geodesic (bearing+distance -> dest lon/lat)
function destFromBearingDistance(lat, lon, bearingDeg, distMeters) {
  const R = 6378137;
  const brng = degToRad(bearingDeg);
  const φ1 = degToRad(lat), λ1 = degToRad(lon);
  const φ2 = Math.asin(Math.sin(φ1) * Math.cos(distMeters / R) +
                       Math.cos(φ1) * Math.sin(distMeters / R) * Math.cos(brng));
  const λ2 = λ1 + Math.atan2(
    Math.sin(brng) * Math.sin(distMeters / R) * Math.cos(φ1),
    Math.cos(distMeters / R) - Math.sin(φ1) * Math.sin(φ2)
  );
  return [radToDeg(λ2), radToDeg(φ2)];
}

// Build a polygon ring for a FOV cone
function makeViewConeRing(lat, lon, headingDeg, fovDeg, radiusMeters = 40, steps = 24) {
  const half = Math.max(0, Math.min(179, fovDeg/2)); // guard
  const start = headingDeg - half;
  const end   = headingDeg + half;

  const ring = [[lon, lat]]; // start at origin
  for (let s = 0; s <= steps; s++) {
    const t = s / steps;
    const brg = start + (end - start) * t;
    ring.push(destFromBearingDistance(lat, lon, brg, radiusMeters));
  }
  ring.push([lon, lat]); // close polygon
  return ring;
}

// Update the map polygon to match current yaw + FOV CONE DIMENSION
function updateViewCone() {
  if (!map || !map.getSource('view-cone')) return;
  const img = IMAGE_DATA[currentImageIndex];
  if (!img) return;

  const headingDeg = normDeg(radToDeg(currentYaw));
  const fovH = getHorizontalFovDeg();         // use horizontal FOV for the cone
  const ring = makeViewConeRing(img.lat, img.lon, headingDeg, fovH, /*radius*/ 7, /*steps*/24);

  map.getSource('view-cone').setData({
    type: 'Feature',
    geometry: { type: 'Polygon', coordinates: [ring] }
  });
}

// Updates the box in the top-right with FOV, Yaw, Pitch, Heading, Lat/Lon
// Updates the box with FOV, dynamic Heading, Pitch, and the frame's original Heading + Lat/Lon
function updateStatusBox() {
  const el = document.getElementById('zoom-level');
  if (!el) return;

  const img = IMAGE_DATA[currentImageIndex] || {};
  const yawDegDynamic = normDeg(radToDeg(currentYaw));
  const pitchDeg = radToDeg(currentPitch);
  const frameHeading =
    (ROUTE_YAWS[currentImageIndex] != null) ? ROUTE_YAWS[currentImageIndex] : null;

  el.innerHTML = `
    <div style="line-height:1.25">
      <div><strong>Zoom</strong>: ${fmt(currentFov,0)}°</div>
      <div><strong>Heading</strong>: ${fmt(yawDegDynamic)}°</div>
      <div><strong>Pitch</strong>: ${fmt(pitchDeg)}°</div>
      <div><strong>Route Heading</strong>: ${frameHeading != null ? fmt(frameHeading) + '°' : '—'}</div>
      <div><strong>Lat</strong>: ${img.lat != null ? fmt(img.lat,6) : '—'}</div>
      <div><strong>Lon</strong>: ${img.lon != null ? fmt(img.lon,6) : '—'}</div>
    </div>
  `;
}  
 

// 16-point compass for nice labels (N, NNE, NE, ...)
function degToCompass(d) {
    const dirs = ["N","NNE","NE","ENE","E","ESE","SE","SSE",
                  "S","SSW","SW","WSW","W","WNW","NW","NNW"];
    const i = Math.round(normDeg(d) / 22.5) % 16;
    return dirs[i];
}



        // ===== 4) ZOOM CONTROLS =====
        function zoomIn() {
            if (currentFov > 30) {
                currentFov -= 5;
                camera.fov = currentFov;
                camera.updateProjectionMatrix();
                updateZoomDisplay();
                  requestConeUpdateAfterZoom();
                showToast(`Zoomed in (${currentFov}°)`, 1000);
            }
        }
        
        function zoomOut() {
            if (currentFov < 120) {
                currentFov += 5;
                camera.fov = currentFov;
                camera.updateProjectionMatrix();
                updateZoomDisplay();
                  requestConeUpdateAfterZoom();
                showToast(`Zoomed out (${currentFov}°)`, 1000);
            }
        }
        
function updateZoomDisplay() {
    document.getElementById('zoom-level').textContent = `Zoom: ${currentFov}°`;
    updateStatusBox(); // NEW
}
        
        function handlePinchZoom(e) {
            if (e.touches.length !== 2) return;
            
            e.preventDefault();
              requestConeUpdateAfterZoom();
            
            // Calculate distance between two fingers
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const distance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            if (!this.lastPinchDistance) {
                this.lastPinchDistance = distance;
                return;
            }
            
            // Determine zoom direction
            const zoomFactor = distance / this.lastPinchDistance;
            
            if (zoomFactor > 1.05) {
                // Pinch out - zoom in
                zoomIn();
                this.lastPinchDistance = distance;
            } else if (zoomFactor < 0.95) {
                // Pinch in - zoom out
                zoomOut();
                this.lastPinchDistance = distance;
            }
        }
        
        function handleWheelZoom(e) {
            e.preventDefault();
            
            if (e.deltaY < 0) {
                // Scroll up - zoom in
                zoomIn();
            } else {
                // Scroll down - zoom out
                zoomOut();
            }
        }
        
        // ===== 5) IMAGE LOADING =====
        function loadImage(index, preserveOrientation = false) {
            if (index < 0 || index >= IMAGE_DATA.length) return;
            
            showLoading('Loading image ' + (index + 1) + '...');
            currentImageIndex = index;
            
            const imageData = IMAGE_DATA[index];
            updateDebugInfo('Loading: ' + imageData.src);
            
            // Check if image is already preloaded
            if (preloadedImages[imageData.src]) {
                updateDebugInfo('Using preloaded image: ' + imageData.src);
                applyImageToScene(preloadedImages[imageData.src], imageData, preserveOrientation);
                preloadAdjacentImages(); // Preload next/previous images
                return;
            }
            
            // Image not preloaded, load it now
            const img = new Image();
            img.crossOrigin = "Anonymous";
            
            img.onload = function() {
                updateDebugInfo('Image loaded successfully: ' + imageData.src);
                preloadedImages[imageData.src] = img; // Add to cache
                applyImageToScene(img, imageData, preserveOrientation);
                preloadAdjacentImages(); // Preload next/previous images
            };
             
            img.onerror = function() {
                updateDebugInfo('Failed to load: ' + imageData.src);
                showToast('Failed to load image ' + (index + 1), 3000, true);
                
                // Try to load the next image if this one fails
                setTimeout(() => {
                    if (index < IMAGE_DATA.length - 1) {
                        loadImage(index + 1, preserveOrientation);
                    } else if (index > 0) {
                        loadImage(index - 1, preserveOrientation);
                    } else {
                        hideLoading();
                        showToast('All images failed to load', 5000, true);
                    }
                }, 1000);
            };
            
            // Add a timestamp to bypass cache
            const timestamp = new Date().getTime();
            const url = imageData.src + '?t=' + timestamp;
            updateDebugInfo('Trying to load: ' + url);
            
            img.src = url;
        }
        
function isPOT(n) { return (n & (n - 1)) === 0; }

function setupTexture(img) {
  const tex = new THREE.Texture(img);
  // For Three r0.132
  tex.encoding = THREE.sRGBEncoding;

  const pot = isPOT(img.width) && isPOT(img.height);
  if (pot) {
    tex.generateMipmaps = true;
    tex.minFilter = THREE.LinearMipmapLinearFilter;
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
  } else {
    tex.generateMipmaps = false;
    tex.minFilter = THREE.LinearFilter;
  }
  tex.magFilter = THREE.LinearFilter;
  tex.needsUpdate = true;
  return tex;
}

       function applyImageToScene(img, imageData, preserveOrientation) {
  // Remove previous sphere (but keep the group)
  if (sphere) {
    panoGroup.remove(sphere);
    sphere.geometry?.dispose?.();
    sphere.material?.map?.dispose?.();
    sphere.material?.dispose?.();
  }

  const geometry = new THREE.SphereGeometry(100, 60, 40);
  geometry.scale(-1, 1, 1);

const texture = setupTexture(img);
const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });

  sphere = new THREE.Mesh(geometry, material);

  // Add sphere inside the group
  panoGroup.add(sphere);

  // --- Apply the constant visual shift ONLY to the sphere ---
  const textureOffsetRad = THREE.MathUtils.degToRad(TEXTURE_YAW_OFFSET_DEG);
  sphere.rotation.set(0, textureOffsetRad, 0);
  // If it looks mirrored, use: sphere.rotation.set(0, -textureOffsetRad, 0);

  // --- Apply logical heading ONLY to the group ---
  if (preserveOrientation) {
    panoGroup.rotation.y = currentYaw;
    panoGroup.rotation.x = currentPitch;
  } else {
    const headingDeg = ROUTE_YAWS[currentImageIndex] ?? 0;
    const headingRad = THREE.MathUtils.degToRad(headingDeg);
    panoGroup.rotation.y = headingRad;  // or -headingRad if needed globally
    panoGroup.rotation.x = 0;
    currentYaw = panoGroup.rotation.y;
    currentPitch = 0;
  }

  updateUI();
  updateMapMarker();
  updateStatusBox();
   updateNavigationButtons(); // Add this line
   updateNavigationRing();

updateViewCone();
  hideLoading();
  showToast('Loaded image ' + (currentImageIndex + 1), 1000);
}

        
        // ===== 6) MAP FUNCTIONS =====
        function initMap() {
  const coordinates = IMAGE_DATA.map(img => [img.lon, img.lat]);

  const addMapContent = () => {
    // Don’t add twice if we ever re-run
    if (!map.getSource('route')) {
      map.addSource('route', {
        type: 'geojson',
        data: {
          type: 'Feature',
          properties: {},
          geometry: { type: 'LineString', coordinates }
        }
      });

      map.addLayer({
        id: 'route',
        type: 'line',
        source: 'route',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 'line-color': '#22d3ee', 'line-width': 4, 'line-opacity': 0.7 }
      });
    }

if (!map.getSource('view-cone')) {
  map.addSource('view-cone', {
    type: 'geojson',
    data: { type: 'Feature', geometry: { type: 'Polygon', coordinates: [[[0,0],[0,0],[0,0]]] } }
  });

  map.addLayer({
    id: 'view-cone-fill',
    type: 'fill',
    source: 'view-cone',
    paint: { 'fill-color': '#ff6b6b', 'fill-opacity': 0.2 }
  });

  map.addLayer({
    id: 'view-cone-outline',
    type: 'line',
    source: 'view-cone',
    paint: { 'line-color': '#ff6b6b', 'line-width': 2, 'line-opacity': 0.8 }
  });

  updateViewCone(); // <- draw once the source exists
}


    // Fit once we know coords and style is ready
    if (coordinates.length) {
      const bounds = coordinates.reduce(
        (b, c) => b.extend(c),
        new mapboxgl.LngLatBounds(coordinates[0], coordinates[0])
      );
      map.fitBounds(bounds, { padding: 40, maxZoom: 19.5 });
    }
 
    // Create click-through DOM markers (once)
    if (!window.__imageMarkersAdded) {
      IMAGE_DATA.forEach((img, index) => {
        const el = document.createElement('div');
        el.className = 'map-marker';
        el.innerHTML = `<div style="width:16px;height:16px;border-radius:50%;background:#22d3ee;border:2px solid white;cursor:pointer;"></div>`;
        el.dataset.index = index;
        new mapboxgl.Marker(el).setLngLat([img.lon, img.lat]).addTo(map);
        el.addEventListener('click', () => loadImage(index, true));
      });
      window.__imageMarkersAdded = true;
    }

    // Current location marker (create once, then we update it elsewhere)
    if (!window.currentLocationMarker && IMAGE_DATA[0]) {
      const currentLocationEl = document.createElement('div');
      currentLocationEl.className = 'current-location-marker';
      window.currentLocationMarker = new mapboxgl.Marker(currentLocationEl)
        .setLngLat([IMAGE_DATA[0].lon, IMAGE_DATA[0].lat])
        .addTo(map);
    }

    // Map click handler (only add once)
    if (!window.__mapClickBound) {
      map.on('click', (e) => {
        const features = map.queryRenderedFeatures(e.point);
        const clickedOnMarker = features.some(f => f.layer && f.layer.id && (f.layer.id.includes('marker') || (f.source && f.source.includes && f.source.includes('marker'))));
        if (clickedOnMarker) return;

        const clicked = e.lngLat;
        let closestIndex = 0, minDist = Infinity;
        IMAGE_DATA.forEach((img, i) => {
          const d = getDistance(clicked, [img.lon, img.lat]);
          if (d < minDist) { minDist = d; closestIndex = i; }
        });
        if (minDist < 15) loadImage(closestIndex, true);
      });
      window.__mapClickBound = true;
    }
  };

  // If the map’s style is already loaded, run now; otherwise wait once
  if (map.isStyleLoaded && map.isStyleLoaded()) {
    addMapContent();
  } else {
    map.once('load', addMapContent);
  }
}

        
        function updateMapMarker() {
            if (!window.currentLocationMarker || !IMAGE_DATA[currentImageIndex]) return;
            
            const currentImage = IMAGE_DATA[currentImageIndex];
            window.currentLocationMarker.setLngLat([currentImage.lon, currentImage.lat]);
        }
        
        function getDistance(lngLat1, lngLat2) {
            const R = 6371000;
            const dLat = (lngLat2[1] - lngLat1[1]) * Math.PI / 180;
            const dLon = (lngLat2[0] - lngLat1[0]) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lngLat1[1] * Math.PI / 180) * Math.cos(lngLat2[1] * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }


function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevImage');
    const nextBtn = document.getElementById('nextImage');
    
    // Update disabled states
    prevBtn.disabled = currentImageIndex <= 0;
    nextBtn.disabled = currentImageIndex >= IMAGE_DATA.length - 1;
    
    // Add visual feedback for disabled state
    if (prevBtn.disabled) {
        prevBtn.style.opacity = "0.3";
        prevBtn.style.cursor = "pointer";
    } else {
        prevBtn.style.opacity = "1";
        prevBtn.style.cursor = "pointer";
    }
    
    if (nextBtn.disabled) {
        nextBtn.style.opacity = "0.3";
        nextBtn.style.cursor = "pointer";
    } else {
        nextBtn.style.opacity = "1";
        nextBtn.style.cursor = "pointer";
    }
}
        
        // ===== 7) UI FUNCTIONS =====
function updateUI() {
  const timeEl = document.getElementById('time');
  if (timeEl) timeEl.textContent = `${currentImageIndex + 1}/${IMAGE_DATA.length}`;
    updateNavigationButtons(); // Add this line
}
        
        function showToast(msg, ms=1500, isError=false) {
            const t = document.getElementById('toast');
            t.textContent = msg; 
            t.className = isError ? 'toast error' : 'toast';
            t.style.display = 'block';
            clearTimeout(t._to); 
            t._to = setTimeout(() => t.style.display = 'none', ms);
        }
        
        function showLoading(message) {
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loading-text');
            loadingText.textContent = message;
            loading.style.display = 'block';
        }
        
        function hideLoading() {
            const loading = document.getElementById('loading');
            loading.style.display = 'none';
        }
        
        function updateDebugInfo(message) {
            const debugInfo = document.getElementById('debug-info');
            debugInfo.textContent = message;
            debugInfo.style.display = 'block';
            
            setTimeout(() => {
                debugInfo.style.display = 'none';
            }, 5000);
        }
        
        // ===== 8) EVENT HANDLERS =====
function setupEventListeners() {
    // Navigation buttons
    document.getElementById('prevImage').addEventListener('click', () => {
        loadImage(currentImageIndex - 1, true);
    });
    
    document.getElementById('nextImage').addEventListener('click', () => {
        loadImage(currentImageIndex + 1, true);
    });
    
    // Zoom buttons
    document.getElementById('zoomIn').addEventListener('click', zoomIn);
    document.getElementById('zoomOut').addEventListener('click', zoomOut);
    
    // Touch events for mobile dragging
    const canvas = document.getElementById('canvas');
    let isDragging = false;
    let previousPosition = { x: 0, y: 0 };
    
    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            isDragging = true;
            previousPosition = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
        }
        e.preventDefault();
    });
    
    canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length === 1 && isDragging && sphere) {
            const currentPosition = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
            
            const deltaX = currentPosition.x - previousPosition.x;
            const deltaY = currentPosition.y - previousPosition.y;
            
            panoGroup.rotation.y -= deltaX * 0.01;
            panoGroup.rotation.x -= deltaY * 0.01;
            
            currentYaw = panoGroup.rotation.y;
            currentPitch = panoGroup.rotation.x;
            updateStatusBox();
            updateNavigationRing();
            updateViewCone();
            previousPosition = currentPosition;
        }
        e.preventDefault();
    });
    
    canvas.addEventListener('touchend', () => {
        isDragging = false;
        canvas.lastPinchDistance = null;
        updateViewCone();
    });
    
    // Pinch to zoom
    canvas.addEventListener('touchmove', handlePinchZoom);
    
    // Mouse events for desktop dragging - FIXED VERSION
    let isMouseDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    
    // Only attach mouse events to the canvas, not the window
    canvas.addEventListener('mousedown', (e) => {
        isMouseDragging = true;
        previousMousePosition = {
            x: e.clientX,
            y: e.clientY
        };
        e.preventDefault();
    });
    
    // Use document instead of window to capture mouse events everywhere
    document.addEventListener('mousemove', (e) => {
        if (isMouseDragging && sphere) {
            const currentPosition = {
                x: e.clientX,
                y: e.clientY
            };
            
            const deltaX = currentPosition.x - previousMousePosition.x;
            const deltaY = currentPosition.y - previousMousePosition.y;
            
            panoGroup.rotation.y -= deltaX * 0.01;
            panoGroup.rotation.x -= deltaY * 0.01;
            
            currentYaw = panoGroup.rotation.y;
            currentPitch = panoGroup.rotation.x;
            updateStatusBox();
            updateNavigationRing();
            updateViewCone();
            
            previousMousePosition = currentPosition;
        }
    });
    
    document.addEventListener('mouseup', () => {
        isMouseDragging = false;
    });
    
    // Mouse wheel zoom
    canvas.addEventListener('wheel', handleWheelZoom);
    
    // Prevent navigation elements from interfering with drag
    const navElements = document.querySelectorAll('.navigation-ring, .image-controls');
    navElements.forEach(element => {
        element.addEventListener('mousedown', (e) => {
            e.stopPropagation(); // Prevent drag start
        });
    });
}
        // ===== 9) INITIALIZATION =====
async function init() {
  try {
    IMAGE_DATA = await loadManifest('https://lalaland.mx/manifest2.json');
    ROUTE_YAWS = computeRouteYawSimple(IMAGE_DATA, CAMERA_HEADING_OFFSET_DEG);

    initThreeJS();
    setupEventListeners();
    initMap();

    // Show something immediately
    await loadImage(0, /*preserveOrientation*/ false);

    // Start background preloading once the first image is on screen
    startBackgroundPreload();
 
  } catch (err) {
    console.error(err);
    showToast('Failed to load manifest.json', 4000, true);
  }
}
          
          // Toggle debug panels with the "D" key (case-insensitive)
  document.addEventListener('keydown', (e) => {
    // ignore when typing in inputs/textareas
    const t = e.target;
    const typing = t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.tagName === 'SELECT' || t.isContentEditable);
    if (typing) return;

    if (e.key === 'd' || e.key === 'D') {
      const ids = ['zoom-level', 'debug-info'];
      ids.forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        const hidden = getComputedStyle(el).display === 'none';
        el.style.setProperty('display', hidden ? 'block' : 'none', 'important');
      });
    } 
  });
        // Start the application
        init();
    </script>
</body>
</html>
