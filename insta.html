<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DIY Street-View on Mapbox ‚Äì HLS + GPX</title>
  <!-- Mapbox GL JS -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
  <!-- Pannellum (lightweight 360 viewer) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css" />
  <script src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"></script>
  <!-- hls.js for .m3u8 playback on Chrome/Firefox/Edge -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root { --bg:#0b1020; --panel:#0f172a; --accent:#22d3ee; --muted:#94a3b8; }
    html,body { height:100%; margin:0; background:var(--bg); color:#e2e8f0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .app { display:grid; grid-template-columns: 1fr min(52vw, 860px); grid-template-rows: 64px 1fr; height:100%; }
    header { grid-column: 1 / -1; display:flex; align-items:center; gap:12px; padding:0 16px; border-bottom:1px solid #1f2937; background:linear-gradient(180deg, rgba(34,211,238,0.06), rgba(34,211,238,0)); }
    header h1 { font-size:16px; font-weight:600; margin:0; }
    header .pill { padding:6px 10px; border:1px solid #233045; border-radius:999px; font-size:12px; color:var(--muted); }
    #map { width:100%; height:100%; }
    .right { position:relative; background:var(--panel); border-left:1px solid #1f2937; }
    .right header { position:absolute; inset:0 auto auto 0; height:72px; z-index:5; display:flex; flex-wrap:wrap; align-items:center; gap:8px; padding:6px 12px; border-bottom:1px solid #1f2937; background:rgba(15,23,42,.7); backdrop-filter: blur(8px); }
    .controls { display:flex; gap:8px; margin-left:auto; }
    button.icon { background:#0b1220; border:1px solid #263247; color:#cbd5e1; padding:6px 10px; border-radius:10px; cursor:pointer; }
    button.icon:hover { border-color:#33445f; }
    input.url { background:#0b1220; border:1px solid #263247; color:#cbd5e1; padding:6px 10px; border-radius:10px; outline:none; }
    #pano { position:absolute; top:72px; left:0; right:0; bottom:0; }
    .legend { position:absolute; bottom:12px; left:12px; font-size:12px; color:#cbd5e1; background:rgba(2,6,23,.65); border:1px solid #263247; padding:8px 10px; border-radius:10px; z-index:4; }
    .legend b { color:#e2e8f0; }
    .toast { position:absolute; top:84px; right:16px; background:#0b1220; border:1px solid #263247; padding:10px 12px; border-radius:10px; font-size:12px; color:#cbd5e1; z-index: 10; display:none; }
    .row { display:flex; gap:6px; width:100%; align-items:center; }
    .grow { flex:1 1 auto; }
    .loading { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; }
    .status { font-size: 12px; color: var(--muted); margin-top: 8px; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>DIY Street-View ‚Ä¢ Mapbox + Pannellum (Seek-only)</h1>
      <span class="pill">Click blue line ‚Üí seek 360¬∞ video (video never plays)</span>
      <span class="pill">Local MP4 or remote HLS + GPX</span>
    </header>

    <div id="map"></div>

    <section class="right">
      <header>
        <div id="panoTitle" class="grow">No video loaded</div>
        <div class="row">
          <input id="videoUrl" class="url grow" placeholder="https://lalaland.mx/output.m3u8" value="https://lalaland.mx/output.m3u8" />
          <input id="gpxUrl"   class="url grow" placeholder="https://lalaland.mx/army(1).gpx" value="https://lalaland.mx/army(1).gpx" />
          <button class="icon" id="loadRemote">Load URLs</button>
        </div>
        <div class="controls">
          <label class="icon" for="videoInput" title="Load 360¬∞ MP4 locally">üìπ Load MP4</label>
          <input id="videoInput" type="file" accept="video/*" style="display:none" />
          <label class="icon" for="gpxInput" title="Load GPX file">üó∫Ô∏è Load GPX</label>
          <input id="gpxInput" type="file" accept=".gpx,application/gpx+xml" style="display:none" />
          <button class="icon" id="back5" title="Seek ‚àí5s">‚àí5s</button>
          <button class="icon" id="fwd5" title="Seek +5s">+5s</button>
        </div>
      </header>
      <div id="pano"></div>
      <video id="vid" playsinline muted preload="metadata" crossorigin="anonymous" style="display:none"></video>
      <div class="legend" id="legend">Load a video (MP4 or HLS URL), then a GPX (file or URL). Click the route to jump around the 360¬∞ video. Video stays <b>paused</b>‚Äîwe only <b>seek</b>.</div>
      <div class="toast" id="toast"></div>
      <div class="loading" id="loading">
        <div>Loading resources...</div>
        <div class="status" id="loadingStatus"></div>
      </div>
    </section>
  </div>

  <script>
    // ===== 0) CONFIG =====
    const MAPBOX_TOKEN = 'pk.eyJ1IjoiYW5kcmVzbXR6YyIsImEiOiJjbWN4ZWZvc3MwNjNjMnJwd3h6ZXdyOGJoIn0.ahgRYAxpOnGnnqOjQvJZTA';

    // Start empty: no route until GPX or telemetry is loaded
    let ROUTE_COORDS = [];
    let ROUTE_TIMES  = null; // ms since route start (optional)

    // ===== 1) MAPBOX INIT =====
    mapboxgl.accessToken = MAPBOX_TOKEN;
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/dark-v11',
      center: [-100, 25], // neutral center until data loads
      zoom: 3,
      attributionControl: true
    });
    map.addControl(new mapboxgl.NavigationControl({ visualizePitch: true }), 'top-left');

    // ===== 2) HELPER: distances, bearings, projection =====
    const R = 6371000; // Earth radius (m)
    function toRad(d){ return d * Math.PI / 180; }
    function haversine(a, b){
      const [lon1, lat1] = a, [lon2, lat2] = b;
      const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1);
      const s1 = Math.sin(dLat/2), s2 = Math.sin(dLon/2);
      const h = s1*s1 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*s2*s2;
      return 2 * R * Math.asin(Math.sqrt(h));
    }
    function bearingDeg(a, b){
      const [lon1, lat1] = a.map(toRad), [lon2, lat2] = b.map(toRad);
      const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
      const x = Math.cos(lat1)*Math.cos(lat2)*Math.cos(lon2 - lon1) - Math.sin(lat1)*Math.sin(lat2);
      return (Math.atan2(y, x) * 180/Math.PI + 360) % 360;
    }

    let cumDist = [0];
    let segBearing = [];
    function recomputeRouteMetrics(){
      cumDist = [0]; segBearing = [];
      for (let i=1;i<ROUTE_COORDS.length;i++){
        const d = haversine(ROUTE_COORDS[i-1], ROUTE_COORDS[i]);
        cumDist.push(cumDist[i-1] + d);
        segBearing.push(bearingDeg(ROUTE_COORDS[i-1], ROUTE_COORDS[i]));
      }
    }
    function totalDistance(){ return cumDist[cumDist.length-1] || 0; }

    function nearestOnRoute(lngLat){
      function ll2m([lon,lat]){
        const x = lon * 20037508.34 / 180;
        const y = Math.log(Math.tan((90+lat)*Math.PI/360)) / (Math.PI/180);
        return [x, y * 20037508.34 / 180];
      }
      const p = ll2m([lngLat.lng, lngLat.lat]);
      let best = { meters:0, idx:0, frac:0, minDist: Infinity };
      for(let i=1;i<ROUTE_COORDS.length;i++){
        const aLL = ROUTE_COORDS[i-1], bLL = ROUTE_COORDS[i];
        const a = ll2m(aLL), b = ll2m(bLL);
        const ab = [b[0]-a[0], b[1]-a[1]];
        const ap = [p[0]-a[0], p[1]-a[1]];
        const ab2 = ab[0]*ab[0] + ab[1]*ab[1];
        const t = Math.max(0, Math.min(1, (ap[0]*ab[0] + ap[1]*ab[1]) / ab2));
        const proj = [a[0] + t*ab[0], a[1] + t*ab[1]];
        const dx = p[0]-proj[0], dy = p[1]-proj[1];
        const dist2 = dx*dx + dy*dy;
        if (dist2 < best.minDist){
          const segLenMeters = haversine(aLL, bLL);
          const meters = cumDist[i-1] + segLenMeters * t;
          best = { meters, idx:i-1, frac:t, minDist: dist2 };
        }
      }
      return best;
    }

    function chainageToTimeMs(meters, videoDurationMs){
      if (Array.isArray(ROUTE_TIMES) && ROUTE_TIMES.length === ROUTE_COORDS.length){
        let i = 0; while (i < cumDist.length-1 && cumDist[i+1] < meters) i++;
        const d0 = cumDist[i], d1 = cumDist[i+1] ?? cumDist[i];
        const t0 = ROUTE_TIMES[i], t1 = ROUTE_TIMES[i+1] ?? ROUTE_TIMES[i];
        if (d1 === d0) return t0;
        const f = (meters - d0) / (d1 - d0);
        return t0 + f * (t1 - t0);
      }
      const f = Math.max(0, Math.min(1, meters / (totalDistance() || 1)));
      return f * videoDurationMs;
    }
    function chainageToBearing(meters){
      let i = 0; while (i < cumDist.length-1 && cumDist[i+1] < meters) i++;
      return segBearing[Math.max(0, Math.min(segBearing.length-1, i))] || 0;
    }

    // ===== 3) Map + sources ===== 
    map.on('load', () => {
      buildRouteLayers();
      map.on('click', (e)=> {
        if (!ROUTE_COORDS || ROUTE_COORDS.length < 2){ showToast('Load GPX or URL first'); return; }
        const n = nearestOnRoute(e.lngLat);
        if (!isFinite(n.meters)) return;
        seekToChainage(n.meters);
      });
    });

    function buildRouteLayers(){
      if (!Array.isArray(ROUTE_COORDS) || ROUTE_COORDS.length < 2){
        if (map.getLayer('route')) map.removeLayer('route');
        if (map.getSource('route')) map.removeSource('route');
        return;
      }
      const srcData = { type:'Feature', geometry:{ type:'LineString', coordinates: ROUTE_COORDS }, properties:{} };
      if (map.getSource('route')) {
        map.getSource('route').setData(srcData);
      } else {
        map.addSource('route', { type:'geojson', data: srcData });
        map.addLayer({ id:'route', type:'line', source:'route',
          paint:{ 'line-color':'#22d3ee', 'line-width':4, 'line-opacity':0.85 } });
      }
      recomputeRouteMetrics();

      // Fly/fit to route
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      ROUTE_COORDS.forEach(c=>{ minX=Math.min(minX,c[0]); minY=Math.min(minY,c[1]); maxX=Math.max(maxX,c[0]); maxY=Math.max(maxY,c[1]); });
      if (isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY)){
        const spanLng = Math.abs(maxX-minX), spanLat = Math.abs(maxY-minY);
        if (spanLng < 0.0005 && spanLat < 0.0005){ map.flyTo({ center: ROUTE_COORDS[0], zoom: 17, speed: 0.7 }); }
        else { map.fitBounds([[minX,minY],[maxX,maxY]], { padding: 60, duration: 700 }); }
      }
    }

    // ===== 4) Pannellum video viewer (video kept paused) =====
    const vid = document.getElementById('vid');
    let viewer = null;
    let videoReady = false;

    vid.addEventListener('loadedmetadata', () => {
      document.getElementById('panoTitle').textContent = `Video duration: ${vid.duration.toFixed(1)}s`;
      if (!viewer){
        viewer = pannellum.viewer('pano', {
          type: 'equirectangular',
          panorama: vid,
          autoLoad: true,
          yaw: 0,
          hfov: 95,
          showControls: true
        });
      }
      videoReady = true;
      // Prime first frame so Pannellum shows immediately
      vid.muted = true;
      vid.play().then(()=> setTimeout(()=> vid.pause(), 120)).catch((e)=>{
        console.warn("Auto-play prevented:", e);
        showToast("Click the video to enable playback");
      });
    });

    function seekToChainage(meters){
      if (!videoReady || !isFinite(vid.duration)) { showToast('Video not ready yet'); return; }
      const tMs = chainageToTimeMs(meters, vid.duration * 1000);
      const yaw = chainageToBearing(meters);
      vid.currentTime = Math.max(0, Math.min(vid.duration - 0.05, tMs/1000));
      if (viewer) try { viewer.setYaw(yaw); } catch(e){}
      showToast(`Seek: ${(tMs/1000).toFixed(1)}s ‚Ä¢ Yaw ${Math.round(yaw)}¬∞`);
    }

    // Nudge buttons
    document.getElementById('back5').onclick = () => { if (!videoReady) return; vid.currentTime = Math.max(0, vid.currentTime - 5); vid.pause(); };
    document.getElementById('fwd5').onclick = () => { if (!videoReady) return; vid.currentTime = Math.min(vid.duration - 0.05, vid.currentTime + 5); vid.pause(); };

    function showToast(msg, ms=1500){
      const t = document.getElementById('toast');
      t.textContent = msg; t.style.display = 'block';
      clearTimeout(t._to); t._to = setTimeout(()=> t.style.display='none', ms);
    }
    
    function showLoading(message) {
      const loading = document.getElementById('loading');
      const status = document.getElementById('loadingStatus');
      status.textContent = message;
      loading.style.display = 'block';
    }
    
    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }

    // === Loaders: local files ===
    (function attachLocalLoaders(){
      const videoInput = document.getElementById('videoInput');
      videoInput.addEventListener('change', (e)=>{
        const file = e.target.files?.[0]; if(!file) return;
        const url = URL.createObjectURL(file);
        if (window._hls) { window._hls.destroy(); window._hls = null; }
        vid.innerHTML=''; const src=document.createElement('source'); src.src=url; src.type=file.type||'video/mp4'; vid.appendChild(src);
        try{ vid.load(); }catch(_){}
        document.getElementById('panoTitle').textContent = `Video: ${file.name}`;
        showToast('Video loaded. Now load a GPX (file or URL).');
      });

      const gpxInput = document.getElementById('gpxInput');
      gpxInput.addEventListener('change', async (e)=>{
        const file = e.target.files?.[0]; if(!file) return;
        showLoading('Parsing GPX file...');
        try {
          const text = await file.text();
          const {coords, times} = parseGpxText(text);
          if (!coords || coords.length < 2){ showToast('Need at least 2 GPX points'); return; }
          ROUTE_COORDS = coords;
          ROUTE_TIMES  = (times && times.length === coords.length) ? times.map(t=> t - times[0]) : null;
          buildRouteLayers();
          showToast('GPX loaded');
        } catch (e) {
          showToast('Error loading GPX: ' + e.message);
        } finally {
          hideLoading();
        }
      });
    })();

    // === Loaders: URLs (HLS + GPX) ===
    document.getElementById('loadRemote').onclick = async () => {
      const m3u8 = document.getElementById('videoUrl').value.trim();
      const gpx  = document.getElementById('gpxUrl').value.trim();

      // 1) Load HLS (or MP4 URL if you paste one)
      if (m3u8) {
        showLoading('Loading video...');
        if (window._hls) { window._hls.destroy(); window._hls = null; }
        vid.pause(); vid.removeAttribute('src'); vid.innerHTML = '';

        const isM3U8 = /\.m3u8(\?|$)/i.test(m3u8);
        if (isM3U8 && window.Hls && Hls.isSupported()) {
          window._hls = new Hls({ maxBufferLength: 10 });
          window._hls.loadSource(m3u8);
          window._hls.attachMedia(vid);
          window._hls.on(Hls.Events.MANIFEST_PARSED, () => {
            vid.muted = true;
            vid.play().then(()=> setTimeout(()=> {
              vid.pause();
              hideLoading();
            }, 120)).catch((e) => {
              console.warn("Auto-play prevented:", e);
              hideLoading();
              showToast("Click the video to enable playback");
            });
          });
          window._hls.on(Hls.Events.ERROR, (event, data) => {
            console.error("HLS Error:", data);
            if (data.fatal) {
              hideLoading();
              showToast("Error loading video. Check CORS settings.");
            }
          });
        } else if (vid.canPlayType('application/vnd.apple.mpegurl') || !isM3U8) {
          // Safari HLS, or direct MP4 URL
          const src = document.createElement('source');
          src.src = m3u8; src.type = isM3U8 ? 'application/vnd.apple.mpegurl' : 'video/mp4';
          vid.appendChild(src);
          vid.load();
          hideLoading();
        } else {
          hideLoading();
          showToast('HLS not supported in this browser');
        }
        document.getElementById('panoTitle').textContent = `Video: ${m3u8}`;
      }

      // 2) Load GPX from URL
      if (gpx) {
        showLoading('Loading GPX...');
        try {
          // Encode URL properly
          const enc = encodeURI(gpx);
          const resp = await fetch(enc, { cache: 'no-store' });
          if (!resp.ok) throw new Error('GPX fetch failed: ' + resp.status);
          const text = await resp.text();
          const { coords, times } = parseGpxText(text);
          if (!coords || coords.length < 2) throw new Error('No valid track points found');
          ROUTE_COORDS = coords;
          ROUTE_TIMES  = (times && times.length === coords.length) ? times.map(t=> t - times[0]) : null;
          buildRouteLayers();
          showToast('GPX loaded from URL');
        } catch (e) {
          console.warn(e);
          showToast('Could not load GPX URL: ' + e.message);
        } finally {
          hideLoading();
        }
      }
    };

    // === Utilities: GPX parser ===
    function parseGpxText(text){
      try{
        const xml = new DOMParser().parseFromString(text, 'application/xml');
        const pts = Array.from(xml.getElementsByTagName('trkpt'));
        const coords = []; const times = [];
        for (const p of pts){
          const lat = parseFloat(p.getAttribute('lat')); const lon = parseFloat(p.getAttribute('lon'));
          if (!isFinite(lat) || !isFinite(lon)) continue;
          coords.push([lon, lat]);
          const tEl = p.getElementsByTagName('time')[0];
          if (tEl && tEl.textContent){
            const t = Date.parse(tEl.textContent);
            times.push(isNaN(t)?null:t);
          }
        }
        return { coords, times: times.every(v=>v!=null)?times:null };
      }catch(e){ 
        console.error("GPX parsing error:", e);
        return { coords:null, times:null }; 
      }
    }
    
    // Auto-load the URLs on page load for testing
    window.addEventListener('load', () => {
      setTimeout(() => {
        document.getElementById('loadRemote').click();
      }, 1000);
    });
  </script>
</body>
</html>
