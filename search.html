<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Community Search Button Designer</title>
<style>
  :root{
    --stage: 620px;      /* canvas size */
    --btn: 56px;         /* center button size */
    --orbit-radius: 80;  /* starting radius (px) */
    --dot: 56px;         /* dot size */
    --mini-orbit-radius: 40; /* mini-dots orbit radius */
    --mini-dot: 24px;    /* mini-dot size */
    --rotate-deg: 0deg;  /* rotation applied to all dots */
  }

  * { box-sizing: border-box; }
  html, body {
    height: 100%;
    margin: 0;
    background: #0a0a0a;
    color: #eaeaea;
    font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }

  .wrap {
    min-height: 100%;
    display: grid;
    place-items: center;
    padding: 24px;
  }

  .panel { width: min(100%, 1200px); }

  h2 {
    font-size: 14px;
    letter-spacing: .06em;
    text-transform: uppercase;
    color: #60a5fa;
    margin: 24px 0 12px 0;
    font-weight: 600;
  }

  .controls {
    display: grid;
    gap: 12px;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    margin-bottom: 18px;
  }
  .control {
    background: #141414;
    border: 1px solid #242424;
    border-radius: 16px;
    padding: 12px 14px;
  }
  .control label {
    display: block;
    font-size: 12px;
    letter-spacing: .06em;
    text-transform: uppercase;
    color: #9aa0a6;
    margin-bottom: 8px;
  }
  .control input[type="range"]{ width:100%; }
  .control input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
  }

  /* Dot visibility checkboxes */
  .dot-toggles {
    background: #141414;
    border: 1px solid #242424;
    border-radius: 16px;
    padding: 16px;
    margin-bottom: 18px;
  }
  .dot-toggles h3 {
    margin: 0 0 12px 0;
    font-size: 12px;
    letter-spacing: .06em;
    text-transform: uppercase;
    color: #9aa0a6;
  }
  .toggle-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 8px;
  }
  .toggle-item {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .toggle-item input[type="checkbox"] {
    width: 16px;
    height: 16px;
    cursor: pointer;
  }
  .toggle-item label {
    font-size: 13px;
    color: #eaeaea;
    cursor: pointer;
    user-select: none;
  }

  .stage {
    width: var(--stage);
    height: var(--stage);
    position: relative;
    margin-inline: auto;
    user-select: none;
    touch-action: manipulation;
  }

  .rotator {
    position: absolute;
    inset: 0;
    transform-origin: 50% 50%;
    transform: rotate(var(--rotate-deg));
    transition: transform .12s ease;
  }

  .orbit-guide {
    position: absolute;
    width: calc(var(--orbit-radius) * 2px);
    height: calc(var(--orbit-radius) * 2px);
    left: 50%; top: 50%;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    border: 1px dashed #2c2c2c;
  }

  .dot-container {
    position: absolute;
    transform: translate(-50%, -50%);
  }

  .dot {
    width: var(--dot);
    height: var(--dot);
    border-radius: 50%;
    background: #fcfaf3;
    border: 0;
    padding: 0;
    cursor: pointer;
    outline: none;
    box-shadow: 0 2px 6px rgba(0,0,0,.15);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: 600;
    color: #1a1a1a;
    opacity: 0;
    transform: scale(0.4);
    transition: background .12s ease, transform .12s ease;
  }

  .dot-label {
    position: absolute;
    top: -24px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 11px;
    font-weight: 700;
    color: #60a5fa;
    background: #1a1a1a;
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid #2c2c2c;
    pointer-events: none;
  }

  .dot.visible {
    /* Don't set static opacity/transform - let animation handle it */
  }

  /* Animation when menu is active */
  .menu-active .dot.visible {
    animation: circle-pop-in 0.35s cubic-bezier(0.25, 1.25, 0.5, 1) forwards;
  }

  /* Mini-dots */
  .mini-dots-ring {
    position: absolute;
    width: calc(var(--mini-orbit-radius) * 2px);
    height: calc(var(--mini-orbit-radius) * 2px);
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
  }

  .mini-orbit-guide {
    position: absolute;
    inset: 0;
    border-radius: 50%;
    border: 1px dashed #3c3c3c;
  }

  .mini-dot-container {
    position: absolute;
    transform: translate(-50%, -50%);
  }

  .mini-dot {
    width: var(--mini-dot);
    height: var(--mini-dot);
    border-radius: 50%;
    background: #60a5fa;
    border: 0;
    padding: 0;
    cursor: pointer;
    outline: none;
    box-shadow: 0 2px 4px rgba(0,0,0,.2);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    font-weight: 700;
    color: #0a0a0a;
    opacity: 0;
    transform: scale(0.4);
    pointer-events: auto;
  }

  .mini-dot-label {
    position: absolute;
    top: -18px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 9px;
    font-weight: 700;
    color: #60a5fa;
    background: #1a1a1a;
    padding: 1px 4px;
    border-radius: 3px;
    border: 1px solid #2c2c2c;
    pointer-events: none;
  }

  .mini-dot.visible {
    /* Don't set static opacity/transform - let animation handle it */
  }

  .menu-active .mini-dot.visible {
    animation: circle-pop-in 0.35s cubic-bezier(0.25, 1.25, 0.5, 1) forwards;
  }

  @keyframes circle-pop-in {
    0% {
      transform: scale(0.4);
      opacity: 0;
    }
    60% {
      transform: scale(1.08);
    }
    100% {
      transform: scale(1);
      opacity: 1;
    }
  }

  .center-btn {
    position: absolute;
    width: var(--btn);
    height: var(--btn);
    left: 50%; top: 50%;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    background: #ffffff;
    color: #0a0a0a;
    border: none;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    transition: transform .12s ease;
  }

  .center-btn:hover {
    transform: translate(-50%, -50%) scale(1.05);
  }

  .center-btn:active {
    transform: translate(-50%, -50%) scale(0.95);
  }

  .info-box {
    background: #141414;
    border: 1px solid #242424;
    border-radius: 16px;
    padding: 16px;
    margin-top: 18px;
  }
  .info-box h3 {
    margin: 0 0 8px 0;
    font-size: 12px;
    letter-spacing: .06em;
    text-transform: uppercase;
    color: #9aa0a6;
  }
  .info-box p {
    margin: 4px 0;
    font-size: 13px;
    color: #eaeaea;
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel">

      <h2>ðŸ”˜ Main Dots Settings</h2>
      <div class="controls">
        <div class="control">
          <label for="count">Count: <span id="countOut">8</span></label>
          <input id="count" type="range" min="0" max="12" value="8" />
        </div>
        <div class="control">
          <label for="radius">Radius: <span id="radiusOut">80</span> px</label>
          <input id="radius" type="range" min="40" max="240" value="80" />
        </div>
        <div class="control">
          <label for="size">Dot size: <span id="sizeOut">56</span> px</label>
          <input id="size" type="range" min="20" max="120" value="56" />
        </div>
        <div class="control">
          <label for="rotation">Rotation: <span id="rotationOut">0</span>Â°</label>
          <input id="rotation" type="range" min="0" max="360" value="0" />
        </div>
        <div class="control">
          <label for="center">Center size: <span id="centerOut">56</span> px</label>
          <input id="center" type="range" min="40" max="120" value="56" />
        </div>
        <div class="control">
          <label for="delay">Animation delay: <span id="delayOut">150</span> ms</label>
          <input id="delay" type="range" min="50" max="500" value="150" step="50" />
        </div>
      </div>

      <div class="dot-toggles">
        <h3>Show/Hide Main Dots</h3>
        <div class="toggle-grid" id="toggleGrid">
          <!-- Checkboxes generated here -->
        </div>
      </div>

      <h2>âšª Mini-Dots Settings (Sub-Groups)</h2>
      <div class="controls">
        <div class="control">
          <label>
            <input type="checkbox" id="miniDotsEnabled" checked />
            Enable Mini-Dots
          </label>
        </div>
        <div class="control">
          <label for="miniCount">Mini count per dot: <span id="miniCountOut">4</span></label>
          <input id="miniCount" type="range" min="0" max="8" value="4" />
        </div>
        <div class="control">
          <label for="miniRadius">Mini radius: <span id="miniRadiusOut">40</span> px</label>
          <input id="miniRadius" type="range" min="20" max="80" value="40" />
        </div>
        <div class="control">
          <label for="miniSize">Mini size: <span id="miniSizeOut">24</span> px</label>
          <input id="miniSize" type="range" min="12" max="120" value="24" />
        </div>
        <div class="control">
          <label for="miniRotation">Mini rotation: <span id="miniRotationOut">0</span>Â°</label>
          <input id="miniRotation" type="range" min="0" max="360" value="0" />
        </div>
        <div class="control">
          <label for="miniDelay">Mini delay: <span id="miniDelayOut">100</span> ms</label>
          <input id="miniDelay" type="range" min="50" max="300" value="100" step="50" />
        </div>
      </div>

      <div class="dot-toggles">
        <h3>Enable Mini-Dots for Each Main Dot</h3>
        <div class="toggle-grid" id="miniToggleGrid">
          <!-- Checkboxes generated here -->
        </div>
      </div>

      <div class="dot-toggles">
        <h3>Show/Hide Individual Mini-Dots</h3>
        <div id="individualMiniControls">
          <!-- Individual mini-dot controls generated here -->
        </div>
      </div>

      <div class="stage" id="stage" aria-label="Orbit stage">
        <div class="rotator" id="rotator">
          <div class="orbit-guide" id="guide"></div>
          <!-- dots injected here -->
        </div>
        <button class="center-btn" id="centerBtn">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" stroke="currentColor">
            <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" stroke-width="2" stroke-linecap="round" fill="none"/>
          </svg>
        </button>
      </div>

      <div class="info-box">
        <h3>Instructions</h3>
        <p><strong>Main Dots:</strong> Click center to toggle animation, use checkboxes to show/hide</p>
        <p><strong>Mini-Dots:</strong> Each main dot can have its own ring of mini-dots (sub-groups)</p>
        <p><strong>Labels:</strong> Show position numbers (#1, #2, etc.) for easy identification</p>
        <p><strong>Design:</strong> Adjust all parameters in real-time to prototype your menu</p>
      </div>
    </div>
  </div>

<script>
(function(){
  const rotator   = document.getElementById('rotator');
  const stage     = document.getElementById('stage');
  const guide     = document.getElementById('guide');
  const centerBtn = document.getElementById('centerBtn');
  const toggleGrid = document.getElementById('toggleGrid');
  const miniToggleGrid = document.getElementById('miniToggleGrid');

  const countIn    = document.getElementById('count');
  const radiusIn   = document.getElementById('radius');
  const sizeIn     = document.getElementById('size');
  const rotationIn = document.getElementById('rotation');
  const centerIn   = document.getElementById('center');
  const delayIn    = document.getElementById('delay');

  const miniDotsEnabledIn = document.getElementById('miniDotsEnabled');
  const miniCountIn    = document.getElementById('miniCount');
  const miniRadiusIn   = document.getElementById('miniRadius');
  const miniSizeIn     = document.getElementById('miniSize');
  const miniRotationIn = document.getElementById('miniRotation');
  const miniDelayIn    = document.getElementById('miniDelay');

  const countOut    = document.getElementById('countOut');
  const radiusOut   = document.getElementById('radiusOut');
  const sizeOut     = document.getElementById('sizeOut');
  const rotationOut = document.getElementById('rotationOut');
  const centerOut   = document.getElementById('centerOut');
  const delayOut    = document.getElementById('delayOut');

  const miniCountOut    = document.getElementById('miniCountOut');
  const miniRadiusOut   = document.getElementById('miniRadiusOut');
  const miniSizeOut     = document.getElementById('miniSizeOut');
  const miniRotationOut = document.getElementById('miniRotationOut');
  const miniDelayOut    = document.getElementById('miniDelayOut');

  let count    = +countIn.value;
  let radius   = +radiusIn.value;
  let dotSize  = +sizeIn.value;
  let rotation = +rotationIn.value;
  let center   = +centerIn.value;
  let animDelay = +delayIn.value;

  let miniDotsEnabled = miniDotsEnabledIn.checked;
  let miniCount = +miniCountIn.value;
  let miniRadius = +miniRadiusIn.value;
  let miniSize = +miniSizeIn.value;
  let miniRotation = +miniRotationIn.value;
  let miniDelay = +miniDelayIn.value;

  let dots = [];
  let menuActive = false;
  let dotVisibility = {}; // Track which dots are visible
  let miniDotsVisibility = {}; // Track which dots have mini-dots enabled
  let individualMiniVisibility = {}; // Track which individual mini-dots are visible for each dot
  let miniDotsMirror = {}; // Track which dots have mirrored mini-dot rotation

  function setCSSVar(name, value){
    document.documentElement.style.setProperty(name, value);
  }

  function updateOutputs(){
    countOut.textContent    = count;
    radiusOut.textContent   = radius;
    sizeOut.textContent     = dotSize;
    rotationOut.textContent = rotation;
    centerOut.textContent   = center;
    delayOut.textContent    = animDelay;

    miniCountOut.textContent    = miniCount;
    miniRadiusOut.textContent   = miniRadius;
    miniSizeOut.textContent     = miniSize;
    miniRotationOut.textContent = miniRotation;
    miniDelayOut.textContent    = miniDelay;
  }

  function rebuildToggles(){
    toggleGrid.innerHTML = '';
    miniToggleGrid.innerHTML = '';

    for(let i=0; i<count; i++){
      // Main dot visibility toggle
      const item = document.createElement('div');
      item.className = 'toggle-item';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = `dot-${i}`;
      checkbox.checked = dotVisibility[i] !== false;
      checkbox.addEventListener('change', () => {
        dotVisibility[i] = checkbox.checked;
        updateDotVisibility(i);
      });

      const label = document.createElement('label');
      label.htmlFor = `dot-${i}`;
      label.textContent = `Dot ${i+1}`;

      item.appendChild(checkbox);
      item.appendChild(label);
      toggleGrid.appendChild(item);

      // Mini-dots enable toggle with mirror
      const miniItem = document.createElement('div');
      miniItem.style.display = 'flex';
      miniItem.style.alignItems = 'center';
      miniItem.style.gap = '6px';

      const miniCheckbox = document.createElement('input');
      miniCheckbox.type = 'checkbox';
      miniCheckbox.id = `mini-${i}`;
      miniCheckbox.checked = miniDotsVisibility[i] !== false;
      miniCheckbox.addEventListener('change', () => {
        miniDotsVisibility[i] = miniCheckbox.checked;
        rebuildMiniDots();
      });

      const miniLabel = document.createElement('label');
      miniLabel.htmlFor = `mini-${i}`;
      miniLabel.textContent = `D${i+1}`;
      miniLabel.style.cursor = 'pointer';
      miniLabel.style.userSelect = 'none';

      // Mirror checkbox for entire mini-ring
      const mirrorCheckbox = document.createElement('input');
      mirrorCheckbox.type = 'checkbox';
      mirrorCheckbox.id = `mirror-ring-${i}`;
      mirrorCheckbox.checked = miniDotsMirror[i] || false;
      mirrorCheckbox.addEventListener('change', () => {
        miniDotsMirror[i] = mirrorCheckbox.checked;
        const dot = dots[i];
        if(dot) positionMiniDots(dot);
      });

      const mirrorLabel = document.createElement('label');
      mirrorLabel.htmlFor = `mirror-ring-${i}`;
      mirrorLabel.textContent = 'ðŸ”„';
      mirrorLabel.title = 'Mirror mini-dots rotation';
      mirrorLabel.style.cursor = 'pointer';
      mirrorLabel.style.userSelect = 'none';

      miniItem.appendChild(miniCheckbox);
      miniItem.appendChild(miniLabel);
      miniItem.appendChild(mirrorCheckbox);
      miniItem.appendChild(mirrorLabel);
      miniToggleGrid.appendChild(miniItem);
    }

    rebuildIndividualMiniControls();
  }

  function rebuildIndividualMiniControls(){
    const container = document.getElementById('individualMiniControls');
    container.innerHTML = '';

    if(!miniDotsEnabled) return;

    for(let i=0; i<count; i++){
      if(miniDotsVisibility[i] === false) continue; // Skip if mini-dots not enabled for this dot

      // Initialize visibility for this dot's mini-dots if not exists
      if(!individualMiniVisibility[i]){
        individualMiniVisibility[i] = {};
        for(let j=0; j<miniCount; j++){
          individualMiniVisibility[i][j] = true; // Default all to visible
        }
      }

      const dotSection = document.createElement('div');
      dotSection.style.marginBottom = '12px';

      const heading = document.createElement('div');
      heading.style.fontSize = '11px';
      heading.style.fontWeight = '600';
      heading.style.color = '#9aa0a6';
      heading.style.marginBottom = '6px';
      heading.textContent = `Dot ${i+1} Mini-Dots:`;
      dotSection.appendChild(heading);

      const grid = document.createElement('div');
      grid.className = 'toggle-grid';

      for(let j=0; j<miniCount; j++){
        const item = document.createElement('div');
        item.className = 'toggle-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `mini-${i}-${j}`;
        checkbox.checked = individualMiniVisibility[i][j] !== false;
        checkbox.addEventListener('change', () => {
          individualMiniVisibility[i][j] = checkbox.checked;
        });

        const label = document.createElement('label');
        label.htmlFor = `mini-${i}-${j}`;
        label.textContent = `${i+1}.${j+1}`;

        item.appendChild(checkbox);
        item.appendChild(label);
        grid.appendChild(item);
      }

      dotSection.appendChild(grid);
      container.appendChild(dotSection);
    }
  }

  function updateDotVisibility(index){
    if(dots[index]){
      const dot = dots[index];
      const isVisible = dotVisibility[index] !== false;
      if(menuActive){
        if(isVisible){
          dot.el.classList.add('visible');
        } else {
          dot.el.classList.remove('visible');
          // Also hide mini-dots when main dot is hidden
          if(dot.miniDotsActive){
            dot.miniDots.forEach(({el}) => {
              el.classList.remove('visible');
            });
            dot.miniDotsActive = false;
          }
        }
      }
    }
    applyAnimationDelays();
  }

  function rebuildDots(){
    const oldVisibility = {...dotVisibility};
    const oldMiniVisibility = {...miniDotsVisibility};

    dots.forEach(d => d.container.remove());
    dots = [];
    dotVisibility = {};
    miniDotsVisibility = {};

    for(let i=0; i<count; i++){
      dotVisibility[i] = oldVisibility[i] !== false;
      miniDotsVisibility[i] = oldMiniVisibility[i] !== false;

      const container = document.createElement('div');
      container.className = 'dot-container';

      const el = document.createElement('button');
      el.className = 'dot';
      el.textContent = (i+1).toString();

      const label = document.createElement('div');
      label.className = 'dot-label';
      label.textContent = `#${i+1}`;

      // Add click handler to toggle mini-dots
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        // Only allow toggling mini-dots if the main dot is visible
        if(menuActive && miniDotsEnabled && miniDotsVisibility[i] !== false && dotVisibility[i] !== false){
          toggleMiniDotsForDot(i);
        }
      });

      container.appendChild(label);
      container.appendChild(el);
      rotator.appendChild(container);
      dots.push({el, container, i, miniDots: [], miniRing: null, miniDotsActive: false});
    }

    applySizes();
    positionDots();
    rebuildToggles();
    rebuildMiniDots();
    applyAnimationDelays();
  }

  function rebuildMiniDots(){
    // Remove all existing mini-dot rings
    dots.forEach(dot => {
      if(dot.miniRing){
        dot.miniRing.remove();
        dot.miniRing = null;
      }
      dot.miniDots = [];
      dot.miniDotsActive = false;
    });

    if(!miniDotsEnabled) return;

    dots.forEach((dot, dotIndex) => {
      // Only create mini-dots if enabled for this dot
      if(miniDotsVisibility[dotIndex] === false) return;

      const ring = document.createElement('div');
      ring.className = 'mini-dots-ring';
      ring.style.width = (miniRadius * 2) + 'px';
      ring.style.height = (miniRadius * 2) + 'px';

      const guide = document.createElement('div');
      guide.className = 'mini-orbit-guide';
      ring.appendChild(guide);

      for(let j=0; j<miniCount; j++){
        const miniContainer = document.createElement('div');
        miniContainer.className = 'mini-dot-container';

        const miniEl = document.createElement('button');
        miniEl.className = 'mini-dot';
        miniEl.textContent = (j+1).toString();

        const miniLabel = document.createElement('div');
        miniLabel.className = 'mini-dot-label';
        miniLabel.textContent = `${dotIndex+1}.${j+1}`;

        miniContainer.appendChild(miniLabel);
        miniContainer.appendChild(miniEl);
        ring.appendChild(miniContainer);

        dot.miniDots.push({el: miniEl, container: miniContainer, index: j});
      }

      dot.container.appendChild(ring);
      dot.miniRing = ring;
      positionMiniDots(dot);
    });

    applyMiniAnimationDelays();
    rebuildIndividualMiniControls();
  }

  function applySizes(){
    setCSSVar('--orbit-radius', radius);
    setCSSVar('--dot', dotSize+'px');
    setCSSVar('--btn', center+'px');
    setCSSVar('--mini-orbit-radius', miniRadius);
    setCSSVar('--mini-dot', miniSize+'px');
  }

  function positionDots(){
    const N = Math.max(1,count);
    const cx = stage.clientWidth/2;
    const cy = stage.clientHeight/2;
    dots.forEach(({container,i})=>{
      const angle = (2*Math.PI*i)/N;
      const x = cx + radius*Math.cos(angle);
      const y = cy + radius*Math.sin(angle);
      container.style.left = x+'px';
      container.style.top  = y+'px';
    });
  }

  function positionMiniDots(dot){
    const N = Math.max(1, miniCount);
    const ringCenterX = miniRadius;
    const ringCenterY = miniRadius;
    const dotIndex = dot.i;

    // Check if this entire mini-ring should be mirrored
    const shouldMirror = miniDotsMirror[dotIndex] || false;
    const effectiveRotation = shouldMirror ? -miniRotation : miniRotation;

    dot.miniDots.forEach(({container, index})=>{
      const baseAngle = (2*Math.PI*index)/N;
      const angle = baseAngle + (effectiveRotation * Math.PI / 180);
      const x = ringCenterX + miniRadius*Math.cos(angle);
      const y = ringCenterY + miniRadius*Math.sin(angle);
      container.style.left = x+'px';
      container.style.top  = y+'px';
    });
  }

  function applyAnimationDelays(){
    let visibleIndex = 0;
    dots.forEach(({el,i})=>{
      if(dotVisibility[i] !== false){
        el.style.animationDelay = (visibleIndex * animDelay) + 'ms';
        visibleIndex++;
      } else {
        el.style.animationDelay = '0ms';
      }
    });
  }

  function applyMiniAnimationDelays(){
    dots.forEach((dot, dotIndex) => {
      if(dotVisibility[dotIndex] === false || miniDotsVisibility[dotIndex] === false) return;

      const dotDelay = dotVisibility[dotIndex] !== false ?
        Array.from(dots).filter((d,idx) => idx < dotIndex && dotVisibility[idx] !== false).length * animDelay : 0;

      dot.miniDots.forEach(({el, index}) => {
        const totalDelay = dotDelay + animDelay + (index * miniDelay);
        el.style.animationDelay = totalDelay + 'ms';
      });
    });
  }

  function toggleMiniDotsForDot(dotIndex){
    const dot = dots[dotIndex];
    if(!dot || !dot.miniDots.length) return;

    dot.miniDotsActive = !dot.miniDotsActive;

    if(dot.miniDotsActive){
      // Show only enabled mini-dots
      dot.miniDots.forEach(({el, index}) => {
        if(individualMiniVisibility[dotIndex] && individualMiniVisibility[dotIndex][index] !== false){
          el.classList.add('visible');
        }
      });
    } else {
      // Hide all mini-dots
      dot.miniDots.forEach(({el}) => {
        el.classList.remove('visible');
      });
    }
  }

  function toggleMenu(){
    menuActive = !menuActive;
    if(menuActive){
      rotator.classList.add('menu-active');
      dots.forEach(({el, i}) => {
        if(dotVisibility[i] !== false){
          el.classList.add('visible');
        }
        // Don't automatically show mini-dots - wait for dot click
      });
    } else {
      rotator.classList.remove('menu-active');
      dots.forEach((dot) => {
        dot.el.classList.remove('visible');
        // Hide all mini-dots when menu closes
        if(dot.miniDotsActive){
          dot.miniDots.forEach(({el}) => {
            el.classList.remove('visible');
          });
          dot.miniDotsActive = false;
        }
      });
    }
  }

  centerBtn.addEventListener('click', toggleMenu);

  countIn.oninput = e=>{
    count=+e.target.value;
    updateOutputs();
    rebuildDots();
  }

  radiusIn.oninput= e=>{
    radius=+e.target.value;
    updateOutputs();
    applySizes();
    positionDots();
  }

  sizeIn.oninput  = e=>{
    dotSize=+e.target.value;
    updateOutputs();
    applySizes();
  }

  rotationIn.oninput = e=>{
    rotation=+e.target.value;
    updateOutputs();
    setCSSVar('--rotate-deg',rotation+'deg');
  };

  centerIn.oninput = e=>{
    center=+e.target.value;
    updateOutputs();
    applySizes();
  };

  delayIn.oninput = e=>{
    animDelay=+e.target.value;
    updateOutputs();
    applyAnimationDelays();
    applyMiniAnimationDelays();
  };

  miniDotsEnabledIn.onchange = e=>{
    miniDotsEnabled = e.target.checked;
    rebuildMiniDots();
  };

  miniCountIn.oninput = e=>{
    miniCount=+e.target.value;
    updateOutputs();
    rebuildMiniDots();
  };

  miniRadiusIn.oninput = e=>{
    miniRadius=+e.target.value;
    updateOutputs();
    applySizes();
    rebuildMiniDots();
  };

  miniSizeIn.oninput = e=>{
    miniSize=+e.target.value;
    updateOutputs();
    applySizes();
  };

  miniRotationIn.oninput = e=>{
    miniRotation=+e.target.value;
    updateOutputs();
    dots.forEach(dot => positionMiniDots(dot));
  };

  miniDelayIn.oninput = e=>{
    miniDelay=+e.target.value;
    updateOutputs();
    applyMiniAnimationDelays();
  };

  updateOutputs();
  rebuildDots();
  setCSSVar('--rotate-deg', rotation+'deg');
  window.addEventListener('resize', ()=>{
    positionDots();
    dots.forEach(dot => positionMiniDots(dot));
  });
})();
</script>
</body>
</html>
