<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lalaland Lots Map</title>
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    html, body { margin:0; padding:0; height:100%; }
    #map { height:100%; }
  </style>
</head>

<body>
<div id="map"></div>
 
<script>
  // LOAD SUPABASE
  window.supabaseReady = new Promise((resolve, reject) => {
    const supabaseScript = document.createElement('script');
    supabaseScript.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';
    supabaseScript.onload = () => {
      const { createClient } = supabase;
      window.supabaseClient = createClient(
        'https://jmoxbhodpvnlmtihcwvt.supabase.co',
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imptb3hiaG9kcHZubG10aWhjd3Z0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIxODM1MDgsImV4cCI6MjA2Nzc1OTUwOH0.-jP1akHIo9R4a2lD15byC5dESSGfeFHu8qlbmHteeJo'
      );
      console.log('✅ Supabase v2 client initialized');
      resolve();
    };
    supabaseScript.onerror = () => reject(new Error("❌ Failed to load Supabase script"));
    document.head.appendChild(supabaseScript);
  });
</script>
 
<script> 
// MAP INITIALIZE
let lotData = [];
 
fetch('https://lalaland.mx/mapbox.txt')
  .then(r => r.text())
  .then(token => {
    mapboxgl.accessToken = token.trim();
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/satellite-streets-v11',
      center: [-100.15994, 25.461823],
      zoom: 16.45
    });

map.on('load', async () => {
  await loadRoad(map, async () => {
    await loadLotsAsync(map); //Parse lots
    await window.supabaseReady; // ✅ Espera a que la librería esté lista
    await enrichLotsWithAvailability();
    animateLots(map, () => {
      addCustomImage(map);
    });
  });
});
  }); // ✅ this is the correct closing
</script>  

<script>
// ROAD: Add and animate road layer
const roadGeojson = {
  type: "FeatureCollection",
  features: [{
    type: "Feature",
    geometry: {
      type: "LineString",
      coordinates: [
        [-100.157757, 25.45803],
        [-100.157888, 25.458456],
        [-100.158984, 25.45995],
        [-100.15855, 25.460763],
        [-100.158634, 25.461454],
        [-100.158488, 25.462755],
        [-100.15872, 25.463296],
        [-100.16009, 25.465042],
        [-100.161556, 25.464865],
        [-100.163154, 25.465748],
        [-100.164051, 25.465707],
        [-100.165586, 25.466227],
        [-100.165558, 25.466294],
        [-100.164039, 25.46578],
        [-100.163133, 25.465821],
        [-100.161538, 25.46494],
        [-100.160053, 25.465119],
        [-100.158649, 25.463331],
        [-100.158407, 25.462765],
        [-100.158554, 25.461455],
        [-100.158468, 25.46075],
        [-100.158893, 25.459956],
        [-100.157814, 25.458486],
        [-100.15768, 25.458049]
      ]
    }
  }]
};

// Function to add and animate road layer
function loadRoad(map, cb) {
  map.addSource('road', { type: 'geojson', data: roadGeojson });
  map.addLayer({
    id: 'road',
    type: 'line',
    source: 'road',
    paint: { 'line-color': '#fff', 'line-width': 1, 'line-opacity': 0 }
  });

  let start = null;
  function animate(ts) {
    if (!start) start = ts;
    let p = Math.min((ts - start) / 500, 1);
    map.setPaintProperty('road', 'line-opacity', p);
    if (p < 1) requestAnimationFrame(animate);
    else cb();
  }
  requestAnimationFrame(animate);
}
</script>

<script>
// LOT PARSING: Load and parse lot data
function loadLotsAsync(map) {
  return fetch('https://lalaland.mx/lots.txt')
    .then(r => r.text())
    .then(txt => {
      lotData = parseLots(txt);
    });
}

function parseLots(text) {
  const lines = text.trim().split('\n');
  const lots = [], curr = null;
  let currentLot = null;
  lines.forEach(line => {
    line = line.trim();
    if (!line) return;
    if (!line.startsWith('{')) {
      if (currentLot) lots.push(currentLot);
      currentLot = { name: line, coords: [] };
    } else {
      const m = line.match(/lat:\s*([0-9.\-]+),\s*lng:\s*([0-9.\-]+)/);
      if (m && currentLot) currentLot.coords.push([+m[2], +m[1]]);
    }
  });
  if (currentLot) lots.push(currentLot);
  return lots;
}
</script>

<script>
  // FETCH AVAILABILITY SUPABASE
  //Async function to fetch availability info from Supabase and attach it to lotData
 async function enrichLotsWithAvailability() {
  if (!lotData || lotData.length === 0) {
    console.warn('lotData is empty, cannot enrich availability');
    return;
  }

  if (!window.supabaseClient) {
    console.error('Supabase client not initialized yet.');
    return;
  }
 
  const names = lotData.map(lot => lot.name);

  const { data, error } = await window.supabaseClient
    .from('lots')
    .select('lot_name, availability')
    .in('lot_name', names);

  if (error) {
    console.error('Error fetching lot availability from Supabase:', error);
    return;
  }

  if (data && data.length > 0) {
    data.forEach(row => {
      const lot = lotData.find(l => l.name === row.lot_name);
      if (lot) {
        lot.availability = row.availability ?? 'Unknown';
      }
    });
    console.log('Lot data enriched with availability:', lotData);
  } else {
    console.warn('No availability data returned for lots');
  }
}
</script>

<script>
// LOT ANIMATION: Animate the appearance of lots
function animateLots(map, cb) {
  const groups = 20,
    delay = 80,
    duration = 250,
    finalDelay = 200; 
  const fadeDuration = 500; 

  // Shuffle lots
  const shuffled = [...Array(lotData.length).keys()];
  shuffle(shuffled);

  // Divide into groups
  const groupArr = Array.from({ length: groups }, () => []);
  shuffled.forEach((i, idx) => groupArr[idx % groups].push(i));

  // Render each group with fade-in animation
  groupArr.forEach((g, i) => {
    const geojson = {
      type: "FeatureCollection",
      features: g.map((idx) => lotFeature(lotData[idx])),
    };
    map.addSource(`lot-group-${i}`, { type: "geojson", data: geojson });
    map.addLayer({
      id: `lot-group-${i}`,
      type: "line",
      source: `lot-group-${i}`,
      paint: {
        "line-color": "#fff",
        "line-width": 1,
        "line-opacity": 0,
        "line-opacity-transition": { duration: fadeDuration },
      },
    });
    setTimeout(
      () => map.setPaintProperty(`lot-group-${i}`, "line-opacity", 1),
      i * delay
    );
  });

  // Add final lots layer (initially transparent but visible)
  const finalGeojson = {
    type: "FeatureCollection",
    features: lotData.map((lot) => lotFeature(lot)),
  };
  map.addSource("lots-final", { type: "geojson", data: finalGeojson });
  map.addLayer({
    id: "lots-final",
    type: "line",
    source: "lots-final",
    layout: { visibility: "visible" },
    paint: {
      "line-color": "#fff",
      "line-width": 1,
      "line-opacity": 0,
      "line-opacity-transition": { duration: fadeDuration },
    },
  });

  // After all groups have faded in & paused, fade in final lots, then fade out all groups simultaneously
  setTimeout(() => {
    // Fade in final lots
    map.setPaintProperty("lots-final", "line-opacity", 1);

    setTimeout(() => {
      // Fade out all lot groups simultaneously
      groupArr.forEach((_, i) => {
        const id = `lot-group-${i}`;
        if (map.getLayer(id)) {
          map.setPaintProperty(id, "line-opacity", 0);
        }
      });

      // Remove all lot groups after fade out duration and call callback
      setTimeout(() => {
        groupArr.forEach((_, i) => {
          const id = `lot-group-${i}`;
          if (map.getLayer(id)) map.removeLayer(id);
          if (map.getSource(id)) map.removeSource(id);
        });
        if (cb) cb();
      }, fadeDuration);
    }, finalDelay + fadeDuration); // Wait for fade-in and extra delay before fading out groups
  }, groups * delay + duration);
}

// Helpers unchanged HERE COLOR IS ADDED DEPENDING ON AVAILABILITY
function lotFeature(lot) {
  const c = [...lot.coords];
  if (c[0][0] !== c[c.length - 1][0] || c[0][1] !== c[c.length - 1][1]) c.push(c[0]);
  return {
    type: "Feature",
    geometry: { type: "Polygon", coordinates: [c] },
    properties: { name: lot.name },
  };
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}
 
</script>

<script>
// DRONE IMAGE - Add custom recent drone satellite image as a raster layer
function addCustomImage(map) {
  // Coordinates for the custom drone image (georeferenced)
  const imageBounds = [
    [-100.16483, 25.467111], // Top-left corner [lng, lat]
    [-100.154874, 25.467111], // Top-right corner [lng, lat]
    [-100.154874, 25.457155], // Bottom-right corner [lng, lat]
    [-100.16483, 25.457155],  // Bottom-left corner [lng, lat]
  ];

  map.addSource('drone-satellite', { 
    type: 'image',
    url: 'https://lalaland.mx/santte2.jpg', // Your drone image URL
    coordinates: imageBounds // Set the coordinates for where the image will be placed
  });

map.addLayer({
  id: 'drone-satellite-layer',
  type: 'raster',
  source: 'drone-satellite',
  paint: {
    'raster-opacity': 0
  }
}, 'road');  // Insert BELOW 'road' layer, so roads are on top

// Then fade in opacity as you do
fadeInImage(map);
}

// Fade-in effect for the image (opacity increases gradually from 0 to 1)
function fadeInImage(map) {
  let opacity = 0;
  const interval = setInterval(() => {
    opacity += 0.05;  // Increase opacity gradually
    if (opacity >= 1) {
      opacity = 1;
      clearInterval(interval); // Stop once opacity reaches 1
    }
    map.setPaintProperty('drone-satellite-layer', 'raster-opacity', opacity);
  }, 50); // Adjust the interval for smoother or faster fade-in
} 
</script> 

</body>
</html> 
