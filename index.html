
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lalaland Lots Map</title>
<link href="https://fonts.googleapis.com/css2?family=Barlow+Condensed:wght@400;600;700" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />

  <script>
    // Font loading handler (runs before DOMContentLoaded)
    document.fonts.ready.then(() => {
      document.body.classList.add('fonts-loaded');
    }).catch(() => {
      document.body.classList.add('fonts-loaded'); // Fallback if fonts fail
    });
  </script>

  <style>
    html, body { margin:0; padding:0; height:100%; font-family: 'Barlow Condensed', Arial, sans-serif; }
    #map { height:100%; }

  .mapboxgl-ctrl.mapboxgl-ctrl-attrib {
  position: absolute;
}

.mapboxgl-ctrl-logo {
  transform: scale(0.8) !important;
  opacity:0.6;
}


.logo-wrapper {
  position: fixed;
  top: 24px;
  left: 24px;
  background-color:#1A1A1A;
  padding: 2px;
  padding-bottom:0px;
  border-radius:0px;
  z-index: 9999;
}

.logo-wrapper path {
  fill: #ff8400; 
}


.logo-wrapper img {
  height: 40px;
  width: auto;
}


#lotModal {
  display: none;
  position: fixed;
  background: #fcfaf3;
  border-radius: 12px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.25);
  z-index: 9999;
  opacity: 0;
  transition: all 0.3s ease;
  width: calc(100% - 40px);

  border: 1px solid #d8cbbc;
  overflow: hidden;
  top: 20px;
  left: 50%;
  transform: translateX(-50%) translateY(-30px);
}

#lotModal.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

@media (max-width: 767px) {
  #lotModal:not(.expanded) {
    height: 40%;
    width: calc(100% - 40px);
    max-width: none;
  }
}

@media (min-width: 768px) {
  #lotModal:not(.expanded) {
    position: fixed;
    top: 50%;
    left: 30vw;
    width: 360px;
    height: 70%;
    max-height: 620px;
    transform: translate(-50%, -50%);
  }
  #lotModal.expanded {
    position: fixed;
    top: 50%;
    left: 30vw;
    width: 56%;
    height: 80%;
    max-height: 920px;
    transform: translate(-50%, -50%);
  }
}
 
.modal-header {
  position: relative;
  background: #fffdf8;
  padding: 16px 52px;
  font-size: 20px;
  font-weight: 700;
  text-align: center;
  color: #a17345;
  display: flex;
  align-items: center;
  justify-content: center;
}

.header-title {
  display: flex;
  align-items: baseline;
  gap: 4px;
}

.header-lot-number {
  font-size: 20px;
  font-weight: 700;
  color: #ac8f5f;
  display: none; /* Hidden by default */
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 8px;
}

.lot-number-header {
  font-weight: 400;
  color: #8a8880;
  display: none; /* Hidden by default */
}

/* Header Controls Container */
.header-control {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 16px;
  height: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.header-control:hover {
  background-color: rgba(0, 0, 0, 0.05);
}

/* Default SVG size for all header controls */
.header-control svg {
  width: 12px;
  height: 12px;
  transition: transform 0.4s ease;
  stroke: #888;
  stroke-width: 1.5px;
  transform-origin: center;
  transform-box: fill-box;
}

/* Back button specifics */
#backButton {
  left: 12px;
  display: none;
}

#backButton svg {
  width: 16px; /* Larger for back button */
  height: 16px;
}

/* Close button specifics */
.close-x {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
}

/* Hover effects */
.header-control:hover svg {
  stroke: #666;
}

/* Rotation animations */
.header-control:hover#backButton svg {
  transform: rotate(-360deg);
}

.header-control.close-x:hover svg {
  transform: rotate(360deg);
}
 
/* Modal divider */
.modal-divider {
  height: 1px;
  background: #e0e0e0;
  margin: 0;
}

/* Modal content wrapper */
.modal-content-wrapper {
  position: relative;
  height: calc(100% - 54px);
  overflow: hidden;
}

/* Scrollable info list */
.modal-info {
  display: block;
  height: 100%;
  overflow-y: scroll;
  scroll-snap-type: y mandatory;
  -ms-overflow-style: none;
  scrollbar-width: none;
  contain: strict;
}

.modal-info::-webkit-scrollbar {
  display: none;
}

/* Scrollbar */
.custom-scrollbar {
  position: absolute;
  right: 4px;
  top: 0;
  bottom: 0;
  width: 6px;
  background: rgba(200, 200, 200, 0.2);
  border-radius: 3px;
  z-index: 10;
}

.custom-scrollthumb {
  position: absolute;
  width: 6px;
  background: #c0c0c0;
  border-radius: 3px;
  transition: height 0.2s, background 0.2s;
}

.custom-scrollthumb:hover,
.custom-scrollthumb.active {
  background: #a0a0a0;
}

/* Info rows */
.info-row {
  flex: none;
  height: calc(100% / 3);
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 24px;
  cursor: pointer;
  border-bottom: 1px solid #f0f0f0;
  gap: 8px;
  scroll-snap-align: center;
  transition: background 0.3s ease, opacity 0.3s ease;
  will-change: transform, opacity;
}

@media (min-width: 768px) {
  .info-row {
    height: calc(100% / 5);
  }
}

.info-row:last-child {
  border-bottom: none;
}

.info-row.active {
  background: #f2efe4;
  opacity: 1;
}

.lot-left {
  display: flex;
  flex-direction: column;
  line-height: 1;
  align-items: flex-end;
  text-align: right;
}

.lot-left .lote-label {
  font-size: 24px;
  color: #b18d69;
  padding-left:.5em;
}

.lot-left .lote-number {
  font-size: 48px;
  color: #8a8880;
  font-weight: 400;
}

.lot-middle {
  font-size: 24px;
  color: #8a8880;
  line-height: 1;
  display: flex;
  align-items: baseline;
}

.lot-middle--sold {
  flex: 1;
  justify-content: center;
  align-items: center;
  display: flex;
}

.lot-price--hidden {
  flex: 0 !important;
  width: 0 !important;
  opacity: 0;
  visibility: hidden;
  overflow: hidden;
}

/* Featured info rows */
.info-row--featured {
  flex: none;
  position: relative;
  box-sizing: border-box;
  margin-right: 14px;
}

.info-row--featured.animate-featured::before,
.info-row--featured.animate-featured .border-left {
  content: '';
  position: absolute;
  background: #ff8400;
  animation: draw-vertical 0.3s forwards;
  z-index: 2;
}

.info-row--featured.animate-featured::before {
  top: 0;
  right: 0;
  width: 2px;
  height: 0;
  animation-delay: 0s;
}

.info-row--featured.animate-featured .border-left {
  bottom: 0;
  left: 0;
  width: 2px;
  height: 0;
  animation-delay: 0.6s;
}

.info-row--featured.animate-featured::after,
.info-row--featured.animate-featured .border-top {
  content: '';
  position: absolute;
  background: #ff8400;
  animation: draw-horizontal 0.3s forwards;
  z-index: 2;
}

.info-row--featured.animate-featured::after {
  bottom: 0;
  right: 0;
  width: 0;
  height: 2px;
  animation-delay: 0.3s;
}

.info-row--featured.animate-featured .border-top {
  top: 0;
  left: 0;
  width: 0;
  height: 2px;
  animation-delay: 0.9s;
}

.featured-label {
  position: absolute;
  top: -20px;
  right: 12px;
  background: #ff8400;
  color: #fff;
  font-size: 14px;
  padding: 2px 6px;
  opacity: 0;
  pointer-events: none;
  z-index: 3;
}

.info-row--featured.animate-featured .featured-label {
  animation: label-pop 0.3s forwards;
  animation-delay: 1.4s;
}

@keyframes draw-horizontal {
  to { width: 100%; }
}

@keyframes draw-vertical {
  to { height: 100%; }
}

@keyframes label-pop {
  to { opacity: 1; }
}

.sup {
  font-size: 60%;
  position: relative;
  top: -0.6em;
  text-transform: uppercase;
  color:#b18d69;
}

.lot-price {
  display: flex;
  align-items: baseline;
  position: relative;
  line-height: 1;
}

.price-wrapper {
  position: relative;
  line-height: 1;
}

.price {
  font-size: 24px;
  color: #8a8880;
  line-height: 1;
}

.mdp {
  position: absolute;
  left: 50%;
  top: 100%;
  transform: translateX(-50%);
  font-size: 14px;
  color: #b18d69;
  line-height: 1;
  text-align: center;
}

.arrow {
  margin-left: 8px;
  display: flex;
  align-items: center;
}

.arrow-hidden {
  opacity: 0;
  pointer-events: none;
}

.arrow svg {
  width: 16px;
  height: 16px;
}

.info-row--featured .arrow svg {
  animation: arrow-wiggle 0.35s ease-in-out infinite alternate;
}

@keyframes arrow-wiggle {
  0%   { transform: translateX(0); }
  100% { transform: translateX(3px); }
}

/* Add this new animation */
@keyframes arrow-bounce {
  0% {
    transform: translateY(0);
  }
  100% {
    transform: translateY(3px);
  }
}

/* Apply to the arrow */
.wiggle-arrow {
  animation: arrow-bounce 0.35s ease-in-out infinite alternate;
}

.close-x {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.loading-spinner {
  display: none;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 40px;
  height: 40px;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #ac8f5f;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: translate(-50%, -50%) rotate(0deg); }
  100% { transform: translate(-50%, -50%) rotate(360deg); }
}

.border-left,
.border-top,
.featured-label {
  position: absolute;
  pointer-events: none;
}

/* Detailed View Styles */
.lot-details {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #fcfaf3;
  padding: 16px;
  transform: translateX(100%);
  transition: transform 0.3s ease;
  z-index: 5;
  border-radius: 12px;
}

.lot-details.active {
  transform: translateX(0);
}

.details-header {
  margin-bottom: 24px;
  position: relative;
}

.details-lot-number {
  font-size: 32px;
  color: #8a8880;
}

.details-lot-number span {
  font-size: 48px;
  font-weight: 400;
}

.details-featured-label {
  position: absolute;
  top: -10px;
  right: 0;
  background: #ff8400;
  color: white;
  padding: 4px 8px;
  font-size: 14px;
}

.details-body {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.details-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 12px;
  border-bottom: 1px solid #e0e0e0;
}

.details-label {
  font-size: 18px;
  color: #a9a698;
}

.details-value {
  font-size: 24px;
  color: #8a8880;
}

.modal-content-wrapper.show-details .modal-info,
.modal-content-wrapper.show-details .custom-scrollbar {
  opacity: 0;
  pointer-events: none;
}

/* Plus button styles */
.plus-button {
  right: 40px;
  transition: all 0.3s ease;
  display: none; /* Hidden by default */
}

/* Show plus button when details view active */
.modal-content-wrapper.show-details .plus-button {
  display: flex;
}

@media (max-width: 767px) {
  #lotModal.expanded {
    width: calc(100% - 40px);
    height: calc(100% - 40px);
    top: 20px !important;
  }
}

/* Keep the content wrapper height adjusted to expanded modal size */
#lotModal.expanded .modal-content-wrapper {
  height: calc(100% - 54px);
  overflow-y: auto;
}

/* Keep padded area for content, but avoid increasing padding size */
#lotModal.expanded .lot-details {
  padding: 16px; /* keep original padding, don't increase */
}

/* Do not change gaps in details-body */
#lotModal.expanded .details-body {
  gap: 24px; /* keep original gap size */
}

/* Keep padding consistent - no enlargement */
#lotModal.expanded .details-section {
  padding-bottom: 12px; /* keep original padding */
}

/* Keep font sizes consistent, no enlarging */
#lotModal.expanded .details-label {
  font-size: 18px;
}

#lotModal.expanded .details-value {
  font-size: 24px;
}

#lotModal.expanded .details-lot-number {
  font-size: 32px;
}

#lotModal.expanded .details-lot-number span {
  font-size: 48px;
}

/* Plus button icons display toggles unchanged */
#lotModal.expanded .plus-button .plus-icon {
  display: none;
}

#lotModal.expanded .plus-button .minus-icon {
  display: block;
}

/* Plus/Minus Button Animation */
.plus-button path.plus-icon {
  transition: transform 0.4s ease;
  transform-origin: center;
  transform-box: fill-box;
}

.plus-button path.minus-icon {
  display: none;
  transition: transform 0.4s ease;
  transform-origin: center;
  transform-box: fill-box;
}

.plus-button:hover path.plus-icon {
  transform: rotate(360deg);
}

.plus-button:hover path.minus-icon {
  animation: spinMinus 0.6s ease;
}

#lotModal.expanded .plus-button:hover path.minus-icon {
  animation: spinMinus 0.6s ease;
}

@keyframes spinMinus {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(-360deg); }
}

.bottom-plus-button {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  cursor: pointer;
  z-index: 10;
  display: none; /* hidden by default */
  transition: transform 0.3s ease, background 0.3s ease;
}

.bottom-plus-button:hover {
  transform: translateX(-50%) scale(1.1);
}

.bottom-plus-button svg {
  width: 20px;
  height: 20px;
}

/* Show only when details are active */
.modal-content-wrapper.show-details ~ .bottom-plus-button {
  display: flex;
}

/* But hide when modal is expanded */
#lotModal.expanded .bottom-plus-button {
  display: none !important;
}

/* Side length labels */
.side-length-label {
  position: absolute;
  background-color: rgba(255, 255, 255, 0.9);
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'Barlow Condensed', Arial, sans-serif;
  font-size: 12px;
  font-weight: 600;
  color: #333;
  pointer-events: none;
  z-index: 1000;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  transform: translate(-50%, -50%);
  white-space: nowrap;
    opacity: 0; /* Start invisible */
  transition: opacity 0.2s ease;
    transform-origin: center center;
  
}

@keyframes pop-in {
  0% {
    transform: translate(-50%, -50%) scale(0.4);
    opacity: 0;
  }
  60% {
    transform: translate(-50%, -50%) scale(1.1);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
}

body.fonts-loaded .side-length-label {
  opacity: 1; /* Fade in when fonts are ready */
}

#toaster,
#ctaToaster {
  position: fixed;
  width: 50%;
  max-width: 400px;
  top: 0;
  left: 50%;
  transform: translateX(-50%) translateY(-20px); /* starts above */
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.4s ease, transform 0.4s ease, border-radius 0.3s ease;
  z-index: 10000;
  border-radius: 6px; /* full radius by default */
  font-size: 14px;
  text-align:center;
  white-space: pre-line;
}

#toaster {
  background: #323232;
  color: white;
  padding: 12px 12px;
}

#ctaToaster {
  background: #25d366;
  color: white;
  padding: 12px 16px;
  text-align: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    text-decoration: none;
      pointer-events: none; /* ‚úÖ allow interaction */
      transition: opacity 0.4s ease, transform 0.4s ease, filter 0.3s ease-in;

}

/* When showing: fade in, slide into place, square top edges */
#toaster.show,
#ctaToaster.show {
  opacity: 1;
  pointer-events: auto;
  transform: translateX(-50%) translateY(0); /* slide down into view */
  border-radius: 0 0 6px 6px; /* only round bottom corners */
}

#ctaToaster:hover {
  filter: brightness(1.1);
}


.whatsapp-button {
  position: fixed;
  bottom: 5px;
  right: 5px;
  z-index: 9999;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background-color: #25d366;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  animation: none;
  transition: transform 0.2s ease;
}

.whatsapp-button:hover {
  transform: scale(1.1);
}

.whatsapp-button img {
  width: 60%;
  height: 60%;
}

.whatsapp-button.bounce {
  animation: bounce 0.6s ease;
}

@keyframes bounce {
  0%, 20%, 50%, 80%, 100% {
    transform: translateY(0);
  }
  40% {
    transform: translateY(-15px);
  }
  60% {
    transform: translateY(-8px);
  }
}

.map-reset-button {
  position: fixed;
  bottom: 80px;
  right: 11px;
  width: 48px;
  height: 48px;
  border: none;
  outline: none;
  background-color: #fff;
  border-radius: 50%;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 9999;
  transition: opacity 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
  opacity: 1;
  pointer-events: auto;
}

.map-reset-button.hide {
  opacity: 0;
  pointer-events: none;
}

.map-reset-button:hover {
  transform: scale(1.1);
}

.map-reset-button svg {
  width: 24px;
  height: 24px;
  display: block;
}

/* Add these new styles to your production CSS */
#lotModal:not(.expanded) .lot-details {
  overflow-y: hidden !important;
}

#lotModal.expanded .lot-details {
  overflow-y: auto !important;
}

/* Detail View Styles */
.detail-container {
  display: flex;
  flex-direction: column;
}

.detail-header {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 0px;
}

.tag-row {
  display: flex;
  justify-content: center;
  gap: 12px;
}

.featured-tag {
  background: #ff8400;
  color: #fff;
  font-size: 14px;
  font-weight: 200;
  padding: 3px 6px;
  border-radius: 0px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.nickname {
  color: #FF8400;
  font-size: 20px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-style: normal;
}

.subtitle-row {
  color: #8a8880;
  font-size: 13px;
  margin-bottom: 0px;
  padding-left: 0px;
  font-style: italic;
  text-align: center;
}

.detail-data-row {
  display: flex;
  width: 100%;
  padding: 12px 20px;
  box-sizing: border-box;
  gap: 8px;
  align-items: center;
}

.detail-data-row > div {
  flex: 1;
  text-align: center;
  min-width: 0;
}

.detail-data-row .lot-left {
  flex: 1;
  text-align: left;
  padding-left: 0;
  margin-left: 0;
}

.detail-data-row .lot-price {
  flex: 1;
  display: flex;
  justify-content: center;
  position: relative;
}

.detail-data-row .price-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  margin-top: 0.7em;
  margin-right: 2em;
}

.detail-data-row .price {
  font-size: 24px;
  line-height: 1;
  position: relative;
  top: 0.1em;
}

.detail-data-row .mdp {
  font-size: 14px;
  color: #b18d69;
  line-height: 1;
  margin-top: 2px;
  position: relative;
  left: 0;
  transform: none;
}

.detail-extra-row {
  width: 100%;
  overflow: hidden;
  border-top: 1px solid #e0e0e0;
  margin: 0;
  padding: 0;
  margin-top: 8px;
}

.lot-image {
  width: 100%;
  height: auto;
  display: block;
  object-fit: cover;
  margin: 0;
  padding: 0;
}

.lot-details {
  padding-left: 0 !important;
  padding-right: 0 !important;
}

.price-per-m2-column {
  flex: none;
  width: 20%;
  font-size: 24px;
  color: #8a8880;
  line-height: 1;
  font-weight: 400;
  display: flex;
  align-items: baseline;
  justify-content: center;
}

.price-per-m2-column sup.sup {
  font-size: 60%;
  position: relative;
  top: -0.6em;
  text-transform: uppercase;
  color: #b18d69;
}

.lot-details .lot-left {
  align-items: flex-start !important;  /* Align children to left */
}

.lot-details .lote-number {
  margin-left: 0 !important;
  text-align: left !important;
}

.map-info-button {
  position: fixed;
  bottom: 20px;
  left: 0px;
  width: 48px; height: 48px;
  border: none; outline: none;
  background-color: rgba(0,0,0,0);
  border-radius: 50%;
  box-shadow: 0 2px 6px rgba(0,0,0,0);
  display: flex; align-items: center; justify-content: center;
  cursor: pointer;
  z-index: 10000;
  transition: transform .2s ease, opacity .3s ease;
}
.map-info-button:hover { transform: scale(1.1); }
.map-info-button svg { width: 24px; height: 24px; stroke: #ff8400; fill: #1A1A1A; stroke-width: 2; }

.map-info-button.hide {
  opacity: 0;
  pointer-events: none;
}

/* Agendar Cita Button */
.schedule-appointment-btn {
  background-color: #ff8400;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 0px;
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  width: 100%;
  margin-top: 16px;
  transition: background-color 0.3s ease;
  font-family: 'Barlow Condensed';
}

.schedule-appointment-btn:hover {
  background-color: #e67300;
}

/* Add to your existing styles */
.calendly-embed-container {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #fcfaf3;
  z-index: 1000;
  overflow: hidden;
}

.calendly-embed-container iframe {
  width: 100%;
  height: 100%;
  border: none;
}


.gps-button {
  position: fixed;
  bottom: 140px;  /* Adjusted to be above the Reset View Button */
  right: 11px;
  width: 48px;
  height: 48px;
  border: none;
  outline: none;
  background-color: #fff;
  border-radius: 50%;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 9999;
  transition: opacity 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
  opacity: 1;
  pointer-events: auto;
}

.gps-button.hide {
  opacity: 0;
  pointer-events: none;
}

.gps-button:hover {
  transform: scale(1.1);
}

.gps-button svg {
  width: 24px;
  height: 24px;
  display: block;
}


/* camera FAB (hidden until GPS starts) */
#cameraButton{
  position: fixed;
  bottom: 200px;          /* sits above GPS (140) and Reset (80) */
  right: 11px;
  z-index: 9999;
  display: none;
}
#takePhotoBtn{
  width: 48px; height: 48px;
  border: none; outline: none;
  background:#fff;
  border-radius: 50%;
  box-shadow: 0 2px 6px rgba(0,0,0,.15);
  display:flex; align-items:center; justify-content:center;
  cursor:pointer;
  transition: transform .2s ease, box-shadow .2s ease;
  font-size: 20px; line-height: 1;
}
#takePhotoBtn:hover{ transform: scale(1.1); }

/* thumbnail markers */
.photo-marker{
  width: 40px; height: 40px;
  background-size: cover; background-position:center;
  border-radius: 50%;
  border: 2px solid #fff;
  box-shadow: 0 2px 6px rgba(0,0,0,.25);
  position: relative;
}
.photo-timestamp{
  position: absolute;
  bottom: -12px; left: 50%;
  transform: translateX(-50%);
  background: #1A1A1A; color:#fff;
  font-size: 10px; padding: 2px 6px; border-radius: 10px;
  white-space: nowrap;
}

/* full-screen viewer */
#photoModal{
  display:none; position:fixed; inset:0;
  background: rgba(0,0,0,0.92); z-index: 10000;
}
#photoModal #modalImage{
  max-width:90%; max-height:90%;
  margin:auto; display:block; position:relative; top:50%; transform:translateY(-50%);
  box-shadow: 0 6px 24px rgba(0,0,0,.4);
}
#photoModal #closeModal{
  position:absolute; top:20px; right:20px;
  background:#f44336; color:white; border:none; border-radius:50%;
  width:40px; height:40px; font-size:20px; cursor:pointer;
}



  </style>
</head>

<body>
<div id="map"></div>

<div id="toaster" class="hidden">Loaded most recent aerial image (March 2025)</div>
<a href="https://wa.me/5218185261819"
   target="_blank"
   id="ctaToaster"
   class="hidden"
   data-utm-source="website"
   data-utm-medium="toaster"
   data-utm-campaign="lead_generation">
  ¬øTienes dudas? ¬°Chatea con nosotros por WhatsApp!
</a>

<div class="logo-wrapper">
  <img src="https://lalaland.mx/lalaland.svg" alt="Logo">
</div>

<!-- Modal Panel -->
<div id="lotModal">
  <div class="modal-header">
    <div class="header-control" id="backButton">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
        <path d="M10 4 L6 8 L10 12" fill="none"/>
      </svg>
    </div>
    <div class="header-title">
      LOTES VENTA ‚Äî SANTTE 2<span class="header-lot-number" id="headerLotNumber"></span>
    </div>
    <div class="header-control close-x" onclick="closeModal()">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
        <path d="M4 4 L12 12 M12 4 L4 12" fill="none"/>
      </svg>
    </div>
<div class="header-control plus-button" onclick="handlePlusButton()">
<svg viewBox="0 0 16 16">
  <!-- Plus sign (centered) -->
  <path class="plus-icon" d="M8 3 L8 13 M3 8 L13 8" 
        fill="none" stroke="#888" stroke-width="1.5" stroke-linecap="round" />
  
  <!-- Minus sign (centered) -->
  <path class="minus-icon" d="M3 8 L13 8" 
        fill="none" stroke="#888" stroke-width="1.5" stroke-linecap="round" 
        style="display: none;"/>
</svg>
</div>
  </div>
  <div class="modal-divider"></div>
  <div class="modal-content-wrapper">
    <div class="loading-spinner" id="loadingSpinner"></div>

<div class="lot-details" id="lotDetails"></div>

<!-- Calendly must be a sibling, not inside lotDetails -->
<div id="calendlyEmbed" class="calendly-embed-container" style="display:none;">

  <iframe id="calendly-iframe" 
          src="about:blank"
          frameborder="0"
          style="width:100%;height:100%;"></iframe>
</div>

<div class="modal-info" id="modalInfo"></div>


    <div class="custom-scrollbar" id="customScrollbar">
      <div class="custom-scrollthumb" id="customScrollthumb"></div>
    </div>
  </div>
  <div class="bottom-plus-button" onclick="handlePlusButton()">
  <svg viewBox="0 0 16 16" class="wiggle-arrow">
    <path d="M4 6 L8 10 L12 6" 
          fill="none" stroke="#fff" stroke-width="1.5" stroke-linecap="round" />
  </svg>
  </div>
</div>

<!-- Whatsapp button -->
<a href="https://wa.me/5218185261819" target="_blank" class="whatsapp-button"
   data-utm-source="website"
   data-utm-medium="button"
   data-utm-campaign="lead_generation">
  <img src="https://lalaland.mx/whatrans.png" alt="WhatsApp" />
</a>

<!-- Reset view Button -->
<button id="resetViewBtn" class="map-reset-button" title="Reset View">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" stroke="#333">
  <!-- Top-left corner (larger inward "L") -->
  <path d="M8,2 H2 V8"  stroke-width="2" stroke-linecap="round" fill="none"/>
  
  <!-- Top-right corner (larger inward "L") -->
  <path d="M16,2 H22 V8"  stroke-width="2" stroke-linecap="round" fill="none"/>
  
  <!-- Bottom-left corner (larger inward "L") -->
  <path d="M2,16 V22 H8"  stroke-width="2" stroke-linecap="round" fill="none"/>
  
  <!-- Bottom-right corner (larger inward "L") -->
  <path d="M16,22 H22 V16"  stroke-width="2" stroke-linecap="round" fill="none"/>
</svg>


</button>

<button id="gpsButton" class="gps-button" title="Enable GPS">
 <svg viewBox="0 0 24 24" width="24" height="24" stroke="#333" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="9" />
    <line x1="12" y1="2" x2="12" y2="5" />
    <line x1="12" y1="19" x2="12" y2="22" />
    <line x1="2" y1="12" x2="5" y2="12" />
    <line x1="19" y1="12" x2="22" y2="12" />
    <circle cx="12" cy="12" r="4.5" fill="#333" stroke="none" />
  </svg>
</button>

<button id="infoBtn" class="map-info-button" title="Ver info">
  <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
    <!-- Circle outline normal thickness -->
    <circle cx="12" cy="12" r="9" stroke-width="2"></circle>

    <!-- "i" parts thicker -->
    <line x1="12" y1="8"  x2="12" y2="8"  stroke-width="3"></line>  <!-- dot -->
    <line x1="12" y1="11" x2="12" y2="16" stroke-width="3"></line>  <!-- stem -->
  </svg>
</button>

<script>
  const btn = document.querySelector('.whatsapp-button');

  function bounceButton() {
    if (!btn) return;
    btn.style.animation = 'bounce 1s';
    btn.addEventListener('animationend', () => {
      btn.style.animation = '';
    }, { once: true });
  }

  // Initial bounce after 10 seconds
  setTimeout(bounceButton, 10000);

  // Subsequent bounces every 3 minutes
  setInterval(bounceButton, 3 * 60 * 1000);

const ctaToaster = document.getElementById('ctaToaster');
const whatsappBtn = document.querySelector('.whatsapp-button');

const ctaobserver = new MutationObserver(() => {
  if (ctaToaster.classList.contains('show')) {
    setTimeout(() => {
      whatsappBtn.classList.add('bounce');

      // Remove after animation so it can be triggered again later
      setTimeout(() => {
        whatsappBtn.classList.remove('bounce');
      }, 600); // duration of bounce animation
    }, 4000); // ‚è≥ 2s delay before bounce
  }
});

ctaobserver.observe(ctaToaster, {
  attributes: true,
  attributeFilter: ['class']
});

</script>

<script>
  //HASH FOR URL
  function openInitialLotModal() {
    const hash = window.location.hash;
    if (hash.startsWith('#lot=')) {
      const lotName = decodeURIComponent(hash.slice(5));
      const lot = lotData.find(l => l.name === lotName);
      if (lot) openModal(lot);
    }
  }
</script>
   
<script>
  // LOAD SUPABASE
  window.supabaseReady = new Promise((resolve, reject) => {
    const supabaseScript = document.createElement('script');
    supabaseScript.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';
    
    supabaseScript.onload = () => {
      fetch('https://lalaland.mx/sb_config.json')
        .then(r => r.json())
        .then(cfg => {
          window.supabaseClient = supabase.createClient(cfg.url, cfg.key);
          console.log('‚úÖ Supabase client initialized with config.json');
          resolve();

          // ‚úÖ ‚úÖ ‚úÖ ADD REALTIME SUBSCRIPTION HERE
          const channel = window.supabaseClient
            .channel('lots-realtime')
            .on(
              'postgres_changes',
              {
                event: '*',
                schema: 'public',
                table: 'lots',
              },
              (payload) => {
                console.log('üì° Change detected:', payload);

                const updatedLotName = payload.new?.lot_name || payload.old?.lot_name;
                const updatedIndex = lotData.findIndex(l => l.name === updatedLotName);

                if (updatedIndex !== -1) {
                  const lot = lotData[updatedIndex];

                  // Update local lot data
                  lot.availability = (payload.new?.availability ?? '').toLowerCase();
                  lot.featured = lot.availability === 'featured';
                  lot.rSize = payload.new?.rSize ?? lot.rSize;
                  lot.millones = payload.new?.millones ?? lot.millones;

                  // Refresh visual on map
                  refreshLotVisuals(map, lot);
                }
              }
            )
            .subscribe()
            .catch(error => console.error('‚ùå Realtime subscription failed:', error));
        })
        .catch(e => {
          console.error('Failed to load Supabase config:', e);
          reject(new Error("‚ùå Failed to load Supabase config"));
        });
    };
    
    supabaseScript.onerror = () => {
      console.error("‚ùå Failed to load Supabase script");
      reject(new Error("‚ùå Failed to load Supabase script"));
    };
    
    document.head.appendChild(supabaseScript);
  });
</script>

<script> 
// MAP INITIALIZE
let lotData = [];
let map;  // global map variable
let hoveredId = null;
let currentLotIndex = -1;
let sideLengthLabels = []; // Array to store side length label elements
let currentLabeledLot = null; // Track which lot has labels
let isDetailOpen = false;


// Initialize map
fetch('https://lalaland.mx/mapbox.txt')
  .then(r => r.text())
  .then(token => {
    mapboxgl.accessToken = token.trim();
const initialZoom = window.innerWidth >= 768 ? 17 : 16.45; // desktop vs mobile

map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/satellite-streets-v11',
  center: [-100.15994, 25.461823],
  zoom: initialZoom
});
 
    map.doubleClickZoom.disable();

    map.on('load', async () => {
      await loadRoad(map, async () => {
        await loadLotsAsync(map);
        await window.supabaseReady;
        await enrichLotsWithAvailability();

        animateLots(map, () => {
          addCustomImage(map);
          addFeaturedLotsLayer(map);

map.once('idle', () => window.__LL_PINS__?._revealMarkers());  


          // ===== NEW INTERACTION HANDLERS =====
          // Clear labels on any map movement
map.on('moveend', () => {
  // Only clear labels if we are NOT in detail view
  if (!isDetailOpen && currentLabeledLot) {
    removeSideLengthLabels();
  }



});


          // Clear labels when clicking a different lot
          map.on('click', 'lots-final-click', (e) => {
            if (e.features.length > 0) {
              const newLot = lotData.find(l => l.name === e.features[0].properties.name);
              if (currentLabeledLot && currentLabeledLot.name !== newLot.name) {
                removeSideLengthLabels();
              }
            }
          });
          // ===== END NEW HANDLERS =====

          map.on('click', (e) => {
            // Don't close if clicking inside modal
            if (e.originalEvent?.target.closest('#lotModal')) return;
            
            // Only close if clicking outside polygons
            const features = map.queryRenderedFeatures(e.point, { 
              layers: ['lots-final-click'] 
            });
            
            if (features.length === 0) {
              closeModal();
            }
          });

          // Add hover outline layer after lots-final source is ready
          map.addLayer({
            id: 'lots-hover-outline',
            type: 'line',
            source: 'lots-final',
            paint: {
              'line-color': '#fff',
              'line-width': 3,
              'line-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0]
            }
          });

          console.log('Ready to open initial modal, lotData:', lotData);
          openInitialLotModal();

          map.on('mousemove', 'lots-final-click', (e) => {
            // Don't override modal highlight
            if (document.getElementById('lotModal').classList.contains('show')) return;
            if (hoveredId !== null) {
              map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
            }
            if (e.features.length > 0) {
              hoveredId = e.features[0].id;
              map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: true });
            }
          });

          map.on('mouseleave', 'lots-final-click', () => {
            if (document.getElementById('lotModal').classList.contains('show')) return;
            if (hoveredId !== null) {
              map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
            }
            hoveredId = null;
          });

          // Click on lot: open modal (no persistent selection highlight)
          map.on('click', 'lots-final-click', (e) => {
            if (e.features.length === 0) return;

            const feature = e.features[0];
            const lotName = feature.properties.name;
            const lot = lotData.find(l => l.name === lotName);
            if (!lot) return;

            // Remove previous hover
            if (hoveredId !== null) {
              map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
              hoveredId = null;
            }

            // Find index
            const idx = lotData.findIndex(l => l.name === lot.name);
            if (idx !== -1) {
              map.setFeatureState({ source: 'lots-final', id: idx }, { hover: true });
              hoveredId = idx;
              currentLotIndex = idx;
            }

            openModal(lot);

            // üü© Scroll modal to correct lot
            const baseIndex = baseLots.findIndex(l => l.number === extractLotNumber(lot.name));
            if (baseIndex !== -1) {
              scrollToBaseIndex(baseIndex, true);
            }
          });
        }); // animateLots callback ends
      }); // loadRoad callback ends
    }); // map load ends
  }); // fetch token ends

// === SIDE LENGTH LABELS ===
function addSideLengthLabels(lot) {
  removeSideLengthLabels();
  currentLabeledLot = lot;

  const coords = [...lot.coords];
  if (coords.length < 3) return;

  if (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1]) {
    coords.push(coords[0]);
  }

  coords.forEach((_, i) => {
    if (i >= coords.length - 1) return;

    setTimeout(() => {
      const start = coords[i];
      const end = coords[i + 1];
      const midpoint = [(start[0] + end[0]) / 2, (start[1] + end[1]) / 2];

      const distance = turf.distance(turf.point(start), turf.point(end), { units: 'meters' });
      const roundedDistance = Math.round(distance * 2) / 2;

      const label = document.createElement('div');
      label.className = 'side-length-label';
      label.textContent = `${roundedDistance}m`;
      label.style.position = 'absolute';

      const pixelPos = map.project(midpoint);
label.style.left = `${pixelPos.x}px`;
label.style.top = `${pixelPos.y}px`;
label.style.transform = 'translate(-50%, -50%) scale(0.4)';
      label.style.opacity = '0';
label.style.transform = 'scale(0.4)';
label.style.animation = 'pop-in 0.35s cubic-bezier(0.25, 1.25, 0.5, 1) forwards';

      document.getElementById('map').appendChild(label);
      requestAnimationFrame(() => label.style.opacity = '1');

      sideLengthLabels.push(label);
    }, i * 200); // ‚Üê Ajusta este valor para controlar el tiempo entre etiquetas
  });

  map.on('move', updateSideLengthPositions);
}


function updateSideLengthPositions() {
  if (!currentLabeledLot || sideLengthLabels.length === 0) return;
  
  const coords = [...currentLabeledLot.coords];
  if (coords[0][0] !== coords[coords.length - 1][0] || 
      coords[0][1] !== coords[coords.length - 1][1]) {
    coords.push(coords[0]);
  }

  for (let i = 0; i < coords.length - 1; i++) {
    const start = coords[i];
    const end = coords[i + 1];
    const midpoint = [
      (start[0] + end[0]) / 2,
      (start[1] + end[1]) / 2
    ];
    
    const pixelPos = map.project(midpoint);
    sideLengthLabels[i].style.left = `${pixelPos.x}px`;
    sideLengthLabels[i].style.top = `${pixelPos.y}px`;
  }
}

function removeSideLengthLabels() {
  sideLengthLabels.forEach(label => {
    if (label.parentNode) {
      label.parentNode.removeChild(label);
    }
  });
  sideLengthLabels = [];
  currentLabeledLot = null;
  map.off('move', updateSideLengthPositions);
}
</script>  

<script>
// ROAD: Add and animate road layer
const roadGeojson = {
  type: "FeatureCollection",
  features: [{
    type: "Feature",
    geometry: {
      type: "LineString",
      coordinates: [
        [-100.157757, 25.45803],
        [-100.157888, 25.458456],
        [-100.158984, 25.45995],
        [-100.15855, 25.460763],
        [-100.158634, 25.461454],
        [-100.158488, 25.462755],
        [-100.15872, 25.463296],
        [-100.16009, 25.465042],
        [-100.161556, 25.464865],
        [-100.163154, 25.465748],
        [-100.164051, 25.465707],
        [-100.165586, 25.466227],
        [-100.165558, 25.466294],
        [-100.164039, 25.46578],
        [-100.163133, 25.465821],
        [-100.161538, 25.46494],
        [-100.160053, 25.465119],
        [-100.158649, 25.463331],
        [-100.158407, 25.462765],
        [-100.158554, 25.461455],
        [-100.158468, 25.46075],
        [-100.158893, 25.459956],
        [-100.157814, 25.458486],
        [-100.15768, 25.458049]
      ]
    }
  }]
};

// Function to add and animate road layer
function loadRoad(map, cb) {
  map.addSource('road', { type: 'geojson', data: roadGeojson });
  map.addLayer({
    id: 'road',
    type: 'line',
    source: 'road',
    paint: { 'line-color': '#fff', 'line-width': 1, 'line-opacity': 0 }
  });

  let start = null;
  function animate(ts) {
    if (!start) start = ts;
    let p = Math.min((ts - start) / 500, 1);
    map.setPaintProperty('road', 'line-opacity', p);
    if (p < 1) requestAnimationFrame(animate);
    else cb();
  }
  requestAnimationFrame(animate);
}
</script>

<script>
// LOT PARSING: Load and parse lot data
function loadLotsAsync(map) {
  return fetch('https://lalaland.mx/lots.txt')
    .then(r => r.text())
    .then(txt => {
      lotData = parseLots(txt);
    });
}

function parseLots(text) {
  const lines = text.trim().split('\n');
  const lots = [], curr = null;
  let currentLot = null;

  lines.forEach(line => {
    line = line.trim();
    if (!line) return;

    if (!line.startsWith('{')) {
      if (currentLot) lots.push(currentLot);
      currentLot = { name: line, coords: [] };
    } else {
      const m = line.match(/lat:\s*([0-9.\-]+),\s*lng:\s*([0-9.\-]+)/);
      if (m && currentLot) currentLot.coords.push([+m[2], +m[1]]);
    }
  });

  if (currentLot) lots.push(currentLot);

  // ‚ûï Calculate center using Turf
  lots.forEach(lot => {
    try {
      const poly = turf.polygon([[...lot.coords, lot.coords[0]]]); // Close ring
      const center = turf.centroid(poly).geometry.coordinates;
      lot.center = center;
    } catch (err) {
      console.warn('Failed to calculate center for', lot.name, err);
      lot.center = [0, 0]; // Fallback
    }
  });

  return lots;
}
</script>

<script>
  // FETCH AVAILABILITY SUPABASE
  //Async function to fetch availability info from Supabase and attach it to lotData
  async function enrichLotsWithAvailability() {
    if (!lotData || lotData.length === 0) {
      console.warn('lotData is empty, cannot enrich availability');
      return;
    }

    if (!window.supabaseClient) {
      console.error('Supabase client not initialized yet.');
      return;
    }
  
    const names = lotData.map(lot => lot.name);

    const { data, error } = await window.supabaseClient
      .from('lots')
      .select('lot_name, availability, rSize, millones')
      .in('lot_name', names);

    if (error) {
      console.error('Error fetching lot availability from Supabase:', error);
      return;
    }

    if (data && data.length > 0) {
      data.forEach(row => {
        const lot = lotData.find(l => l.name === row.lot_name);
        if (lot) {
          const value = (row.availability ?? '').toLowerCase();
          lot.featured = value === 'featured';
          lot.availability = value === 'sold' ? 'sold' : 'available';
          lot.rSize = row.rSize;
          lot.millones = row.millones;
        }
      });
      console.log('Lot data enriched with availability:', lotData);
    } else {
      console.warn('No availability data returned for lots');
    }
  }
</script>

<script>
// ========== DRAW X ON SOLD LOTS ==========
function addSoldXs(map, soldLots, fadeDuration = 500) {
  if (!map.getSource('sold-x')) {
    map.addSource('sold-x', {
      type: 'geojson',
      data: { type: 'FeatureCollection', features: [] }
    });

    map.addLayer({
      id: 'sold-x-layer',
      type: 'line',
      source: 'sold-x',
      layout: {},
      paint: {
        'line-color': 'white',
        'line-width': 1,
        'line-opacity': 0,
        'line-opacity-transition': { duration: fadeDuration }
      }
    });
  }

  const newFeatures = soldLots.flatMap(makeXFeatures);

  // Merge with existing features
  const source = map.getSource('sold-x');
  const current = source._data?.features || [];
  const updated = [...current, ...newFeatures];

  source.setData({ type: 'FeatureCollection', features: updated });

  // ‚è≥ Fade in after tiny delay to ensure features are added first
  setTimeout(() => {
    map.setPaintProperty('sold-x-layer', 'line-opacity', 1);
  }, 10);
}

function makeXFeatures(lot) {
  const coords = lot.coords;
  if (!coords || coords.length < 3) return [];

  // Ensure polygon is not closed twice
  if (
    coords[0][0] === coords[coords.length - 1][0] &&
    coords[0][1] === coords[coords.length - 1][1]
  ) {
    coords.pop();
  }

  const n = coords.length;
  if (n === 4) {
    return [
      {
        type: 'Feature',
        properties: { lotName: lot.name },
        geometry: { type: 'LineString', coordinates: [coords[0], coords[2]] }
      },
      {
        type: 'Feature',
        properties: { lotName: lot.name },
        geometry: { type: 'LineString', coordinates: [coords[1], coords[3]] }
      }
    ];
  }

  function distance(p1, p2) {
    const dx = p2[0] - p1[0];
    const dy = p2[1] - p1[1];
    return Math.sqrt(dx * dx + dy * dy);
  }

  let maxDistance = 0;
  let farthestPair = [];
  let secondMaxDistance = 0;
  let secondFarthestPair = [];

  for (let i = 0; i < coords.length; i++) {
    for (let j = i + 1; j < coords.length; j++) {
      const dist = distance(coords[i], coords[j]);
      if (dist > maxDistance) {
        secondMaxDistance = maxDistance;
        secondFarthestPair = [...farthestPair];
        maxDistance = dist;
        farthestPair = [coords[i], coords[j]];
      } else if (dist > secondMaxDistance) {
        secondMaxDistance = dist;
        secondFarthestPair = [coords[i], coords[j]];
      }
    }
  }

  const threshold = 0.000038;
  function isTooClose(p, a, b) {
    return distance(p, a) < threshold || distance(p, b) < threshold;
  }

  let secondMaxDistanceCheck = 0;
  let secondFarthestPairCheck = [];

  for (let i = 0; i < coords.length; i++) {
    for (let j = i + 1; j < coords.length; j++) {
      if (
        coords[i] === farthestPair[0] || coords[i] === farthestPair[1] ||
        coords[j] === farthestPair[0] || coords[j] === farthestPair[1]
      ) continue;
      if (
        isTooClose(coords[i], farthestPair[0], farthestPair[1]) ||
        isTooClose(coords[j], farthestPair[0], farthestPair[1])
      ) continue;

      const dist = distance(coords[i], coords[j]);
      if (dist > secondMaxDistanceCheck) {
        secondMaxDistanceCheck = dist;
        secondFarthestPairCheck = [coords[i], coords[j]];
      }
    }
  }

  const features = [
    {
      type: 'Feature',
      properties: { lotName: lot.name },
      geometry: { type: 'LineString', coordinates: farthestPair }
    }
  ];

  if (secondFarthestPairCheck.length === 2) {
    features.push({
      type: 'Feature',
      properties: { lotName: lot.name },
      geometry: { type: 'LineString', coordinates: secondFarthestPairCheck }
    });
  }

  return features;
}
</script>

<script>
// LOT ANIMATION: Animate the appearance of lots
function animateLots(map, cb) { 
  const groups = 20,
    delay = 80,
    duration = 250,
    finalDelay = 200; 
  const fadeDuration = 500;
  const fadeDurationXs = 1500; 

  // Shuffle lots
  const shuffled = [...Array(lotData.length).keys()];
  shuffle(shuffled);

  // Divide into groups
  const groupArr = Array.from({ length: groups }, () => []);
  shuffled.forEach((i, idx) => groupArr[idx % groups].push(i));

  // Render each group with fade-in animation
  groupArr.forEach((g, i) => {
    const geojson = {
      type: "FeatureCollection",
      features: g.map((idx) => lotFeature(lotData[idx])),
    };
    map.addSource(`lot-group-${i}`, { type: "geojson", data: geojson });
    map.addLayer({
      id: `lot-group-${i}`,
      type: "line",
      source: `lot-group-${i}`,
      paint: {
        "line-color": "#fff",
        "line-width": 1,
        "line-opacity": 0,
        "line-opacity-transition": { duration: fadeDuration },
      },
    });
    setTimeout(() => {
      map.setPaintProperty(`lot-group-${i}`, "line-opacity", 1);

      // ‚úÖ ADD THIS: Draw Xs for sold lots in this group
      const soldInGroup = g
        .map(idx => lotData[idx])
        .filter(lot => (lot.availability ?? '').toLowerCase() === 'sold');

      if (soldInGroup.length > 0) {
        addSoldXs(map, soldInGroup, fadeDurationXs); // ‚¨Ö match fade timing
      } 
    }, i * delay);




  });

  // Add final lots layer (initially transparent but visible)
  const finalGeojson = {
    type: "FeatureCollection",
    features: lotData.map((lot, i) => lotFeature(lot, i))  // <- pass index here!
  };
  map.addSource("lots-final", { type: "geojson", data: finalGeojson });
  map.addLayer({
    id: "lots-final",
    type: "line",
    source: "lots-final",
    layout: { visibility: "visible" },
    paint: {
      "line-color": "#fff",
      "line-width": 1,
      "line-opacity": 0,
      "line-opacity-transition": { duration: fadeDuration },
    },
  });
  map.addLayer({ //HAD TO ADD THIS FOR CLICKABLE LOTS
    id: "lots-final-click",
    type: "fill",
    source: "lots-final",
    layout: { visibility: "visible" },
    paint: {
      "fill-color": "#000",      // any color
      "fill-opacity": 0          // invisible
    }

    
  });







  // After all groups have faded in & paused, fade in final lots, then fade out all groups simultaneously
  setTimeout(() => {
    // Fade in final lots
    map.setPaintProperty("lots-final", "line-opacity", 1);

    setTimeout(() => {
      // Fade out all lot groups simultaneously
      groupArr.forEach((_, i) => {
        const id = `lot-group-${i}`;
        if (map.getLayer(id)) {
          map.setPaintProperty(id, "line-opacity", 0);
        }
      });

      // Remove all lot groups after fade out duration and call callback
      setTimeout(() => {
        groupArr.forEach((_, i) => {
          const id = `lot-group-${i}`;
          if (map.getLayer(id)) map.removeLayer(id);
          if (map.getSource(id)) map.removeSource(id);
        });
        if (cb) cb();
      }, fadeDuration);
    }, finalDelay + fadeDuration); // Wait for fade-in and extra delay before fading out groups
  }, groups * delay + duration);
}

// Helpers unchanged HERE COLOR IS ADDED DEPENDING ON AVAILABILITY
function lotFeature(lot, index) {
  const c = [...lot.coords];
  if (c[0][0] !== c[c.length - 1][0] || c[0][1] !== c[c.length - 1][1]) c.push(c[0]);
  return {
    type: "Feature",
    geometry: { type: "Polygon", coordinates: [c] },
    properties: { name: lot.name },
    id: index  // unique id for feature state
  };
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}
</script>

<script>
// DRONE IMAGE - Add custom recent drone satellite image as a raster layer
function addCustomImage(map) {
  // Coordinates for the custom drone image (georeferenced)
  const imageBounds = [
    [-100.16483, 25.467111], // Top-left corner [lng, lat]
    [-100.154874, 25.467111], // Top-right corner [lng, lat]
    [-100.154874, 25.457155], // Bottom-right corner [lng, lat]
    [-100.16483, 25.457155],  // Bottom-left corner [lng, lat]
  ];

  map.addSource('drone-satellite', { 
    type: 'image',
    url: 'https://lalaland.mx/santte2.jpg', // Your drone image URL
    coordinates: imageBounds // Set the coordinates for where the image will be placed
  });

  map.addLayer({
    id: 'drone-satellite-layer',
    type: 'raster',
    source: 'drone-satellite',
    paint: {
      'raster-opacity': 0
    }
  }, 'road');  // Insert BELOW 'road' layer, so roads are on top

  // Then fade in opacity as you do
  fadeInImage(map);
  showToaster("Cargamos la im√°gen a√©rea m√°s actual ‚Äî (marzo 2025)");
}

//CTA
function showCta(message = "Want more info about this lot?", duration = 5000) {
  const ctaToaster = document.getElementById('ctaToaster');
  ctaToaster.classList.remove('hidden');
  ctaToaster.textContent = message;
  ctaToaster.classList.add('show');
 
  setTimeout(() => {
    ctaToaster.classList.remove('show');
    setTimeout(() => ctaToaster.classList.add('hidden'), 400); // Wait for fade out
  }, duration);
}
 
// Fade-in effect for the image (opacity increases gradually from 0 to 1)
function fadeInImage(map) {
  let opacity = 0;
  const interval = setInterval(() => {
    opacity += 0.05;  // Increase opacity gradually
    if (opacity >= 1) {
      opacity = 1;
      clearInterval(interval); // Stop once opacity reaches 1
    }
    map.setPaintProperty('drone-satellite-layer', 'raster-opacity', opacity);
  }, 50); // Adjust the interval for smoother or faster fade-in
} 

function showToaster(message, duration = 3000) {
  const toaster = document.getElementById('toaster');
  toaster.textContent = message;
  toaster.classList.add('show');

  setTimeout(() => {
    toaster.classList.remove('show');
  }, duration);
} 
</script> 

<script>
// === FEATURED LOT POLYGON PULSE (ASYNC) ===

// Utility to create a polygon feature from a lot
function featuredPolygonFeature(lot) {
  const coords = [...lot.coords];
  if (
    coords.length < 3 ||
    coords[0][0] !== coords[coords.length - 1][0] ||
    coords[0][1] !== coords[coords.length - 1][1]
  ) {
    coords.push(coords[0]); // Ensure closed polygon
  }

  return {
    type: 'Feature',
    geometry: {
      type: 'Polygon',
      coordinates: [coords]
    },
    properties: {
      name: lot.name,
      phase: Math.random() * Math.PI * 2, // ‚úÖ random delay per lot
      opacity: 0.5 // initial value for fill-opacity
    }
  };
}

// Main function ‚Äî still named as requested
function addFeaturedLotsLayer(map) {
  const featuredLots = lotData.filter(lot => lot.featured);
  if (featuredLots.length === 0) return;

  const features = featuredLots.map(featuredPolygonFeature);

  map.addSource('featured-lots', {
    type: 'geojson',
    data: {
      type: 'FeatureCollection',
      features
    }
  });

  // Orange fill with pulsating opacity
  map.addLayer({
    id: 'featured-lots-layer',
    type: 'fill',
    source: 'featured-lots',
    paint: {
      'fill-color': '#ff8400',
      'fill-opacity': ['get', 'opacity']
    }
  }, 'lots-final');

// Get the list of all layers
const layers = map.getStyle().layers;
let insertBefore = null;

for (let i = 0; i < layers.length; i++) {
  if (layers[i].id === 'sold-x-layer') {
    insertBefore = layers[i + 1]?.id || null;
    break;
  }
}

// Add the orange outline *after* lots-final
map.addLayer({
  id: 'featured-lots-outline',
  type: 'line',
  source: 'featured-lots',
  paint: {
    'line-color': '#ff8400',
    'line-width': 2,
    'line-opacity': 1
  }
}, insertBefore); // will insert after lots-final

  startPolygonPulse(map);
}




// Animate each polygon's opacity independently
function startPolygonPulse(map) {
  let t = 0;

  function frame() {
    t += 0.05;

    const source = map.getSource('featured-lots');
    if (!source || !source._data) return;

    const updated = {
      ...source._data,
      features: source._data.features.map(f => {
        const phase = f.properties?.phase ?? 0;
        const opacity = 0.3 + Math.sin(t + phase) * 0.2;
        return {
          ...f,
          properties: {
            ...f.properties,
            opacity
          }
        };
      })
    };

    source.setData(updated); // ‚¨Ö update feature data with new opacities
    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}
</script>



<script>
  // MODAL HERE
let lastOffset = [0, 0];

function adjustMapForModal() {
  if (!map) {
    console.error('Map not initialized');
    return;
  }

  const isMobile = window.innerWidth < 768;

  const offset = isMobile
    ? [0, -window.innerHeight * 0.23] // mobile: pan upward
    : [-240, 0];                      // desktop: pan left

  lastOffset = offset;

  console.log('üîÑ map.panBy:', offset);
  map.panBy(offset, { duration: 800 });
}
 
const modal = document.getElementById('lotModal');
const modalInfo = document.getElementById('modalInfo');
const customScrollbar = document.getElementById('customScrollbar');
const customScrollthumb = document.getElementById('customScrollthumb');
const loadingSpinner = document.getElementById('loadingSpinner');
const lotDetails = document.getElementById('lotDetails');
const backButton = document.getElementById('backButton');
const detailNumber = document.getElementById('detailNumber');
const detailSize = document.getElementById('detailSize');
const detailPrice = document.getElementById('detailPrice');
const detailAvailability = document.getElementById('detailAvailability');
const headerLotNumber = document.getElementById('headerLotNumber');

const cloneCount = 5;
let baseLots = [];
let lots = [];
let isDataLoaded = false;
let previousMapView = null; // for "Back" button inside modal
let preModalView = null;    // for closing modal completely
let isDragging = false;
let isScrollbarDragging = false;
let dragStartY = 0;
let dragStartScroll = 0;
let scrollTimeout;
let scrollHandlerAttached = true;
let clampCooldown = false;
let infoMode = false;

function extractLotNumber(lotName) {
  const num = lotName.replace(/^lot/i, '');
  return parseInt(num, 10) || 0;
}

async function fetchLots() {
  try {
    loadingSpinner.style.display = 'block';
    modalInfo.style.opacity = '0.5';
    
    await window.supabaseReady;
    
    // Fetch ALL data (including images) upfront
    const { data, error } = await window.supabaseClient
      .from('lots')
      .select('lot_name, rSize, millones, availability, nickname, subtitle, image')
      .order('lot_name', { ascending: true });
    
    if (error) throw error;
    
    baseLots = data.map(lot => ({
      number: extractLotNumber(lot.lot_name),
      size: lot.rSize,
      price: lot.millones,
      availability: lot.availability,
      // Store all detail data upfront
      detailData: {
        nickname: lot.nickname,
        subtitle: lot.subtitle,
        image: lot.image
      }
    }));
    
    updateLotsArray();
    isDataLoaded = true;
    console.log('‚úÖ Pre-loaded all lots + images');
  } catch (error) {
    console.error('Error fetching lots:', error);
    // Fallback dummy data
    baseLots = Array.from({ length: 10 }, (_, i) => ({
      number: 100 + i,
      size: '150',
      price: '1.5',
      availability: 'available',
      detailData: {
        nickname: `Lot ${100 + i}`,
        image: 'https://via.placeholder.com/800x400?text=No+Image'
      }
    }));
    updateLotsArray();
  } finally {
    loadingSpinner.style.display = 'none';
    modalInfo.style.opacity = '1';
  }
}

function updateLotsArray() {
  lots = [
    ...baseLots.slice(-cloneCount).map(l => ({ ...l, clone: true })),
    ...baseLots,
    ...baseLots.slice(0, cloneCount).map(l => ({ ...l, clone: true }))
  ];
}

function setupLotClickHandlers() {
  const allRows = document.querySelectorAll('.info-row');

  allRows.forEach(row => {
    row.addEventListener('click', async (e) => {
      if (!row.classList.contains('active-center')) return;

      const index = row.dataset.index;
      const lot = lots[index];
      const status = (lot.availability ?? '').toLowerCase();

      if (status === 'sold') return;

      if (status === 'available') {
        showCta("¬°Este lote tambi√©n tiene mucho potencial\n¬ølo vemos juntos? Escr√≠benos por WhatsApp.");
        return;
      }

      if (status === 'featured') {
        // Save map state
        if (map && map.getCenter) {
          preModalView = {
            center: map.getCenter().toArray(),
            zoom: map.getZoom(),
            bearing: map.getBearing(),
            pitch: map.getPitch()
          };
        }

        const lotNumber = lot.number;
        const lotMapIndex = lotData.findIndex(l => extractLotNumber(l.name) === lotNumber);
        
        if (lotMapIndex !== -1 && lotData[lotMapIndex].center && map) {
          previousMapView = {
            center: map.getCenter().toArray(),
            zoom: map.getZoom(),
            bearing: map.getBearing(),
            pitch: map.getPitch()
          };

          const [lng, lat] = lotData[lotMapIndex].center;
          currentLotIndex = lotMapIndex;

// 1. First start the map animation
await new Promise(resolve => {
  map.once('moveend', resolve);

  const isDesktop = window.innerWidth >= 768;
  const isExpanded = document.getElementById('lotModal').classList.contains('expanded');

  const xOffset = isDesktop ?  310 : 0; // üëâ more pan on desktop
  const yOffset = isDesktop ? 0 : 180;                       // keep vertical nudged on mobile

  map.easeTo({
    center: [lng, lat],
    zoom: 18.8,
    speed: 1.2,
    curve: 1.5,
    offset: [xOffset, yOffset]
  });
});

          // 2. Then add labels and show detail view
        
          showDetailViewForLot(index);
        } else {
          // Fallback if map data isn't available
          showDetailViewForLot(index);
        }
      }
    });
  });
}

async function showDetailViewForLot(index) {
  // Clear previous details
  lotDetails.innerHTML = '';
  isDetailOpen = true;
  // Get the pre-fetched lot data
  const lot = lots[index];
  const lotMapData = lotData.find(l => extractLotNumber(l.name) === lot.number);
  const detailData = lot.detailData || {};

  // Create container for detail view
  const detailContainer = document.createElement('div');
  detailContainer.className = 'detail-container';

  // ===== HEADER SECTION =====
  const headerSection = document.createElement('div');
  headerSection.className = 'detail-header';

  // Tag row with LALALAND SELECTION and nickname
  headerSection.innerHTML = `
    <div class="tag-row">
      ${lot.availability === 'Featured' ? '<div class="featured-tag">SELECCI√ìN LALALAND</div>' : ''}
      <div class="nickname">${detailData.nickname || 'Lot ' + lot.number}</div>
    </div>
    ${detailData.subtitle ? `
      <div class="subtitle-row">${detailData.subtitle}</div>
    ` : ''}
  `;
  detailContainer.appendChild(headerSection);

  // ===== PRICE/SIZE ROW =====
  const detailRow = document.createElement('div');
  detailRow.className = 'detail-data-row';
  
  // Calculate price per m2
  const price = parseFloat(lot.price);
  const size = parseFloat(lot.size);
  let pricePerM2Formatted = 'N/A';
  
  if (price > 0 && size > 0) {
    const pricePerM2 = (price * 1000000) / size;
    pricePerM2Formatted = `$${pricePerM2.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ",")}<sup class="sup">/M2</sup>`;
  }

  // Build the price/size row
  detailRow.innerHTML = `
    <div class="lot-left">
      <div class="lote-label">LOTE</div>
      <div class="lote-number">${lot.number}</div>
    </div>
    
    <div class="lot-middle">
      ${lot.size}<span class="sup">M2</span>
    </div>
    
    <div class="lot-price">
      <div class="price-wrapper">
        <span class="price">$${lot.price}</span>
        <span class="mdp">MDP</span>
      </div>
    </div>
    
    <div class="price-per-m2-column">
      ${pricePerM2Formatted}
    </div>
  `;
  detailContainer.appendChild(detailRow);

  // ===== IMAGE ROW =====
  const image = new Image();  // Create an image element
  image.src = detailData.image || lotMapData.image || 'https://via.placeholder.com/800x400?text=No+Image+Available';
  image.onload = function() {
    // This runs once the image is fully loaded

    // Add image to the DOM
    const extraRow = document.createElement('div');
    extraRow.className = 'detail-extra-row';
    extraRow.innerHTML = `
      <img src="${image.src}" class="lot-image" onerror="this.src='https://via.placeholder.com/800x400?text=Image+Not+Available'">
    `;
    detailContainer.appendChild(extraRow);

    // Add the Agendar Cita button below the image after the image is loaded
    const scheduleButton = document.createElement('button');
    scheduleButton.id = 'scheduleAppointmentBtn';
    scheduleButton.className = 'schedule-appointment-btn';
    scheduleButton.innerText = 'Agendar Visita';

    detailContainer.appendChild(scheduleButton);

    // Add to DOM after the image is loaded
    lotDetails.appendChild(detailContainer);

    // Activate modal view
    document.querySelector('.modal-content-wrapper').classList.add('show-details');
    lotDetails.classList.add('active');
    backButton.style.display = 'flex';
    document.querySelector('.plus-button').style.display = 'flex';
    scrollHandlerAttached = false;

    // Add side length labels if we have map data
    if (lotMapData) {
      addSideLengthLabels(lotMapData);
    }

    // === Step 4: Add the Event Listener for the "Agendar Cita" Button ===
    document.getElementById('scheduleAppointmentBtn').addEventListener('click', function () {
      // Hide lot details and show Calendly
      document.getElementById('lotDetails').style.display = 'none'; // Hide lot details

      // Show Calendly widget
      document.getElementById('calendlyEmbed').style.display = 'block';

      // Initialize Calendly widget
      loadCalendlyWidget({ lot, detailData });
    });
  };

  // If the image fails to load, use the fallback image
  image.onerror = function() {
    image.src = 'https://via.placeholder.com/800x400?text=Image+Not+Available';
  };
}



backButton.addEventListener('click', () => {
  const modal = document.getElementById('lotModal');
  const plusIcon = document.querySelector('.plus-button .plus-icon');
  const minusIcon = document.querySelector('.plus-button .minus-icon');
  const calendly = document.getElementById('calendlyEmbed');

  isDetailOpen = false;
  removeSideLengthLabels(); // keep it

  // Check if we're in the Calendly view
  if (calendly && calendly.style.display === 'block') {
    // Close Calendly and return to lot details
    calendly.style.display = 'none';
    document.getElementById('lotDetails').style.display = 'block';
    return; // exit here to avoid further actions
  }

  // Reset expanded state if needed
  if (modal.classList.contains('expanded')) {
    modal.classList.remove('expanded');
    plusIcon.style.display = 'block';
    minusIcon.style.display = 'none';
  }

  // Return to list view
  headerLotNumber.style.display = 'none';
  document.querySelector('.modal-content-wrapper').classList.remove('show-details');
  lotDetails.classList.remove('active');
  backButton.style.display = 'none';
  document.querySelector('.plus-button').style.display = 'none';

  // Re-enable scrolling
  scrollHandlerAttached = true;

  // Remove side length labels
  removeSideLengthLabels();

  // Return to previous map zoom state
  if (previousMapView && map) {
    map.flyTo({
      center: previousMapView.center,
      zoom: previousMapView.zoom,
      bearing: previousMapView.bearing,
      pitch: previousMapView.pitch,
      speed: 1.2,
      curve: 1.5
    });
    previousMapView = null;
  }
});


function render() {
  modalInfo.innerHTML = '';
  lots.forEach((lot, i) => {
    const row = document.createElement('div');
    row.classList.add('info-row');
    row.dataset.index = i;
    row.dataset.baseIndex = lot.clone ? -1 : baseLots.findIndex(l => l.number === lot.number);

    const isFeatured = lot.availability === 'Featured';
    const isSold = lot.availability === 'Sold';

    if (isFeatured) row.classList.add('info-row--featured');

    row.innerHTML = `
      <div class="lot-left">
        <div class="lote-label">LOTE</div>
        <div class="lote-number">${lot.number}</div>
      </div>

      <div class="lot-middle ${isSold ? 'lot-middle--sold' : ''}">
        ${
          isSold
            ? `<div style="font-size:48px; font-weight:700; color:#ff8400;">VENDIDO</div>`
            : `${lot.size}<span class="sup">M2</span>`
        }
      </div>

      <div class="lot-price ${isSold ? 'lot-price--hidden' : ''}">
        <div class="price-wrapper">
          <span class="price">$${lot.price}</span>
          <span class="mdp">MDP</span>
        </div>
      </div>

      <div class="arrow ${isFeatured ? '' : 'arrow-hidden'}">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 12">
          <path d="M4 3 L7 6 L4 9" stroke="#888" stroke-width="1" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>
    `;

    if (isFeatured) {
      const left = document.createElement('div');
      left.classList.add('border-left');
      row.appendChild(left);

      const top = document.createElement('div');
      top.classList.add('border-top');
      row.appendChild(top);

      const label = document.createElement('div');
      label.classList.add('featured-label');
      label.textContent = 'SELECCI√ìN LALALAND';
      row.appendChild(label);
    }

    modalInfo.appendChild(row);
  });
  
  setupLotClickHandlers();
  updateScrollbar();
}

function updateScrollbar() {
  const containerHeight = modalInfo.clientHeight;
  const contentHeight = modalInfo.scrollHeight;
  const scrollTop = modalInfo.scrollTop;

  if (baseLots.length === 0 || contentHeight === 0) {
    customScrollthumb.style.height = '0px';
    customScrollthumb.style.transform = 'translateY(0)';
    return;
  }

  const rowHeight = contentHeight / lots.length;
  const bufferHeight = rowHeight * cloneCount;
  const baseHeight = rowHeight * baseLots.length;

  const thumbHeight = Math.max(20, (containerHeight / contentHeight) * containerHeight);
  customScrollthumb.style.height = `${thumbHeight}px`;

  let baseScrollTop = ((scrollTop - bufferHeight) % baseHeight);
  if (baseScrollTop < 0) baseScrollTop += baseHeight;
  baseScrollTop = Math.min(baseScrollTop, baseHeight - containerHeight);

  const scrollRatio = baseScrollTop / (baseHeight - containerHeight);
  const thumbPosition = scrollRatio * (containerHeight - thumbHeight);

  customScrollthumb.style.transform = `translateY(${thumbPosition}px)`;
}

function scrollToBaseIndex(baseIndex, smooth = true) {
  if (baseLots.length === 0) return;
  
  const actualIndex = baseIndex + cloneCount;
  const target = modalInfo.querySelector(`.info-row[data-index="${actualIndex}"]`);

  if (target) {
    target.offsetWidth;
    target.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto', block: 'center' });

    if (!smooth) {
      setTimeout(() => {
        highlightCenter();
        updateScrollbar();
      }, 0);
    }
  }
}

const animatedFeaturedLots = new Set();

function highlightCenter(isClamping = false) {
  const rows = [...modalInfo.querySelectorAll('.info-row')];
  const containerRect = modalInfo.getBoundingClientRect();
  const centerY = containerRect.top + containerRect.height / 2;
  const tolerance = containerRect.height * 0.1;

  let closestRow = null;
  let minDistance = Infinity;

  // Clear previous active states
  rows.forEach(row => {
    row.classList.remove('active');
    row.classList.remove('active-center');
  });

  // Find closest row to center
  rows.forEach(row => {
    const rect = row.getBoundingClientRect();
    const rowCenter = (rect.top + rect.bottom) / 2;
    const dist = Math.abs(rowCenter - centerY);

    if (dist < minDistance) {
      minDistance = dist;
      closestRow = row;
    }
  });

  // If we found a row close enough to center
  if (closestRow && minDistance <= tolerance) {
    // Mark as active (for styling) and active-center (for click handling)
    closestRow.classList.add('active');
    closestRow.classList.add('active-center');

    // Handle featured lot animation
    if (closestRow.classList.contains('info-row--featured')) {
      const index = closestRow.dataset.index;

      if (!animatedFeaturedLots.has(index)) {
        void closestRow.offsetWidth; // Trigger reflow
        closestRow.classList.add('animate-featured');
        animatedFeaturedLots.add(index);
      } else {
        closestRow.classList.add('animate-featured');
      }
    }

    // Sync polygon hover with centered row
    const baseIndex = parseInt(closestRow.dataset.baseIndex, 10);
    if (!isNaN(baseIndex)) {
      const lot = baseLots[baseIndex];
      if (lot && window.map && lotData) {
        const mapIndex = lotData.findIndex(l => extractLotNumber(l.name) === lot.number);
        if (mapIndex !== -1) {
          if (hoveredId !== null && hoveredId !== mapIndex) {
            map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
          }
          map.setFeatureState({ source: 'lots-final', id: mapIndex }, { hover: true });
          hoveredId = mapIndex;
        }
      }
    }
  }
}

function clampScroll() {
  if (baseLots.length === 0 || lots.length === 0 || clampCooldown) return;

  const { scrollTop, scrollHeight, clientHeight } = modalInfo;
  const lotHeight = scrollHeight / lots.length;
  const bufferHeight = lotHeight * cloneCount;
  const baseHeight = lotHeight * baseLots.length;

  let virtualScroll = scrollTop;
  
  if (scrollTop < bufferHeight) {
    clampCooldown = true;
    virtualScroll = scrollTop + baseHeight;
  } 
  else if (scrollTop + clientHeight >= scrollHeight - bufferHeight) {
    clampCooldown = true;
    virtualScroll = scrollTop - baseHeight;
  }

  if (clampCooldown) {
    modalInfo.removeEventListener('scroll', handleScroll);
    modalInfo.scrollTop = virtualScroll;
    
    requestAnimationFrame(() => {
      highlightCenter(true);
      updateScrollbar();
      
      setTimeout(() => {
        modalInfo.addEventListener('scroll', handleScroll);
        clampCooldown = false;
      }, 50);
    });
  }
}

function stopDragging() {
  if (!isDragging && !isScrollbarDragging) return;
  
  isDragging = false;
  isScrollbarDragging = false;
  customScrollthumb.classList.remove('active');
  modalInfo.classList.remove('dragging');

  const rows = [...modalInfo.querySelectorAll('.info-row')];
  const containerRect = modalInfo.getBoundingClientRect();
  const centerY = containerRect.top + containerRect.height / 2;

  let closestBaseIndex = 0;
  let closestDistance = Infinity;

  rows.forEach(row => {
    if(row.dataset.baseIndex === "-1") return;
    const rect = row.getBoundingClientRect();
    const rowCenter = (rect.top + rect.bottom) / 2;
    const dist = Math.abs(rowCenter - centerY);
    if (dist < closestDistance) {
      closestDistance = dist;
      closestBaseIndex = parseInt(row.dataset.baseIndex, 10);
    }
  });

  scrollToBaseIndex(closestBaseIndex, true);
}

customScrollthumb.addEventListener('pointerdown', (e) => {
  e.stopPropagation();
  isScrollbarDragging = true;
  dragStartY = e.clientY;
  dragStartScroll = modalInfo.scrollTop;
  customScrollthumb.classList.add('active');
  
  document.addEventListener('pointermove', handleScrollDrag);
  document.addEventListener('pointerup', stopScrollDrag);
  e.preventDefault();
});

function handleScrollDrag(e) {
  if (isScrollbarDragging) {
    const deltaY = e.clientY - dragStartY;
    const scrollRatio = deltaY / modalInfo.clientHeight;
    modalInfo.scrollTop = dragStartScroll + (scrollRatio * modalInfo.scrollHeight);
  }
  e.preventDefault();
}

function stopScrollDrag() {
  if (isScrollbarDragging) {
    isScrollbarDragging = false;
    customScrollthumb.classList.remove('active');
    document.removeEventListener('pointermove', handleScrollDrag);
    document.removeEventListener('pointerup', stopScrollDrag);
    stopDragging();
  }
}

modalInfo.addEventListener('pointerdown', (e) => {
  if (e.target.closest('.custom-scrollbar')) return;
  isDragging = true;
  dragStartY = e.clientY;
  dragStartScroll = modalInfo.scrollTop;
  modalInfo.classList.add('dragging');
  document.addEventListener('pointermove', handleContentDrag);
  document.addEventListener('pointerup', stopContentDrag);
  e.preventDefault();
});

function handleContentDrag(e) {
  if (isDragging) {
    const deltaY = dragStartY - e.clientY;
    modalInfo.scrollTop = dragStartScroll + deltaY;

    const scrollTop = modalInfo.scrollTop;
    const scrollHeight = modalInfo.scrollHeight;
    const clientHeight = modalInfo.clientHeight;
    const lotHeight = scrollHeight / lots.length;
    const bufferHeight = lotHeight * cloneCount;
    const baseHeight = lotHeight * baseLots.length;

    if (scrollTop < bufferHeight) {
      modalInfo.scrollTop = scrollTop + baseHeight;
      dragStartScroll = modalInfo.scrollTop;
      dragStartY = e.clientY;
    } else if (scrollTop + clientHeight >= scrollHeight - bufferHeight) {
      modalInfo.scrollTop = scrollTop - baseHeight;
      dragStartScroll = modalInfo.scrollTop;
      dragStartY = e.clientY;
    }
  }
  e.preventDefault();
}

function stopContentDrag() {
  if (isDragging) {
    isDragging = false;
    modalInfo.classList.remove('dragging');
    document.removeEventListener('pointermove', handleContentDrag);
    document.removeEventListener('pointerup', stopContentDrag);
    stopDragging();
  }
}

function handleScroll() {
  if (!scrollHandlerAttached) return;
  
  requestAnimationFrame(() => {
    highlightCenter();
    updateScrollbar();
    
    if (!isDragging && !isScrollbarDragging) {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        clampScroll();
      }, 100);
    }
  });
}

modalInfo.addEventListener('scroll', handleScroll);

modalInfo.addEventListener('wheel', (e) => {
  e.preventDefault();
  if(isDragging || isScrollbarDragging) return;

  const rows = [...modalInfo.querySelectorAll('.info-row')];
  const containerRect = modalInfo.getBoundingClientRect();
  const centerY = containerRect.top + containerRect.height / 2;
  
  let closestRow = null;
  let minDistance = Infinity;
  
  rows.forEach(row => {
    const rect = row.getBoundingClientRect();
    const distance = Math.abs((rect.top + rect.bottom)/2 - centerY);
    if (distance < minDistance) {
      minDistance = distance;
      closestRow = row;
    }
  });

  if (!closestRow) return;
  
  const currentIndex = parseInt(closestRow.dataset.index);
  const direction = Math.sign(e.deltaY);
  let nextIndex = currentIndex + direction;

  if (nextIndex < 0) {
      nextIndex = lots.length - 1;
  } else if (nextIndex >= lots.length) {
      nextIndex = 0;
  }
  
  modalInfo.querySelector(`.info-row[data-index="${nextIndex}"]`)?.scrollIntoView({
    behavior: 'auto',
    block: 'center'
  });
});

function openModal(lot = null, baseIndex = 0) {
  const wasHidden = !modal.classList.contains('show');

  // üßπ Reset modal state (your existing code)
  headerLotNumber.style.display = 'none';
  document.querySelector('.modal-content-wrapper').classList.remove('show-details');
  lotDetails.classList.remove('active');
  backButton.style.display = 'none';
  document.querySelector('.plus-button').style.display = 'none';
  modal.classList.remove('expanded');
  scrollHandlerAttached = true;
  document.getElementById('calendlyEmbed').style.display = 'none';
  document.getElementById('lotDetails').style.display = 'block';

  // üî∂ If we're going to list mode, clear previous INFO content *before showing the modal*
  const modalInfoEl = document.getElementById('modalInfo');
  const customScrollbarEl = document.getElementById('customScrollbar');
  const spinnerEl = document.getElementById('loadingSpinner');

  if (!infoMode) {
    // Pre-clear to avoid flashing old info content
    modalInfoEl.innerHTML = '';
    customScrollbarEl.style.display = '';   // make sure scrollbar is back for list
    spinnerEl.style.display = 'block';      // show spinner immediately
    modalInfoEl.style.opacity = '0';        // hide list container until rendered
  }

  // Now show the modal
  modal.classList.add('show');
  modal.style.display = 'block';
  if (wasHidden) adjustMapForModal();

  // üî∏ INFO MODE short-circuit (your existing block)
  if (infoMode) {
    modal.classList.add('expanded');
    modalInfoEl.innerHTML = `
      <div style="padding:20px; color:#8a8880;">
        <h2 style="color:#a17345; margin-bottom:10px;">Sobre Santte 2</h2>
        <p>Bienvenido a Santte 2. Aqu√≠ puedes poner descripci√≥n, ubicaci√≥n, beneficios, etc.</p>
        <p>Para m√°s informaci√≥n cont√°ctanos por WhatsApp o visita nuestras oficinas.</p>
      </div>
    `;
    customScrollbarEl.style.display = 'none';
    spinnerEl.style.display = 'none';
    scrollHandlerAttached = false;
    infoMode = false;
    return;
  }

  // üëá Normal list flow
  const doScrollAndHighlight = () => {
    const scrollToIndex = lot
      ? baseLots.findIndex(l => l.number === extractLotNumber(lot.name))
      : baseIndex;

    scrollToBaseIndex(scrollToIndex, false);

    // show list once content exists
    setTimeout(() => {
      highlightCenter();
      updateScrollbar();
      spinnerEl.style.display = 'none';   // hide spinner after render
      modalInfoEl.style.opacity = '1';    // fade in the list
    }, 0);
  };

  if (!isDataLoaded) {
    fetchLots().then(() => {
      render();
      requestAnimationFrame(() => {
        requestAnimationFrame(doScrollAndHighlight);
      });
    });
  } else {
    render();
    requestAnimationFrame(() => {
      requestAnimationFrame(doScrollAndHighlight);
    });
  }
}

   


function closeModal() {
  const modal = document.getElementById('lotModal');
  const plusIcon = document.querySelector('.plus-button .plus-icon');
  const minusIcon = document.querySelector('.plus-button .minus-icon');


isDetailOpen = false;
removeSideLengthLabels(); // already present ‚Äî keep it

  // Reset expanded state and icons
  modal.classList.remove('expanded');
  plusIcon.style.display = 'block';
  minusIcon.style.display = 'none';


  // Remove side length labels
  removeSideLengthLabels();

  // Restore original view before modal opened
  if (preModalView && map) {
    map.flyTo({
      center: preModalView.center,
      zoom: preModalView.zoom,
      bearing: preModalView.bearing,
      pitch: preModalView.pitch,
      speed: 1.2,
      curve: 1.5
    });

    // After the flyTo animation ends, apply panBy to compensate for the modal shift
    map.once('moveend', () => {
      if (lastOffset) {
        map.panBy([-lastOffset[0], -lastOffset[1]], { duration: 800 });
        lastOffset = [0, 0];
      }
    });

    preModalView = null;
  } else if (map && lastOffset) {
    // fallback if no preModalView is saved
    map.panBy([-lastOffset[0], -lastOffset[1]], { duration: 800 });
    lastOffset = [0, 0];
  }

  // Close modal
  modal.classList.remove('show');
  setTimeout(() => modal.style.display = 'none', 300);
}

function handlePlusButton() {
  const modal = document.getElementById('lotModal');
  const plusIcon = document.querySelector('.plus-button .plus-icon');
  const minusIcon = document.querySelector('.plus-button .minus-icon');
  
  // Toggle expanded state
  modal.classList.toggle('expanded');
  
  // Toggle between plus and minus icon
  if (modal.classList.contains('expanded')) {
    plusIcon.style.display = 'none';
    minusIcon.style.display = 'block';
  } else {
    plusIcon.style.display = 'block';
    minusIcon.style.display = 'none';
  }
 }

function loadCalendlyWidget({ lot, detailData }) {
  const container = document.getElementById('calendlyEmbed');
  const iframe = document.getElementById('calendly-iframe');
  
  // Build the Calendly URL with all hiding parameters
  const calendlyUrl = new URL('https://calendly.com/lalaland_/santte2');
  calendlyUrl.searchParams.set('hide_gdpr_banner', '1');
  calendlyUrl.searchParams.set('background_color', 'fcfaf3');
  calendlyUrl.searchParams.set('text_color', '1a1a1a');
  calendlyUrl.searchParams.set('primary_color', 'ff8400');
  
  // Load the iframe
  iframe.src = calendlyUrl.toString();
  container.style.display = 'block';
  

  
  // Nuclear option to remove branding (runs every 500ms)
  const checkForBranding = setInterval(() => {
    try {
      const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
      const elements = iframeDoc.querySelectorAll('.calendly-branding, .calendly-cookie-banner');
      elements.forEach(el => el.remove());
    } catch(e) {
      // Cross-origin error - we'll rely on URL parameters
      clearInterval(checkForBranding);
    }
  }, 500);
}





</script>
 
 
<script>
// RESET GPS + INFO (reusing #lotModal)
document.addEventListener('DOMContentLoaded', () => {
  const modal    = document.getElementById('lotModal');
  const resetBtn = document.getElementById('resetViewBtn');
  const infoBtn  = document.getElementById('infoBtn'); // left orange button
  const gpsBtn   = document.getElementById('gpsButton'); 

  // Open lot modal in "info mode" (replace list content)
infoBtn.addEventListener('click', () => {
  infoMode = true;        // tell openModal to skip list rendering
  openModal();            // reuse the same modal

  // Force expanded mode
  modal.classList.add('expanded');

  const modalInfo = document.getElementById('modalInfo');
  const customScrollbar = document.getElementById('customScrollbar');

  // Replace list with your static info content
  modalInfo.innerHTML = `
    <div style="padding:20px; color:#8a8880;">
      <h2 style="color:#a17345; margin-bottom:10px;">Sobre Santte 2</h2>
      <p>Bienvenido a Santte 2. Aqu√≠ puedes poner descripci√≥n, ubicaci√≥n, beneficios, etc.</p>
      <p>Para m√°s informaci√≥n cont√°ctanos por WhatsApp o visita nuestras oficinas.</p>
    </div>
  `;

  // Hide scrollbar for static content
  customScrollbar.style.display = 'none';
});

 
  // Hide/show floating buttons while modal is expanded (mobile)
const observer = new MutationObserver(() => {
  if (window.innerWidth < 768) {
    if (modal.classList.contains('expanded')) {
      resetBtn.classList.add('hide');
      infoBtn.classList.add('hide');
      gpsBtn.classList.add('hide');
    } else {
      resetBtn.classList.remove('hide');
      infoBtn.classList.remove('hide');
      gpsBtn.classList.remove('hide');
    }
  } else {
    resetBtn.classList.remove('hide');
    infoBtn.classList.remove('hide');
    gpsBtn.classList.remove('hide');
  }
});

  observer.observe(modal, { attributes: true, attributeFilter: ['class'] });

  // Reset map view (existing behavior)
  const initialZoom = window.innerWidth >= 768 ? 17 : 16.45;
  resetBtn.addEventListener('click', () => {
    if (!window.map) return;
    map.flyTo({
      center: [-100.15994, 25.461823],
      zoom: initialZoom,
      bearing: 0,
      pitch: 0,
      speed: 1.2,
      curve: 1.5
    });
  });
});
</script>





<script>
(() => {
  'use strict';

  // ===== Namespace =====
  const NS = (window.__LL_GPS__ = window.__LL_GPS__ || {});

// ---- simple event bus
NS._listeners = {};
NS.on = function (evt, cb) { (NS._listeners[evt] ||= []).push(cb); };
NS.emit = function (evt, payload) { (NS._listeners[evt] || []).forEach(fn => { try { fn(payload); } catch {} }); };

  // Config
  NS.lotCenter = NS.lotCenter || [-100.15994, 25.461823];
  NS.maxDistanceMeters = NS.maxDistanceMeters || 1000;

  // State
  NS.gpsWatchId = null;
  NS.lastUserLngLat = null;
  NS.hasInitialFly = false;
  NS.userHeading = null;
  NS.headingListenerAttached = false;
  NS.farAwayTimer = null;
  NS.farWarned = false;
  NS.headingMarker = null;
  
  // Smoothing (for Android)
  NS.headingSmoothingFactor = 0.15;
  NS.lastSmoothedHeading = null;

  // Utils
  const safeToaster = (msg, duration = 3000) => {
    try { if (typeof window.showToaster === 'function') window.showToaster(msg, duration); } catch {}
  };

  // Distance calculation
  const distanceMeters = (a, b) => {
    const [lng1, lat1] = a, [lng2, lat2] = b;
    const R = 6371000, œÜ1 = lat1 * Math.PI / 180, œÜ2 = lat2 * Math.PI / 180;
    const ŒîœÜ = (lat2 - lat1) * Math.PI / 180, ŒîŒª = (lng2 - lng1) * Math.PI / 180;
    const a_ = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
              Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    return R * 2 * Math.atan2(Math.sqrt(a_), Math.sqrt(1 - a_));
  };

  // Smooth heading
  const smoothHeading = (newHeading) => {
    if (NS.lastSmoothedHeading === null) {
      NS.lastSmoothedHeading = newHeading;
    } else {
      const diff = ((newHeading - NS.lastSmoothedHeading + 540) % 360) - 180;
      NS.lastSmoothedHeading = (NS.lastSmoothedHeading + diff * NS.headingSmoothingFactor) % 360;
    }
    return NS.lastSmoothedHeading;
  };

  // ===== Core Functions =====
  function ensureUserLocationLayers() {
    if (!window.map) return;

    if (!map.getSource('ll-user-location')) {
      map.addSource('ll-user-location', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });
    }

    if (!map.getLayer('ll-user-accuracy')) {
      map.addLayer({
        id: 'll-user-accuracy',
        type: 'circle',
        source: 'll-user-location',
        paint: {
          'circle-radius': ['interpolate', ['linear'], ['zoom'],
            15, ['coalesce', ['get', 'accRadiusZ15'], 2],
            22, ['coalesce', ['get', 'accRadiusZ22'], 500]
          ],
          'circle-color': '#1a73e826',
          'circle-stroke-color': '#1a73e8',
          'circle-stroke-width': 1
        },
        filter: ['==', ['get', 'role'], 'accuracy']
      });
    }

    if (!map.getLayer('ll-user-dot')) {
      map.addLayer({
        id: 'll-user-dot',
        type: 'circle',
        source: 'll-user-location',
        paint: {
          'circle-radius': 8,
          'circle-color': '#4285F4',
          'circle-stroke-color': '#FFFFFF',
          'circle-stroke-width': 2
        },
        filter: ['==', ['get', 'role'], 'point']
      });
    }

    ensureHeadingMarker();
  }

  // Google Maps-style cone (wide part forward, pointy end at dot)
  function ensureHeadingMarker() {
  if (!window.map || NS.headingMarker) return;

  const el = document.createElement('div');
  el.style.width = '70px';
  el.style.height = '50px';
  el.style.pointerEvents = 'none';
  el.style.zIndex = '1000';
  el.innerHTML = `
    <svg viewBox="0 0 70 50" width="70" height="50">
      <!-- Solid wide cone (140¬∞ opening) -->
      <path d="M35 45 L5 5 L65 5 Z" 
            fill="#1a73e8" 
            opacity="0.6"
            stroke="none"/>
    </svg>
  `;

  NS.headingMarker = new mapboxgl.Marker({
    element: el,
    offset: [0, -25],
    anchor: 'center'
  })
    .setRotationAlignment('map')
    .setPitchAlignment('map')
    .setLngLat(NS.lotCenter)
    .addTo(map);
}

  // Handle compass data
  async function ensureHeadingListener() {
    if (NS.headingListenerAttached) return;

    const onOrientation = (e) => {
      let rawHeading;
      if (typeof e?.webkitCompassHeading === 'number') {
        rawHeading = e.webkitCompassHeading; // iOS
      } 
      else if (typeof e?.alpha === 'number') {
        rawHeading = (360 - e.alpha) % 360; // Android
      }
      else {
        return;
      }

      NS.userHeading = smoothHeading(rawHeading);

      if (NS.lastUserLngLat) {
        updateUserLocation(NS.lastUserLngLat[0], NS.lastUserLngLat[1]);
      }
    };

    if ('ondeviceorientationabsolute' in window) {
      window.addEventListener('deviceorientationabsolute', onOrientation, true);
    } else {
      window.addEventListener('deviceorientation', onOrientation, true);
    }
    NS.headingListenerAttached = true;
  }

  // Update cone direction (no 180¬∞ offset needed!)
  function updateUserLocation(lng, lat, accuracyMeters = 10) {
    const src = map?.getSource('ll-user-location');
    if (!src) return;

    src.setData({
      type: 'FeatureCollection',
      features: [
        { type: 'Feature', properties: { role: 'point' }, geometry: { type: 'Point', coordinates: [lng, lat] } },
        {
          type: 'Feature',
          properties: {
            role: 'accuracy',
            accRadiusZ15: Math.min(12, Math.max(2, accuracyMeters / 6)),
            accRadiusZ22: Math.min(600, Math.max(50, accuracyMeters * 6))
          },
          geometry: { type: 'Point', coordinates: [lng, lat] }
        }
      ]
    });

    // Directly use the heading (cone SVG is already correctly oriented)
    if (NS.headingMarker) {
      NS.headingMarker.setLngLat([lng, lat]);
      NS.headingMarker.setRotation(NS.userHeading || 0);
    }
  }

  // ===== UI Controls =====
  document.addEventListener('DOMContentLoaded', () => {
    const gpsBtn = document.getElementById('gpsButton');
    if (gpsBtn && !gpsBtn.__llBound) {
      gpsBtn.__llBound = true;
      gpsBtn.addEventListener('click', () => {
        if (NS.gpsWatchId == null) startGPS();
        else stopGPS();
      });
    }
  });

function startGPS() {
  // Always show startup notification
  safeToaster('Activating GPS...', 2000);

  // 1. Check prerequisites
  if (!navigator.geolocation) {
    safeToaster('Geolocation not supported on this device', 5000);
    return;
  }
  if (!window.map) {
    safeToaster('Please wait - map is still loading', 5000);
    return;
  }

  // 2. Initialize UI elements
  ensureUserLocationLayers();
  ensureHeadingListener();

// show camera immediately on GPS start
document.getElementById('cameraButton')?.style && (document.getElementById('cameraButton').style.display = 'block');


  // 3. Clear previous instance if exists
  if (NS.gpsWatchId !== null) {
    navigator.geolocation.clearWatch(NS.gpsWatchId);
  }

  // 4. Start new GPS session
  NS.gpsWatchId = navigator.geolocation.watchPosition(
    (pos) => {
      const { latitude, longitude, accuracy, heading } = pos.coords;
      NS.lastUserLngLat = [longitude, latitude];

if (!NS._notifiedStart) { NS._notifiedStart = true; NS.emit('gps-start'); }

      // Use GPS heading if compass unavailable
      if (heading && !NS.userHeading) {
        NS.userHeading = smoothHeading(heading);
      }

      updateUserLocation(longitude, latitude, accuracy);

      // Initial zoom to user
      if (!NS.hasInitialFly) {
        NS.hasInitialFly = true;
        map.flyTo({
          center: [longitude, latitude],
          zoom: 17,
          speed: 1.2,
          curve: 1.5
        });
        safeToaster('GPS active - tracking your location', 3000);
      }
    },
    (err) => {
      let errorMsg = 'GPS error';
      switch(err.code) {
        case err.PERMISSION_DENIED:
          errorMsg = 'Please enable location permissions';
          break;
        case err.POSITION_UNAVAILABLE:
          errorMsg = 'Location signal lost';
          break;
        case err.TIMEOUT:
          errorMsg = 'GPS timeout - try moving outdoors';
          break;
      }
      stopGPS(errorMsg);
    },
    { 
      enableHighAccuracy: true,
      maximumAge: 2000,
      timeout: 10000 
    }
  );

  // Confirm activation
  NS.gpsWatchId !== null && safeToaster('GPS activated successfully', 2000);
}

function stopGPS(reason) {
  // 1. Stop GPS tracking
  if (NS.gpsWatchId) {
    navigator.geolocation.clearWatch(NS.gpsWatchId);
    NS.gpsWatchId = null;
  }

  // 2. Clear the dot/accuracy circle (if layers exist)
  if (map?.getSource('ll-user-location')) {
    map.getSource('ll-user-location').setData({ 
      type: 'FeatureCollection', 
      features: [] 
    });
  }

  // 3. Remove the heading arrow (if it exists)
  if (NS.headingMarker) {
    NS.headingMarker.remove();
    NS.headingMarker = null; // ‚Üê Critical! Prevents ghost markers
  }

// hide camera immediately on GPS stop
document.getElementById('cameraButton')?.style && (document.getElementById('cameraButton').style.display = 'none');


  // 4. Reset all tracking states
  NS.lastUserLngLat = null;
  NS.userHeading = null;
  NS.lastSmoothedHeading = null;

  safeToaster(reason || 'GPS stopped');

  NS._notifiedStart = false;
NS.emit('gps-stop');
}

})();
</script>



<script>
(() => {
  'use strict';

  const PS = (window.__LL_PINS__ = window.__LL_PINS__ || {});
  PS.markers = new Map();    // id -> { pin, marker }
  PS.addMode = false;
  PS._mapClickHandler = null;
  PS._isVisible = false; // start hidden

  const toast = (m, t=2500) => { try{ window.showToaster?.(m, t);}catch{} };
  const uid = () => (Date.now().toString(36) + Math.random().toString(36).slice(2));

  async function compressImageToJPEG(fileOrBlob, maxSize = 1000) {
    const dataURL = await new Promise((res) => {
      const fr = new FileReader();
      fr.onload = () => res(fr.result);
      fr.readAsDataURL(fileOrBlob);
    });
    const img = await new Promise((res) => {
      const i = new Image();
      i.onload = () => res(i);
      i.src = dataURL;
    });
    let { width, height } = img;
    if (width > height && width > maxSize) {
      height = Math.round(height * (maxSize / width));
      width = maxSize;
    } else if (height > width && height > maxSize) {
      width = Math.round(width * (maxSize / height));
      height = maxSize;
    }
    const canvas = document.createElement('canvas');
    canvas.width = width; canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, width, height);
    return await new Promise((res) => canvas.toBlob(b => res(b), 'image/jpeg', 0.85));
  }

  PS.addAddPinButton = function () {
    if (document.getElementById('addPinBtn')) return;
    const btn = document.createElement('button');
    btn.id = 'addPinBtn';
    btn.className = 'gps-button';
    btn.title = 'Add point';
    btn.style.bottom = '200px';
 
    btn.innerHTML = `
      <svg viewBox="0 0 24 24" width="24" height="24" stroke="#333" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <line x1="5" y1="12" x2="19" y2="12"></line>
      </svg>`;
    btn.addEventListener('click', () => PS.toggleAddMode());
    document.body.appendChild(btn);
  };

  PS.toggleAddMode = function () {
    if (!PS._isVisible) return;
    PS.addMode = !PS.addMode;
    const btn = document.getElementById('addPinBtn');
    if (!btn) return;
    btn.style.boxShadow = PS.addMode ? '0 0 0 3px rgba(255,132,0,.35)' : '';
    map.getCanvas().style.cursor = PS.addMode ? 'crosshair' : '';
    if (PS.addMode && !PS._mapClickHandler) {
      PS._mapClickHandler = (e) => {
        const t = e.originalEvent?.target;
        if (t && (t.closest('#lotModal') || t.closest('.mapboxgl-ctrl') || t.closest('button') || t.closest('a'))) return;
        PS.createPinAt(e.lngLat).finally(() => {
          PS.addMode = false;
          PS.toggleAddMode();
        });
      };
      map.on('click', PS._mapClickHandler);
      toast('Click the map to drop a pin');
    } else if (!PS.addMode && PS._mapClickHandler) {
      map.off('click', PS._mapClickHandler);
      PS._mapClickHandler = null;
    }
  };

  PS.createPinAt = async function (lngLat) {
    await window.supabaseReady;
    const { data, error } = await window.supabaseClient
      .from('pins').insert({ lng: lngLat.lng, lat: lngLat.lat }).select().single();
    if (error) { console.error(error); toast('Could not create pin'); return; }
    PS.addMarker(data);
    toast('Pin added');
  };

  PS.markerElement = function () {
    const el = document.createElement('div');
    el.style.width = '14px';
    el.style.height = '14px';
    el.style.borderRadius = '50%';
    el.style.background = '#ff8400';
    el.style.border = 'none';
    el.style.boxShadow = 'none';
    el.style.cursor = 'pointer';
    return el;
  };

  PS.addMarker = function (pin) {
    if (PS.markers.has(pin.id)) {
      PS.markers.get(pin.id).marker.setLngLat([pin.lng, pin.lat]);
      PS.markers.get(pin.id).pin = pin;
      return;
    }
    const el = PS.markerElement();
    const marker = new mapboxgl.Marker({ element: el, draggable: true })
      .setLngLat([pin.lng, pin.lat]);
    if (PS._isVisible && window.map) marker.addTo(map);
    marker.on('dragend', async () => {
      const ll = marker.getLngLat();
      const { error } = await window.supabaseClient
        .from('pins').update({ lng: ll.lng, lat: ll.lat }).eq('id', pin.id);
      if (error) toast('Failed to save position'); else toast('Position saved');
    });
    el.addEventListener('click', (ev) => { ev.stopPropagation(); PS.openPinPopup(pin, marker); });
    PS.markers.set(pin.id, { pin, marker });
  };

  PS._revealMarkers = function () {
    if (PS._isVisible) return;
    PS._isVisible = true;
    const btn = document.getElementById('addPinBtn');
    if (btn) {
      btn.style.display = 'flex';
      btn.style.opacity = '0';
      btn.style.transition = 'opacity 300ms ease';
      requestAnimationFrame(() => { btn.style.opacity = '1'; });
    }
    PS.markers.forEach(({ marker }) => {
      const el = marker.getElement();
      if (!el.parentNode) marker.addTo(map);
      el.style.display = 'block';
      el.style.opacity = '0';
      el.style.transition = 'opacity 300ms ease';
      requestAnimationFrame(() => { el.style.opacity = '1'; });
    });
  };

  PS.openPinPopup = async function (pin, marker) {
    await window.supabaseReady;
    const { data: photos } = await window.supabaseClient
      .from('pin_photos').select('id,url,created_at').eq('pin_id', pin.id).order('created_at', { ascending: true });
    const wrap = document.createElement('div');
    wrap.style.width = '260px';
    wrap.style.fontFamily = `'Barlow Condensed', Arial, sans-serif`;
    wrap.style.color = '#1A1A1A';
    const grid = (photos || []).map(p => `
      <div class="ps-thumb" data-url="${p.url}" style="width:76px;height:76px;background-image:url('${p.url}');background-size:cover;background-position:center;border-radius:6px;cursor:pointer;"></div>`).join('');
    wrap.innerHTML = `
      <div style="font-size:16px; color:#a17345; margin-bottom:6px;">
        <strong>Pin</strong> <span style="color:#8a8880; font-size:12px;">${pin.id.slice(0,6)}</span>
      </div>
      <div id="ps-grid-${pin.id}" style="display:grid; grid-template-columns:repeat(3,1fr); gap:6px; min-height:82px; margin-bottom:8px;">
        ${grid || '<div style="grid-column:1/-1; color:#8a8880">No photos yet.</div>'}
      </div>
      <label style="display:inline-block; background:#ff8400; color:#fff; padding:6px 10px; border-radius:4px; cursor:pointer;">
        Upload photo<input type="file" accept="image/*" capture="environment" style="display:none" id="ps-upload-${pin.id}">
      </label>`;
    const popup = new mapboxgl.Popup({ offset: 20, closeButton: true })
      .setDOMContent(wrap).setLngLat(marker.getLngLat()).addTo(map);
    wrap.querySelectorAll('.ps-thumb').forEach(div => {
      div.addEventListener('click', () => PS.showViewer(div.getAttribute('data-url')));
    });
    wrap.querySelector(`#ps-upload-${pin.id}`).addEventListener('change', async (e) => {
      if (!e.target.files || !e.target.files[0]) return;
      try {
        const blob = await compressImageToJPEG(e.target.files[0], 1200);
        const path = `${pin.id}/${Date.now()}.jpg`;
        const up = await window.supabaseClient.storage.from('pin-photos').upload(path, blob, { contentType: 'image/jpeg' });
        if (up.error) throw up.error;
        const pub = window.supabaseClient.storage.from('pin-photos').getPublicUrl(path);
        const url = pub?.data?.publicUrl;
        if (!url) throw new Error('No public URL');
        const { error: insErr } = await window.supabaseClient
          .from('pin_photos').insert({ pin_id: pin.id, url });
        if (insErr) throw insErr;
        const g = wrap.querySelector(`#ps-grid-${pin.id}`);
        g.querySelector('div[style*="No photos yet"]')?.remove();
        const thumb = document.createElement('div');
        thumb.className = 'ps-thumb';
        thumb.setAttribute('data-url', url);
        thumb.style.cssText = `width:76px;height:76px;background-image:url("${url}");background-size:cover;background-position:center;border-radius:6px;cursor:pointer;`;
        thumb.addEventListener('click', () => PS.showViewer(url));
        g.appendChild(thumb);
        toast('Photo uploaded');
      } catch (err) {
        toast('Upload failed');
      } finally { e.target.value = ''; }
    });
  };

  PS.ensureViewer = function () {
    if (document.getElementById('pinViewer')) return;
    document.body.insertAdjacentHTML('beforeend', `
      <div id="pinViewer" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.92);z-index:10000;">
        <img id="pinViewerImg" style="max-width:90%;max-height:90%;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);" />
        <button id="pinViewerClose" style="position:absolute;top:20px;right:20px;background:#f44336;color:#fff;border:none;border-radius:50%;width:40px;height:40px;font-size:20px;cursor:pointer;">√ó</button>
      </div>`);
    document.getElementById('pinViewerClose').addEventListener('click', () => {
      document.getElementById('pinViewer').style.display = 'none';
    });
  };
  PS.showViewer = function (url) {
    PS.ensureViewer();
    document.getElementById('pinViewerImg').src = url;
    document.getElementById('pinViewer').style.display = 'block';
  };

  PS.loadPins = async function () {
    await window.supabaseReady;
    const { data, error } = await window.supabaseClient
      .from('pins').select('id,lng,lat').order('created_at', { ascending: true });
    if (error) return;
    (data || []).forEach(p => PS.addMarker(p));
  };

  PS.subscribe = function () {
    window.supabaseClient
      .channel('pins-rt')
      .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'pins' }, (payload) => PS.addMarker(payload.new))
      .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'pins' }, (payload) => {
        const rec = PS.markers.get(payload.new.id);
        if (rec) rec.marker.setLngLat([payload.new.lng, payload.new.lat]);
      })
      .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'pins' }, (payload) => {
        const rec = PS.markers.get(payload.old.id);
        if (rec) { rec.marker.remove(); PS.markers.delete(payload.old.id); }
      })
      .subscribe();
  };

  const boot = async () => {
    await window.supabaseReady;
    if (!window.map) {
      const i = setInterval(() => {
        if (window.map) { clearInterval(i); PS.addAddPinButton(); PS.loadPins(); PS.subscribe(); }
      }, 200);
    } else {
      PS.addAddPinButton();
      PS.loadPins();
      PS.subscribe();
    }

  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot);
  } else {
    boot();
  }
})();
</script>

  



</body>
</html>
