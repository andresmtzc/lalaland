<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lalaland</title>
<link href="https://fonts.googleapis.com/css2?family=Barlow+Condensed:wght@400;600;700" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tmcw/togeojson@4.5.0/dist/togeojson.umd.js"></script>
<link rel="stylesheet" href="styles.css">

  <script>
    // Font loading handler (runs before DOMContentLoaded)
    document.fonts.ready.then(() => {
      document.body.classList.add('fonts-loaded');
    }).catch(() => {
      document.body.classList.add('fonts-loaded'); // Fallback if fonts fail
    });
  </script>


</head>
 
<body>









<div id="map"></div>


 
<div id="toaster" class="hidden">Loaded most recent aerial image (March 2025)</div>
<a href="https://wa.me/5218185261819"
   target="_blank"
   id="ctaToaster"
   class="hidden"
   data-utm-source="website"
   data-utm-medium="toaster"
   data-utm-campaign="lead_generation">
  ¬øTienes dudas? ¬°Chatea con nosotros por WhatsApp!
</a>

<div class="logo-wrapper">
   <a href="#" onclick="event.preventDefault(); window.location.reload(true);" title="Reload Site">
  <img src="https://lalaland.mx/lalaland.svg" alt="Logo"></a>
</div>

<!-- Modal Panel -->
<div id="lotModal">
  <div class="modal-header">
    <div class="header-control" id="backButton">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
        <path d="M10 4 L6 8 L10 12" fill="none"/>
      </svg>
    </div>

<!-- Unit controls (left) -->
<div class="unit-controls" id="unitControls">
  <button class="unit-btn" data-mode="num" title="Lote #">#</button>
 <!-- <button class="unit-btn" data-mode="area" title="m¬≤">m<sup>2</sup></button> -->
  <button class="unit-btn" data-mode="price" title="Precio">$</button>
</div>



    <div class="header-title">
      <span id="headerFracc">SANTTE</span><span class="header-lot-number" id="headerLotNumber"></span>
    </div>

<!-- AUTH controls -->
<div class="auth-controls" id="authControls">
  <button id="modal-login-btn" class="header-control auth-btn" title="Login">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="#888" aria-hidden="true">
      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V9h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
    </svg>
  </button>
  <button id="modal-logout-btn" class="header-control auth-btn" title="Logout">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="#888" aria-hidden="true">
      <path d="M17 7l-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z"/>
    </svg>
  </button>
</div>

<!-- üü¢ CLASSIC SHARE BUTTON ICON -->
<div class="header-control share-button" id="shareButton" title="Share this lot">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <circle cx="4" cy="8" r="1.5" fill="none" stroke="#ff8400" stroke-width="1.2"/>
    <circle cx="12" cy="4" r="1.5" fill="none" stroke="#ff8400" stroke-width="1.2"/>
    <circle cx="12" cy="12" r="1.5" fill="none" stroke="#ff8400" stroke-width="1.2"/>
    <path d="M5.5 9 L10.5 5 M5.5 7 L10.5 11" 
          fill="none" stroke="#ff8400" stroke-width="1.2" stroke-linecap="round"/>
  </svg>
</div>

    <div class="header-control close-x" onclick="closeModal()">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
        <path d="M4 4 L12 12 M12 4 L4 12" fill="none"/>
      </svg>
    </div>
<div class="header-control plus-button" onclick="handlePlusButton()">
<svg viewBox="0 0 16 16">
  <!-- Plus sign (centered) -->
  <path class="plus-icon" d="M8 3 L8 13 M3 8 L13 8" 
        fill="none" stroke="#888" stroke-width="1.5" stroke-linecap="round" />
  
  <!-- Minus sign (centered) -->
  <path class="minus-icon" d="M3 8 L13 8" 
        fill="none" stroke="#888" stroke-width="1.5" stroke-linecap="round" 
        style="display: none;"/>
</svg>
</div>



  </div>
  <div class="modal-divider"></div>
  <div class="modal-content-wrapper">
    <div class="loading-spinner" id="loadingSpinner"></div>

<div class="lot-details" id="lotDetails"></div>

<!-- Calendly must be a sibling, not inside lotDetails -->
<div id="calendlyEmbed" class="calendly-embed-container" style="display:none;">

  <iframe id="calendly-iframe" 
          src="about:blank"
          frameborder="0"
          style="width:100%;height:100%;"></iframe>
</div>

<!-- üü¢ ADD 360 VIEWER HERE (right after calendly) -->
    <div id="viewer-container" class="viewer-mode" style="display: none;">
      <canvas id="canvas"></canvas>
      
      <div class="viewer-controls">
        <button id="prevImageBtnTop">‚Üê Prev</button>
        <span id="viewer-info">No images loaded</span>
        <button id="nextImageBtnTop">Next ‚Üí</button>
      </div>

      <div class="image-controls">
        <div class="navigation-ring">
          <button class="nav-button ring-button" id="nextImageBtn">‚ñ≥</button>
          <button class="nav-button ring-button" id="prevImageBtn">‚ñΩ</button>
          <button class="nav-button ring-button" id="branchImageBtn">‚ñ∑</button> 
        </div>
        <div id="branch-buttons" style="margin-top:8px; display:flex; gap:6px; pointer-events:auto;"></div>
      </div>

      <div class="time" id="time">-/-</div>

      <div class="loading" id="viewer-loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading 360¬∞ image...</div>
      </div>
    </div>
    <!-- üü¢ END 360 VIEWER -->

<div class="modal-info" id="modalInfo"></div>
    <div class="custom-scrollbar" id="customScrollbar">
      <div class="custom-scrollthumb" id="customScrollthumb"></div>
    </div>
  </div>
  <div class="bottom-plus-button" onclick="handlePlusButton()">
  <svg viewBox="0 0 16 16" class="wiggle-arrow">
    <path d="M4 6 L8 10 L12 6" 
          fill="none" stroke="#fff" stroke-width="1.5" stroke-linecap="round" />
  </svg>
  </div>
</div>

<!-- AUTH MODAL -->
<div id="auth-modal">
  <div class="auth-box">
    <h2>Iniciar sesi√≥n</h2>

    <div id="auth-step-email">
      <label for="auth-email">Correo electr√≥nico</label>
      <input type="email" id="auth-email" placeholder="tu@correo.com">
      <button class="primary" id="request-otp">Enviar c√≥digo</button>
      <button class="secondary" id="auth-cancel">Cancelar</button>
    </div>

    <div id="auth-step-otp" style="display:none;">
      <label for="auth-otp">C√≥digo enviado a <span id="otp-email-display"></span></label>
      <input type="text" id="auth-otp" maxlength="6" placeholder="123456">
      <button class="primary" id="verify-otp">Verificar</button>
      <button class="secondary" id="auth-cancel">Cancelar</button>
    </div>
  </div>
</div>




<!-- Whatsapp button 
<a href="https://wa.me/5218185261819" target="_blank" class="whatsapp-button"
   data-utm-source="website"
   data-utm-medium="button"
   data-utm-campaign="lead_generation">
  <img src="https://lalaland.mx/whatrans.png" alt="WhatsApp" />
</a> -->

<!-- Lalaland Info Button -->
<button class="lalaland-button" id="lalalandInfoBtn">
<svg width="36" height="36" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
  <path style="fill:none;stroke:#fff;stroke-width:1.3;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-dasharray:none;stroke-opacity:1" 
        d="M20.749.039a2.235 2.235 0 0 0-1.084 2.06v.01a1.87 1.87 0 0 0-1.155 2.5l-.016.023a1.501 1.501 0 0 0-.775 1.95 1.492 1.492 0 0 0 2.168.674l5.576-3.218-.001-.003c.813-.486 1.14-1.5.763-2.37A1.878 1.878 0 0 0 23.76.71l-.007.004a2.21 2.21 0 0 0-2.033-.988 2.253 2.253 0 0 0-.97.313z" 
        transform="rotate(30 8.172 -24.122) scale(2) translate(-7, -.7)"/>
</svg>
</button>


<!-- Search Button Container -->
<div class="search-button-container">
  <button id="communitySearchBtn" class="map-reset-button" title="Search Communities">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" stroke="#333">
      <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" stroke-width="2" stroke-linecap="round" fill="none"/>
    </svg>
  </button>
  
<div id="communityCircleMenu" class="community-circle-menu"></div>

 
 <!-- Drive button -->
<button id="driveBtn" class="gps-button" title="Drive" style="bottom: 200px;">
<svg viewBox="1.2 4 21.6 16" width="24" height="24" aria-hidden="true" style="color:#333">
  <path fill="currentColor" d="M18.92 6.01C18.72 5.42 18.16 5 17.5 5h-11c-.66 0-1.21.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 16c-.83 0-1.5-.67-1.5-1.5S5.67 13 6.5 13s1.5.67 1.5 1.5S7.33 16 6.5 16zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 11l1.5-4.5h11L19 11H5z"/>
</svg>
</button> 

  <!-- GPS button -->
<button id="gpsButton" class="gps-button" title="Enable GPS">
 <svg viewBox="0 0 24 24" width="24" height="24" stroke="#333" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="9" />
    <line x1="12" y1="2" x2="12" y2="5" />
    <line x1="12" y1="19" x2="12" y2="22" />
    <line x1="2" y1="12" x2="5" y2="12" />
    <line x1="19" y1="12" x2="22" y2="12" />
    <circle cx="12" cy="12" r="4.5" fill="#333" stroke="none" />
  </svg>
</button> 

<!-- info button 
<button id="infoBtn" class="map-info-button" title="View Info">
  <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
 
    <circle cx="12" cy="12" r="9" stroke-width="2"></circle>


    <line x1="12" y1="7"  x2="12" y2="7"  stroke-width="3" stroke="#333" fill="none"></line> 
    <line x1="12" y1="12" x2="12" y2="17" stroke-width="3" stroke="#333" fill="none"></line> 
  </svg>
</button> -->

<!-- AVAILABILITY BUTTON -->
<button id="cycleAvailabilityBtn" class="gps-button" title="Cycle Availability" style="bottom: 320px;">
  <svg viewBox="0 0 24 24" width="24" height="24" stroke="#333" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M23 4L23 10 17 10"></path>
    <path d="M1 20L1 14 7 14"></path>
    <path d="M3.51 9a9 9 0 0114.85-3.36L23 10"></path>
    <path d="M20.49 15a9 9 0 01-14.85 3.36L1 14"></path>
  </svg>
</button>

<!-- Edit BUTTON -->
<button id="editBtn" class="gps-button" title="Edit Button" style="bottom: 380px;">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M3 17.25V21H6.75L17.81 9.94L14.06 6.19L3 17.25ZM20.71 7.04C21.1 6.65 21.1 6.02 20.71 5.63L18.37 3.29C17.98 2.9 17.35 2.9 16.96 3.29L15.13 5.12L18.88 8.87L20.71 7.04Z" fill="currentColor"/>
</svg>
</button>

<script>

// ===== 360 VIEWER GLOBALS =====
let allTracks = new Map();
let currentTrackId = null;
let scene, camera, renderer, sphere, panoGroup;
let currentYaw = 0, currentPitch = 0, currentFov = 75;
let viewerInitialized = false;
let selectedMarbleId = null;
const navGraph = new Map();
let lastHopBearingDeg = null;
let currentImages = [];
let currentImageIndex = -1;
let preloadedImages = {};
let viewConeMarker = null;
let isSwitchingTrack = false;

// Constants
const FRAMES_BASE = 'https://lalaland.mx/frames/';
// ===== REST OF YOUR EXISTING CODE STARTS HERE =====
//button tracking here
</script>

<script>
  const btn = document.querySelector('.lalaland-button');

  function bounceButton() {
    if (!btn) return;
    btn.style.animation = 'bounce 1s';
    btn.addEventListener('animationend', () => {
      btn.style.animation = '';
    }, { once: true });
  }

  // Initial bounce after 10 seconds
  setTimeout(bounceButton, 10000);

  // Subsequent bounces every 3 minutes
  setInterval(bounceButton, 3 * 60 * 1000);

const ctaToaster = document.getElementById('ctaToaster');
const whatsappBtn = document.querySelector('.lalaland-button');

const ctaobserver = new MutationObserver(() => {
  if (ctaToaster.classList.contains('show')) {
    setTimeout(() => {
      whatsappBtn.classList.add('bounce');

      // Remove after animation so it can be triggered again later
      setTimeout(() => {
        whatsappBtn.classList.remove('bounce');
      }, 600); // duration of bounce animation
    }, 4000); // ‚è≥ 2s delay before bounce
  }
});

ctaobserver.observe(ctaToaster, {
  attributes: true,
  attributeFilter: ['class']
});

</script>

<script>
  //HASH FOR URL
  function openInitialLotModal() {
    const hash = window.location.hash;
    if (hash.startsWith('#lot=')) {
      const lotName = decodeURIComponent(hash.slice(5));
      const lot = lotData.find(l => l.name === lotName);
      if (lot) openModal(lot);
    }
  }
</script>
   
<script>
  // LOAD SUPABASE
  window.supabaseReady = new Promise((resolve, reject) => {
    const supabaseScript = document.createElement('script');
    supabaseScript.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';
    
    supabaseScript.onload = () => {
      fetch('https://lalaland.mx/sb_config.json')
        .then(r => r.json())
        .then(cfg => {
          window.supabaseClient = supabase.createClient(cfg.url, cfg.key);
          console.log('‚úÖ Supabase client initialized with config.json');
          resolve();

          // ‚úÖ ‚úÖ ‚úÖ ADD REALTIME SUBSCRIPTION HERE
         const channel = window.supabaseClient
  .channel('lots-realtime')
  .on(
    'postgres_changes',
    {
      event: '*',
      schema: 'public',
      table: 'lots',
    },
    (payload) => {
      console.log('üì° Change detected:', payload);

      const updatedLotName = payload.new?.lot_name || payload.old?.lot_name;
      const lotNumber = extractLotNumber(updatedLotName);

      // üü¢ UPDATE ALL DATA SOURCES, not just lotData
      
      // 1. Update lotData (map data)
      const updatedIndex = lotData.findIndex(l => l.name === updatedLotName);
      if (updatedIndex !== -1) {
        const lot = lotData[updatedIndex];
        const raw = payload.new?.availability ?? lot.availability ?? 'Available';
        lot.availability = raw;
        lot.featured = raw.toLowerCase() === 'featured';
        lot.rSize = payload.new?.rSize ?? lot.rSize;
        lot.millones = payload.new?.millones ?? lot.millones;

        // Refresh visual on map
        refreshLotVisuals(map, lot);
      }

      // üü¢ NEW: Update baseLotsAll (modal data source)
      if (window.baseLotsAll) {
        const baseLotAll = window.baseLotsAll.find(bl => bl.number === lotNumber);
        if (baseLotAll) {
          baseLotAll.availability = payload.new?.availability ?? baseLotAll.availability;
          baseLotAll.rSize = payload.new?.rSize ?? baseLotAll.rSize;
          baseLotAll.price = payload.new?.millones ?? baseLotAll.price;
        }
      }

      // üü¢ NEW: Update baseLots (current filtered list)
      if (baseLots) {
        const baseLot = baseLots.find(bl => bl.number === lotNumber);
        if (baseLot) {
          baseLot.availability = payload.new?.availability ?? baseLot.availability;
          baseLot.rSize = payload.new?.rSize ?? baseLot.rSize;
          baseLot.price = payload.new?.millones ?? baseLot.price;
        }
      }

      // üü¢ NEW: Re-render modal if it's open
      if (document.getElementById('lotModal').classList.contains('show')) {
        render();
      }
    }
  )
  .subscribe()
  .catch(error => console.error('‚ùå Realtime subscription failed:', error));
        })
        .catch(e => {
          console.error('Failed to load Supabase config:', e);
          reject(new Error("‚ùå Failed to load Supabase config"));
        });
    };
    
    supabaseScript.onerror = () => {
      console.error("‚ùå Failed to load Supabase script");
      reject(new Error("‚ùå Failed to load Supabase script"));
    };
    
    document.head.appendChild(supabaseScript);
  });
</script>




<script>
// ===== AUTH (Supabase OTP) =====
(() => {
  const $  = (s) => document.querySelector(s);
  const $$ = (s) => Array.from(document.querySelectorAll(s));

  // ‚¨áÔ∏è Keep toaster behavior exactly as before (one-arg showToaster)
  const toast = (m) => {
    try { window.showToaster?.(m); } catch { /* no-op to match previous behavior */ }
  };

  // Header controls (only where that header includes .auth-controls)
  const btnLogin  = $('#modal-login-btn');
  const btnLogout = $('#modal-logout-btn');

  // Modal + steps
  const modal     = $('#auth-modal');
  const stepEmail = $('#auth-step-email');
  const stepOtp   = $('#auth-step-otp');
  const emailInp  = $('#auth-email');
  const otpInp    = $('#auth-otp');
  const otpEmail  = $('#otp-email-display');

  const reqBtn     = $('#request-otp');
  const verifyBtn  = $('#verify-otp');
  const cancelBtns = $$('#auth-cancel'); // support cancel buttons in both steps

  let pendingEmail = '';

  function showAuthModal() {
    if (!modal) return;
    // reset to email step
    if (stepEmail) stepEmail.style.display = 'block';
    if (stepOtp)   stepOtp.style.display   = 'none';
    if (emailInp)  emailInp.value = '';
    if (otpInp)    otpInp.value   = '';
    modal.style.display = 'block';
    setTimeout(() => emailInp?.focus(), 0);
  }

  function hideAuthModal() {
    if (!modal) return;
    modal.style.display = 'none';
  }

  function resetModalState() {
    pendingEmail = '';
    if (emailInp) emailInp.value = '';
    if (otpInp)   otpInp.value   = '';
    if (stepEmail) stepEmail.style.display = 'block';
    if (stepOtp)   stepOtp.style.display   = 'none';
  }

  function updateButtons(loggedIn) {
    if (btnLogin)  btnLogin.style.display  = loggedIn ? 'none' : 'flex';
    if (btnLogout) btnLogout.style.display = loggedIn ? 'flex' : 'none';
  }

  // --- UI bindings ---
  btnLogin && btnLogin.addEventListener('click', showAuthModal);

  btnLogout && btnLogout.addEventListener('click', async () => {
    try {
      await window.supabaseClient?.auth.signOut();
      updateButtons(false);
      toast('Sesi√≥n cerrada.');
    } catch (e) {
      console.error(e);
      toast('Error al cerrar sesi√≥n.');
    }
  });

  // Cancel buttons (both steps)
  cancelBtns.forEach(btn => {
    btn.type = 'button';
    btn.addEventListener('click', () => {
      resetModalState();
      hideAuthModal();
    });
  });

  // Close on ESC
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modal?.style.display === 'block') {
      resetModalState();
      hideAuthModal();
    }
  });

  // Click backdrop to close (only if clicking outside the inner box)
  modal && modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      resetModalState();
      hideAuthModal();
    }
  });

  // ======================
  // ALLOWLIST CHECK (editors.email)
  // ======================
  async function isEmailAllowed(email) {
    const { data, error } = await window.supabaseClient
      .from('editors')
      .select('id') // minimal; don't expose lot_table
      .eq('email', email.trim().toLowerCase())
      .maybeSingle();

    if (error) {
      console.error('Allowlist check failed:', error);
      return false; // fail closed
    }
    return !!data; // true if found
  }

  // --- Send OTP (guarded by allowlist) ---
  reqBtn && reqBtn.addEventListener('click', async () => {
    const email = (emailInp?.value || '').trim().toLowerCase();
    if (!email) { toast('Escribe tu email.'); return; }

    // Basic email format guard
    const looksLikeEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    if (!looksLikeEmail) { toast('Ingresa un correo v√°lido.'); return; }

    // Allowlist guard against public.editors(email)
    const allowed = await isEmailAllowed(email);
    if (!allowed) {
      toast('Este correo no est√° autorizado.');
      return;
    }

    try {
      const { error } = await window.supabaseClient.auth.signInWithOtp({
        email,
        options: { emailRedirectTo: window.location.origin }
      });
      if (error) throw error;

      pendingEmail = email;
      if (otpEmail) otpEmail.textContent = email; // ‚ÄúC√≥digo enviado a ‚Ä¶‚Äù
      if (stepEmail) stepEmail.style.display = 'none';
      if (stepOtp)   stepOtp.style.display   = 'block';
      setTimeout(() => otpInp?.focus(), 0);
      toast('C√≥digo enviado. Revisa tu correo.');
    } catch (e) {
      console.error(e);
      toast('No pudimos enviar el c√≥digo.');
    }
  });

  // --- Verify OTP ---
  verifyBtn && verifyBtn.addEventListener('click', async () => {
    const token = (otpInp?.value || '').trim();
    if (token.length !== 6) { toast('El c√≥digo debe tener 6 d√≠gitos.'); return; }

    try {
      const { error } = await window.supabaseClient.auth.verifyOtp({
        email: pendingEmail,
        token,
        type: 'email'
      });
      if (error) throw error;

      resetModalState();
      hideAuthModal();
      toast('Has iniciado sesi√≥n.');
      // UI will also update via auth state listener below
    } catch (e) {
      console.error(e);
      toast('C√≥digo inv√°lido o vencido.');
    }
  });

  // --- Initialize auth state (no toast on page refresh) ---
  const initAuth = async () => {
    try {
      const { data: { session } = { session: null } } =
        await window.supabaseClient.auth.getSession();
      updateButtons(!!(session && session.user));
    } catch (e) {
      console.warn('getSession failed:', e);
    }

    window.supabaseClient.auth.onAuthStateChange((_event, session) => {
      updateButtons(!!(session && session.user));
      // No toast here‚Äîonly in explicit login/logout actions above
    });
  };

  if (window.supabaseReady && typeof window.supabaseReady.then === 'function') {
    window.supabaseReady.then(initAuth);
  } else {
    const iv = setInterval(() => {
      if (window.supabaseClient) {
        clearInterval(iv);
        initAuth();
      }
    }, 200);
  }
})();
</script>


 

<script> 
// MAP INITIALIZE
let lotData = [];
let map;  // global map variable
let hoveredId = null;
let currentLotIndex = -1;
let sideLengthLabels = []; // Array to store side length label elements
let currentLabeledLot = null; // Track which lot has labels
let isDetailOpen = false;
let lastOpenedBaseIndex = null;

// Initialize map
fetch('https://lalaland.mx/mapbox.txt')
  .then(r => r.text())
  .then(token => {
    mapboxgl.accessToken = token.trim();
    
    // Calculate bounds that contain BOTH satellite image areas
    const communityBounds = new mapboxgl.LngLatBounds();
    
    // First community bounds (drone image - santte2.jpg)
    communityBounds.extend([-100.16483, 25.457155]);   // Bottom-left
    communityBounds.extend([-100.154874, 25.467111]);  // Top-right
    
    // Second community bounds (agora image - agora.jpg)
    communityBounds.extend([-100.183685, 25.433407]);  // Bottom-left  
    communityBounds.extend([-100.173731, 25.443361]);  // Top-right
    
    const m = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/satellite-streets-v12',
      bounds: communityBounds,
      fitBoundsOptions: {
        padding: 50,
        maxZoom: 16
      }
    });
   
    window.map = m;
    map = m;

    map.doubleClickZoom.disable();

    map.on('load', async () => {
      await loadRoad(map, async () => {
        await loadLotsAsync(map);
        await window.supabaseReady;
        await enrichLotsWithAvailability();

        animateLots(map, () => {
['drone', 'agora'].forEach(type => addCustomImage(map, type));
  addFeaturedLotsLayer(map, () => {
    // This callback runs AFTER featured lots have completed initial pulse
    
    // ===== MOVE ALL MAP INTERACTIONS HERE =====

        // ===== COMMUNITY SEARCH CIRCULAR MENU =====
// ===== COMMUNITY SEARCH CIRCULAR MENU =====
function setupCommunitySearchMenu() {
  const searchBtn = document.getElementById('communitySearchBtn');
  const circleMenu = document.getElementById('communityCircleMenu');
  
  const communities = {
    'santte1': {
      center: [-100.157213, 25.462513], 
      zoom: 16.7,
      fracc: 'santte1',
      name: 'Santte 1'
    },
    'santte2': {
      center: [-100.15994, 25.461823],
      zoom: 16.5,
      fracc: 'santte2',
      name: 'Santte 2'
    },
    'amani-aqua': {
      center: [-100.179408, 25.437384], // Center of drone image bounds
      zoom: 15.65,
      fracc: 'amani-aqua',
      name: 'Amani Aqua'
    },
    'ca√±adas-vergel': {
      center: [-100.178308, 25.441684], // Center of agora image bounds
      zoom: 16.6,
      fracc: 'ca√±adas-vergel', 
      name: 'Ca√±adas Vergel'
    }
  };

  let menuActive = false;

  // Toggle menu on search button click
  searchBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    menuActive = !menuActive;
    circleMenu.classList.toggle('active', menuActive);
  });

  // Handle community selection
  document.querySelectorAll('.community-option').forEach(option => {
    option.addEventListener('click', function(e) {
      e.stopPropagation();
      const communityId = this.dataset.community;
      
      if (communities[communityId]) {
        const community = communities[communityId];
        
        // Fly to the community
        map.flyTo({
          center: community.center,
          zoom: community.zoom,
          speed: 1.2,
          curve: 1.5
        });
        
        // Filter the modal list if open
        const modal = document.getElementById('lotModal');
        if (modal && modal.classList.contains('show')) {
          modal.dataset.fracc = community.fracc;
          if (typeof window.resetUnitButtons === 'function') {
            window.resetUnitButtons();
          }
        }
        
        // Show toast with community name
        showToaster(`Navegando a ${community.name}`);
      }
      
      // Close menu after selection
      menuActive = false;
      circleMenu.classList.remove('active');
    });
  });

  // Close menu when clicking elsewhere
  document.addEventListener('click', function() {
    menuActive = false;
    circleMenu.classList.remove('active');
  });

  // Prevent menu close when clicking inside menu
  circleMenu.addEventListener('click', function(e) {
    e.stopPropagation();
  });
}

        // Initialize the community search menu
        setupCommunitySearchMenu();
        // ===== END COMMUNITY SEARCH =====

// ===== üü¢ ADD MARBLE LAYERS HERE =====
        // üü¢ MARBLES SOURCE
        map.addSource('marbles', { 
          type: 'geojson', 
          data: { type:'FeatureCollection', features: [] } 
        });

        // VISIBLE marbles layer
        map.addLayer({
          id: 'marbles-layer',
          type: 'circle',
          source: 'marbles',
          paint: {
            'circle-radius': ['case',
              ['==', ['get', 'isSelected'], true], 6,
              ['==', ['get', 'hasImage'], true], 2, // Larger for marbles with images
              3 // Smaller for marbles without images
            ],
            'circle-color': ['case',
              ['==', ['get', 'isSelected'], true], '#ff8400',
              ['==', ['get', 'hasImage'], true], 'rgba(52, 168, 83, 0)', // GREEN for marbles with images
              '#8B4513' // Brown for marbles without images
            ],
            'circle-stroke-width': ['case',
              ['==', ['get', 'isSelected'], true], 0,
              ['==', ['get', 'hasImage'], true], 1, // Thin stroke for marbles with images
              0
            ],
            'circle-stroke-color': '#FFFFFF'
          }
        });

        // INVISIBLE, larger hit area for clicks
        map.addLayer({
          id: 'marbles-click-layer',
          type: 'circle',
          source: 'marbles',
          paint: { 
            'circle-radius': 8, 
            'circle-opacity': 0, 
            'circle-stroke-width': 0 
          }
        });

        // VIEW CONE source + layers
        initConeSystem();
        // ===== üü¢ END MARBLE LAYERS =====

        // ===== üü¢ INITIALIZE 360 VIEWER SYSTEM =====
        console.log('Initializing 360 viewer system...');
        initializeViewer();
        setupMapInteractions();
        // ===== üü¢ END 360 VIEWER INIT =====

// Replace your map.on('moveend') event handler with this:
let isUserDragging = false;

map.on('dragstart', () => {
  isUserDragging = true;
});

map.on('dragend', () => {
  isUserDragging = false;
  // Only remove labels if zoom drops below threshold after user dragging
  const currentZoom = map.getZoom();
  if (currentZoom < 18.8 && currentLabeledLot) {
    removeSideLengthLabels();
  }
});

map.on('moveend', () => {
  // Only handle non-drag movements (like zoom changes)
  if (!isUserDragging) {
    const currentZoom = map.getZoom();
    if (currentZoom < 18.8 && currentLabeledLot) {
      removeSideLengthLabels();
    }
  }
});

    // Clear labels when clicking a different lot
map.on('click', 'lots-final-click', (e) => {
  if (e.features.length > 0) {
    const newLot = lotData.find(l => l.name === e.features[0].properties.name);
    
    // Always remove existing labels first
    if (currentLabeledLot) {
      removeSideLengthLabels();
    }
    
    // Add labels for the new lot if zoom is high enough
    const currentZoom = map.getZoom();
    if (currentZoom >= 18.8 && newLot) {
      addSideLengthLabels(newLot);
    }
  }
});

    // Main map click handler
    map.on('click', (e) => {
      // Don't close if clicking inside modal
      if (e.originalEvent?.target.closest('#lotModal')) return;
  
   // Check if clicking on lots OR cones OR marbles
      const lotFeatures = map.queryRenderedFeatures(e.point, { 
        layers: ['lots-final-click'] 
      });
      
      const coneFeatures = map.queryRenderedFeatures(e.point, { 
        layers: ['ps-cones-fill'] 
      });

        const marbleFeatures = map.queryRenderedFeatures(e.point, { 
    layers: ['marbles-click-layer'] 
  });
      
      // If clicking on a lot while pin modal is open
      if (lotFeatures.length > 0 && document.getElementById('lotModal').classList.contains('pin-mode')) {
        const feature = lotFeatures[0];
        const lotName = feature.properties.name;
        const lot = lotData.find(l => l.name === lotName);
        if (lot) {
          // Switch from pin modal to lot modal without closing
          document.getElementById('lotModal').classList.remove('pin-mode');
          openModal(lot); // This will handle the transition to lot view
          return; // Exit early
        }
      }
      
  // Only close if clicking outside lots, cones, AND marbles
  if (lotFeatures.length === 0 && coneFeatures.length === 0 && marbleFeatures.length === 0) {
    closeModal();
      }
    });

    // Add hover outline layer after lots-final source is ready
    map.addLayer({
      id: 'lots-hover-outline',
      type: 'line',
      source: 'lots-final',
      paint: {
        'line-color': '#fff',
        'line-width': 3,
        'line-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0]
      }
    });

    console.log('Ready to open initial modal, lotData:', lotData);
    openInitialLotModal();

    map.on('mousemove', 'lots-final-click', (e) => {
      // Don't override modal highlight
      if (document.getElementById('lotModal').classList.contains('show')) return;
      if (hoveredId !== null) {
        map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
      }
      if (e.features.length > 0) {
        hoveredId = e.features[0].id;
        map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: true });
      }
    });

    map.on('mouseleave', 'lots-final-click', () => {
      if (document.getElementById('lotModal').classList.contains('show')) return;
      if (hoveredId !== null) {
        map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
      }
      hoveredId = null;
    });

    // SINGLE CLICK HANDLER - REMOVED THE DUPLICATE
map.on('click', 'lots-final-click', (e) => {
  if (e.features.length === 0) return;

  // üü¢ FIX: Check if we're in 360 viewer mode and exit to list mode
  const modal = document.getElementById('lotModal');
  if (modal.classList.contains('viewer-mode')) {
    // Get the clicked lot info before closing viewer
    const feature = e.features[0];
    const lotName = feature.properties.name;
    const lot = lotData.find(l => l.name === lotName);
    
    // Close the viewer
    close360ViewerInModal();
    
    // Scroll list to the clicked lot
    if (lot) {
      const baseIndex = baseLots.findIndex(l => l.number === extractLotNumber(lot.name));
      if (baseIndex !== -1) {
        requestAnimationFrame(() => {
          scrollToBaseIndex(baseIndex, true);
        });
      }
    }
    
    e.preventDefault();
    e.originalEvent.stopPropagation();
    return; // Exit here - just close viewer and scroll to lot
  }

  // üü¢ UPDATED: Check edit mode first (now includes marble check)
  if (handleEditClick(e)) return;

  const feature = e.features[0];
  const lotName = feature.properties.name;
  const lot = lotData.find(l => l.name === lotName);
  if (!lot) return;

  // Remove previous hover
  if (hoveredId !== null) {
    map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
    hoveredId = null;
  }

  // Find index
  const idx = lotData.findIndex(l => l.name === lot.name);
  if (idx !== -1) {
    map.setFeatureState({ source: 'lots-final', id: idx }, { hover: true });
    hoveredId = idx;
    currentLotIndex = idx;
  }

  // Remove any existing labels
  removeSideLengthLabels();
  
  // üü¢ FIX: Check if we're already in detail view
  const isInDetailView = modal.classList.contains('info-mode') && isDetailOpen;
  
  if (isInDetailView) {
    // We're in detail view - update the current detail view with new lot
    const baseIndex = baseLots.findIndex(l => l.number === extractLotNumber(lot.name));
    if (baseIndex !== -1) {
      // Update the detail view with the new lot
      showDetailViewForLot(baseIndex + cloneCount, true); // true = isSwitchingLots
    }
  } else {
    // Normal case - open modal
    openModal(lot);
  }

  // Add side length labels if zoom is high enough
  const currentZoom = map.getZoom();
  if (currentZoom >= 18.8) {
    addSideLengthLabels(lot);
  }

  // Prevent the event from bubbling to avoid duplicate handling
  e.preventDefault();
  e.originalEvent.stopPropagation();
});


    // ===== END MAP INTERACTIONS =====

    // ===== REVEAL PINS VERY LAST =====
    if (window.__LL_PINS__?._revealMarkers) {
      console.log('Revealing photo pins LAST after everything else');
       
      window.__LL_PINS__._revealMarkers();
    }
  });
});
 
        // Add hover outline layer after lots-final source is ready
        map.addLayer({
          id: 'lots-hover-outline',
          type: 'line',
          source: 'lots-final',
          paint: {
            'line-color': '#ff8400',
            'line-width': 3,
            'line-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0]
          }
        });

        console.log('Ready to open initial modal, lotData:', lotData);
        openInitialLotModal();

        map.on('mousemove', 'lots-final-click', (e) => {
          // Don't override modal highlight
          if (document.getElementById('lotModal').classList.contains('show')) return;
          if (hoveredId !== null) {
            map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
          }
          if (e.features.length > 0) {
            hoveredId = e.features[0].id;
            map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: true });
          }
        });

        map.on('mouseleave', 'lots-final-click', () => {
          if (document.getElementById('lotModal').classList.contains('show')) return;
          if (hoveredId !== null) {
            map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
          }
          hoveredId = null;
        });
      }); // loadRoad callback ends
    }); // map load ends
  }); // fetch token ends

// === SIDE LENGTH LABELS ===
function addSideLengthLabels(lot) {
  // Always remove any existing labels first
  removeSideLengthLabels();
  currentLabeledLot = lot;

  const coords = [...lot.coords];
  if (coords.length < 3) return;

  if (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1]) {
    coords.push(coords[0]);
  }

  coords.forEach((_, i) => {
    if (i >= coords.length - 1) return;

    setTimeout(() => {
      const start = coords[i];
      const end = coords[i + 1];
      const midpoint = [(start[0] + end[0]) / 2, (start[1] + end[1]) / 2];

      const distance = turf.distance(turf.point(start), turf.point(end), { units: 'meters' });
      const roundedDistance = Math.round(distance * 2) / 2;

      const label = document.createElement('div');
      label.className = 'side-length-label';
      label.textContent = `${roundedDistance}m`;
      label.style.position = 'absolute';

      const pixelPos = map.project(midpoint);
      label.style.left = `${pixelPos.x}px`;
      label.style.top = `${pixelPos.y}px`;
      label.style.transform = 'translate(-50%, -50%) scale(0.4)';
      label.style.opacity = '0';
      label.style.transform = 'scale(0.4)';
      label.style.animation = 'pop-in 0.35s cubic-bezier(0.25, 1.25, 0.5, 1) forwards';

      document.getElementById('map').appendChild(label);
      requestAnimationFrame(() => label.style.opacity = '1');

      sideLengthLabels.push(label);
    }, i * 200);
  });
  map.on('move', updateSideLengthPositions);
}

function updateSideLengthPositions() {
  if (!currentLabeledLot || sideLengthLabels.length === 0) return;
  
  // Make sure we have the same number of labels as coordinates
  const coords = [...currentLabeledLot.coords];
  if (coords[0][0] !== coords[coords.length - 1][0] || 
      coords[0][1] !== coords[coords.length - 1][1]) {
    coords.push(coords[0]);
  }
  
  // Safety check - if labels and coordinates don't match, recreate labels
  if (sideLengthLabels.length !== coords.length - 1) {
    removeSideLengthLabels();
    addSideLengthLabels(currentLabeledLot);
    return;
  }

  for (let i = 0; i < coords.length - 1; i++) {
    const start = coords[i];
    const end = coords[i + 1];
    const midpoint = [
      (start[0] + end[0]) / 2,
      (start[1] + end[1]) / 2
    ];
    
    const pixelPos = map.project(midpoint);
    sideLengthLabels[i].style.left = `${pixelPos.x}px`;
    sideLengthLabels[i].style.top = `${pixelPos.y}px`;
  }
}

function removeSideLengthLabels() {
  // Remove all side length labels from the DOM
  sideLengthLabels.forEach(label => {
    if (label && label.parentNode) {
      label.parentNode.removeChild(label);
    }
  });
  
  // Clear the array
  sideLengthLabels = [];
  currentLabeledLot = null;
  
  // Remove the move event listener
  map.off('move', updateSideLengthPositions);
  
  // Also remove any potentially orphaned labels
  const allLabels = document.querySelectorAll('.side-length-label');
  allLabels.forEach(label => {
    if (label.parentNode) {
      label.parentNode.removeChild(label);
    }
  });
}
</script>

<script>
// ROAD: Add and animate road layer
const roadGeojson = {
  type: "FeatureCollection",
  features: [{
    type: "Feature",
    geometry: {
      type: "LineString",
      coordinates: [
        [-100.157757, 25.45803],
        [-100.157888, 25.458456],
        [-100.158984, 25.45995],
        [-100.15855, 25.460763],
        [-100.158634, 25.461454],
        [-100.158488, 25.462755],
        [-100.15872, 25.463296],
        [-100.16009, 25.465042],
        [-100.161556, 25.464865],
        [-100.163154, 25.465748],
        [-100.164051, 25.465707],
        [-100.165586, 25.466227],
        [-100.165558, 25.466294],
        [-100.164039, 25.46578],
        [-100.163133, 25.465821],
        [-100.161538, 25.46494],
        [-100.160053, 25.465119],
        [-100.158649, 25.463331],
        [-100.158407, 25.462765],
        [-100.158554, 25.461455],
        [-100.158468, 25.46075],
        [-100.158893, 25.459956],
        [-100.157814, 25.458486],
        [-100.15768, 25.458049]
      ]
    }
  }]
};

// Function to add and animate road layer
function loadRoad(map, cb) {
  map.addSource('road', { type: 'geojson', data: roadGeojson });
  map.addLayer({
    id: 'road',
    type: 'line',
    source: 'road',
    paint: { 'line-color': '#fff', 'line-width': 1, 'line-opacity': 0 }
  });

  let start = null;
  function animate(ts) {
    if (!start) start = ts;
    let p = Math.min((ts - start) / 500, 1);
    map.setPaintProperty('road', 'line-opacity', p);
    if (p < 1) requestAnimationFrame(animate);
    else cb();
  }
  requestAnimationFrame(animate);
}
</script>

<script>
// LOT PARSING: Load and parse lot data
function loadLotsAsync(map) {
  return fetch('https://lalaland.mx/lots.txt')
    .then(r => r.text())
    .then(txt => {
      lotData = parseLots(txt);
    });
}

function parseLots(text) {
  const lines = text.trim().split('\n');
  const lots = [], curr = null;
  let currentLot = null;

  lines.forEach(line => {
    line = line.trim();
    if (!line) return;

    if (!line.startsWith('{')) {
      if (currentLot) lots.push(currentLot);
      currentLot = { name: line, coords: [] };
    } else {
      const m = line.match(/lat:\s*([0-9.\-]+),\s*lng:\s*([0-9.\-]+)/);
      if (m && currentLot) currentLot.coords.push([+m[2], +m[1]]);
    }
  });

  if (currentLot) lots.push(currentLot);

  // ‚ûï Calculate center using Turf
  lots.forEach(lot => {
    try {
      const poly = turf.polygon([[...lot.coords, lot.coords[0]]]); // Close ring
      const center = turf.centroid(poly).geometry.coordinates;
      lot.center = center;
    } catch (err) {
      console.warn('Failed to calculate center for', lot.name, err);
      lot.center = [0, 0]; // Fallback
    }
  });

  return lots;
}
</script>

<script>
  // FETCH AVAILABILITY SUPABASE
  // Async function to fetch availability info from Supabase and attach it to lotData
  async function enrichLotsWithAvailability() {
    if (!lotData || lotData.length === 0) {
      console.warn('lotData is empty, cannot enrich availability');
      return;
    }

    if (!window.supabaseClient) {
      console.error('Supabase client not initialized yet.');
      return;
    }
  
    const names = lotData.map(lot => lot.name);

    const { data, error } = await window.supabaseClient
      .from('lots')
      .select('lot_name, availability, rSize, millones, fraccionamiento')
      .in('lot_name', names);

    if (error) {
      console.error('Error fetching lot availability from Supabase:', error);
      return;
    }

    if (data && data.length > 0) {
      data.forEach(row => {
        const lot = lotData.find(l => l.name === row.lot_name);
        if (lot) {
          const raw = row.availability ?? 'Available';        // preserve title case if you want it in DB
          lot.availability = raw;                             // e.g. "Available", "Sold", "Featured"
          lot.featured = raw.toLowerCase() === 'featured';    // keep a boolean too (for legacy paths)
          lot.rSize = row.rSize;
          lot.millones = row.millones;
          lot.fraccionamiento = row.fraccionamiento;          // Add fraccionamiento data
        }
      });
      console.log('Lot data enriched with availability and fraccionamiento:', lotData);
    } else {
      console.warn('No availability data returned for lots');
    }
  }
</script>

<script>
// ========== DRAW X ON SOLD LOTS ==========
function addSoldXs(map, soldLots, fadeDuration = 500) {
  if (!map.getSource('sold-x')) {
    map.addSource('sold-x', {
      type: 'geojson',
      data: { type: 'FeatureCollection', features: [] }
    });

    map.addLayer({
      id: 'sold-x-layer',
      type: 'line',
      source: 'sold-x',
      layout: {},
      paint: {
        'line-color': 'white',
        'line-width': 1,
        'line-opacity': 0,
        'line-opacity-transition': { duration: fadeDuration }
      }
    });
  }

  const newFeatures = soldLots.flatMap(makeXFeatures);

  // Merge with existing features
  const source = map.getSource('sold-x');
  const current = source._data?.features || [];
  const updated = [...current, ...newFeatures];

  source.setData({ type: 'FeatureCollection', features: updated });

  // ‚è≥ Fade in after tiny delay to ensure features are added first
  setTimeout(() => {
    map.setPaintProperty('sold-x-layer', 'line-opacity', 0.49);
  }, 10);
}

function makeXFeatures(lot) {
  const coords = lot.coords;
  if (!coords || coords.length < 3) return [];

  // Ensure polygon is not closed twice
  if (
    coords[0][0] === coords[coords.length - 1][0] &&
    coords[0][1] === coords[coords.length - 1][1]
  ) {
    coords.pop();
  }

  const n = coords.length;
  if (n === 4) {
    return [
      {
        type: 'Feature',
        properties: { lotName: lot.name },
        geometry: { type: 'LineString', coordinates: [coords[0], coords[2]] }
      },
      {
        type: 'Feature',
        properties: { lotName: lot.name },
        geometry: { type: 'LineString', coordinates: [coords[1], coords[3]] }
      }
    ];
  }

  function distance(p1, p2) {
    const dx = p2[0] - p1[0];
    const dy = p2[1] - p1[1];
    return Math.sqrt(dx * dx + dy * dy);
  }

  let maxDistance = 0;
  let farthestPair = [];
  let secondMaxDistance = 0;
  let secondFarthestPair = [];

  for (let i = 0; i < coords.length; i++) {
    for (let j = i + 1; j < coords.length; j++) {
      const dist = distance(coords[i], coords[j]);
      if (dist > maxDistance) {
        secondMaxDistance = maxDistance;
        secondFarthestPair = [...farthestPair];
        maxDistance = dist;
        farthestPair = [coords[i], coords[j]];
      } else if (dist > secondMaxDistance) {
        secondMaxDistance = dist;
        secondFarthestPair = [coords[i], coords[j]];
      }
    }
  }

  const threshold = 0.000038;
  function isTooClose(p, a, b) {
    return distance(p, a) < threshold || distance(p, b) < threshold;
  }

  let secondMaxDistanceCheck = 0;
  let secondFarthestPairCheck = [];

  for (let i = 0; i < coords.length; i++) {
    for (let j = i + 1; j < coords.length; j++) {
      if (
        coords[i] === farthestPair[0] || coords[i] === farthestPair[1] ||
        coords[j] === farthestPair[0] || coords[j] === farthestPair[1]
      ) continue;
      if (
        isTooClose(coords[i], farthestPair[0], farthestPair[1]) ||
        isTooClose(coords[j], farthestPair[0], farthestPair[1])
      ) continue;

      const dist = distance(coords[i], coords[j]);
      if (dist > secondMaxDistanceCheck) {
        secondMaxDistanceCheck = dist;
        secondFarthestPairCheck = [coords[i], coords[j]];
      }
    }
  }

  const features = [
    {
      type: 'Feature',
      properties: { lotName: lot.name },
      geometry: { type: 'LineString', coordinates: farthestPair }
    }
  ];

  if (secondFarthestPairCheck.length === 2) {
    features.push({
      type: 'Feature',
      properties: { lotName: lot.name },
      geometry: { type: 'LineString', coordinates: secondFarthestPairCheck }
    });
  }

  return features;
}
</script>

<script>
// LOT ANIMATION: Animate the appearance of lots
function animateLots(map, cb) { 
  const groups = 20,
    delay = 80,
    duration = 250,
    finalDelay = 200; 
  const fadeDuration = 500;
  const fadeDurationXs = 1500; 

  // Shuffle lots
  const shuffled = [...Array(lotData.length).keys()];
  shuffle(shuffled);

  // Divide into groups
  const groupArr = Array.from({ length: groups }, () => []);
  shuffled.forEach((i, idx) => groupArr[idx % groups].push(i));

  // Render each group with fade-in animation
  groupArr.forEach((g, i) => {
    const geojson = {
      type: "FeatureCollection",
      features: g.map((idx) => lotFeature(lotData[idx])),
    };
    map.addSource(`lot-group-${i}`, { type: "geojson", data: geojson });
    
    // Add BOTH layers for this group
    map.addLayer({
      id: `lot-group-${i}-available`,
      type: "line",
      source: `lot-group-${i}`,
      paint: {
        "line-color": "#fff",
        "line-width": 1,
        "line-opacity": 0,
        "line-opacity-transition": { duration: fadeDuration },
      },
      filter: ["!=", ["get", "availability"], "Sold"]
    });
    
    map.addLayer({
      id: `lot-group-${i}-sold`, 
      type: "line",
      source: `lot-group-${i}`,
      paint: {
        "line-color": "#fff",
        "line-width": 1,
        "line-opacity": 0,
        "line-opacity-transition": { duration: fadeDuration },
      },
      filter: ["==", ["get", "availability"], "Sold"]
    });
    
    setTimeout(() => {
      // Fade in BOTH layers for this group
      map.setPaintProperty(`lot-group-${i}-available`, "line-opacity", 1);
      map.setPaintProperty(`lot-group-${i}-sold`, "line-opacity", 0.24); // ‚¨ÖÔ∏è 0.24 for group layer
      
      // Draw Xs for sold lots in this group
      const soldInGroup = g
        .map(idx => lotData[idx])
        .filter(lot => (lot.availability ?? '').toLowerCase() === 'sold');
      
      if (soldInGroup.length > 0) {
        addSoldXs(map, soldInGroup, fadeDurationXs);
      }
    }, i * delay);
  });

  // Add final lots layer (initially transparent but visible)
  const finalGeojson = {
    type: "FeatureCollection",
    features: lotData.map((lot, i) => lotFeature(lot, i))
  };
  map.addSource("lots-final", { type: "geojson", data: finalGeojson });

  // Create TWO separate layers instead of one
  map.addLayer({
    id: "lots-final-available",
    type: "line",
    source: "lots-final",
    layout: { visibility: "visible" },
    paint: {
      "line-color": "#fff",
      "line-width": 1.5,
      "line-opacity": 0,
      "line-opacity-transition": { duration: fadeDuration },
    },
    filter: ["!=", ["get", "availability"], "Sold"] // Show only available lots
  });
  
  map.addLayer({
    id: "lots-final-sold",
    type: "line",
    source: "lots-final",
    layout: { visibility: "visible" },
    paint: {
      "line-color": "#fff",
      "line-width": 1,
      "line-opacity": 0,
      "line-opacity-transition": { duration: fadeDuration },
    },
    filter: ["==", ["get", "availability"], "Sold"] // Show only sold lots
  });

  map.addLayer({ //HAD TO ADD THIS FOR CLICKABLE LOTS
    id: "lots-final-click",
    type: "fill",
    source: "lots-final",
    layout: { visibility: "visible" },
    paint: {
      "fill-color": "#000",      // any color
      "fill-opacity": 0          // invisible
    }
  });

  // After all groups have faded in & paused, fade in final lots, then fade out all groups simultaneously
  setTimeout(() => {
    // Fade in final lots - sold lots get 0.25 to make total 0.49 during transition
    map.setPaintProperty("lots-final-available", "line-opacity", 1);
    map.setPaintProperty("lots-final-sold", "line-opacity", 0.25); // ‚¨ÖÔ∏è 0.25 for final layer during transition

    setTimeout(() => {
      // Fade out all lot groups simultaneously
      groupArr.forEach((_, i) => {
        const availableId = `lot-group-${i}-available`;
        const soldId = `lot-group-${i}-sold`;
        
        if (map.getLayer(availableId)) map.setPaintProperty(availableId, "line-opacity", 0);
        if (map.getLayer(soldId)) map.setPaintProperty(soldId, "line-opacity", 0);
      });

      // AFTER group layers fade out, update final sold layer to full 0.49
      setTimeout(() => {
        map.setPaintProperty("lots-final-sold", "line-opacity", 0.49); // ‚¨ÖÔ∏è UPDATE TO FULL 0.49
         
        // Remove all lot groups
        groupArr.forEach((_, i) => {
          const availableId = `lot-group-${i}-available`;
          const soldId = `lot-group-${i}-sold`;
          const sourceId = `lot-group-${i}`;
          
          if (map.getLayer(availableId)) map.removeLayer(availableId);
          if (map.getLayer(soldId)) map.removeLayer(soldId);
          if (map.getSource(sourceId)) map.removeSource(sourceId);
        });
        if (cb) cb();
      }, fadeDuration);
    }, finalDelay + fadeDuration);
  }, groups * delay + duration);
}

// Helpers unchanged HERE COLOR IS ADDED DEPENDING ON AVAILABILITY
function lotFeature(lot, index) {
  const c = [...lot.coords];
  if (c[0][0] !== c[c.length - 1][0] || c[0][1] !== c[c.length - 1][1]) c.push(c[0]);
  return {
    type: "Feature",
    geometry: { type: "Polygon", coordinates: [c] },
    properties: { 
      name: lot.name,
      availability: lot.availability || 'Available' // Add this line
    },
    id: index
  };
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}
</script>

<script>
// DRONE IMAGE - Add custom recent drone satellite image as a raster layer
function addCustomImage(map, imageType = 'drone') {
  const images = {
    drone: {
      url: 'https://lalaland.mx/santte2.jpg',
      layerId: 'drone-satellite-layer',
      sourceId: 'drone-satellite',
      message: "Cargamos la im√°gen a√©rea m√°s actual ‚Äî (marzo 2025)",
      bounds: [
        [-100.16483, 25.467111], // Top-left [lng, lat]
        [-100.154874, 25.467111], // Top-right
        [-100.154874, 25.457155], // Bottom-right
        [-100.16483, 25.457155],  // Bottom-left
      ]
    },
    agora: {
      url: 'https://lalaland.mx/agora.jpg',
      layerId: 'agora-satellite-layer',
      sourceId: 'agora-satellite',
      message: "Cargamos la im√°gen a√©rea m√°s actual ‚Äî (marzo 2025)",
      bounds: [
    [-100.183685, 25.443361], // Top-left [lng, lat]
    [-100.173731, 25.443361], // Top-right
    [-100.173731, 25.433407], // Bottom-right
    [-100.183685, 25.433407], // Bottom-left
      ]
    }
  };

  const config = images[imageType];

  // Remove existing layers/sources if they exist
  if (map.getLayer(config.layerId)) {
    map.removeLayer(config.layerId);
  }
  if (map.getSource(config.sourceId)) {
    map.removeSource(config.sourceId);
  }

  map.addSource(config.sourceId, {
    type: 'image',
    url: config.url,
    coordinates: config.bounds
  });

  map.addLayer({
    id: config.layerId,
    type: 'raster',
    source: config.sourceId,
    paint: {
      'raster-opacity': 0
    }
  }, 'road');

  fadeInImage(map, config.layerId);
  showToaster(config.message);
}

//CTA
function showCta(message = "Want more info about this lot?", duration = 5000) {
  const ctaToaster = document.getElementById('ctaToaster');
  ctaToaster.classList.remove('hidden');
  ctaToaster.textContent = message;
  ctaToaster.classList.add('show');
 
  setTimeout(() => {
    ctaToaster.classList.remove('show');
    setTimeout(() => ctaToaster.classList.add('hidden'), 400); // Wait for fade out
  }, duration);
}
 
// Fade-in effect for the image (opacity increases gradually from 0 to 1)
function fadeInImage(map, layerId) {
  let opacity = 0;
  const interval = setInterval(() => {
    opacity += 0.05;  // Increase opacity gradually
    if (opacity >= 1) {
      opacity = 1;
      clearInterval(interval); // Stop once opacity reaches 1
    }
    map.setPaintProperty(layerId, 'raster-opacity', opacity);
  }, 50); // Adjust the interval for smoother or faster fade-in
}

function showToaster(message, duration = 3000) {
  const toaster = document.getElementById('toaster');
  toaster.textContent = message;
  toaster.classList.add('show');

  setTimeout(() => {
    toaster.classList.remove('show');
  }, duration);
} 
</script> 

<script>
// === FEATURED LOT POLYGON PULSE (ASYNC) ===

// Utility to create a polygon feature from a lot
function featuredPolygonFeature(lot) {
  const coords = [...lot.coords];
  if (
    coords.length < 3 ||
    coords[0][0] !== coords[coords.length - 1][0] ||
    coords[0][1] !== coords[coords.length - 1][1]
  ) {
    coords.push(coords[0]); // Ensure closed polygon
  }

  return {
    type: 'Feature',
    geometry: {
      type: 'Polygon',
      coordinates: [coords]
    },
    properties: {
      name: lot.name,
      phase: Math.random() * Math.PI * 2, // ‚úÖ random delay per lot
      opacity: 0.5 // initial value for fill-opacity
    }
  };
}

// Main function ‚Äî still named as requested
// In the addFeaturedLotsLayer function, update the layer insertion point:
function addFeaturedLotsLayer(map, onComplete) {
  const featuredLots = lotData.filter(lot => lot.featured);
  if (featuredLots.length === 0) {
    if (onComplete) onComplete();
    return;
  }

  const features = featuredLots.map(featuredPolygonFeature);

  map.addSource('featured-lots', {
    type: 'geojson',
    data: {
      type: 'FeatureCollection',
      features
    }
  });

  // Orange fill with pulsating opacity - insert above lots-final-available
  map.addLayer({
    id: 'featured-lots-layer',
    type: 'fill',
    source: 'featured-lots',
    paint: {
      'fill-color': '#ff8400',
      'fill-opacity': ['get', 'opacity']
    }
  }, 'lots-final-available'); // ‚Üê CHANGED FROM 'lots-final' to 'lots-final-available'

  // Get the list of all layers
  const layers = map.getStyle().layers;
  let insertBefore = null;

  // Find the correct layer to insert before
  for (let i = 0; i < layers.length; i++) {
    if (layers[i].id === 'sold-x-layer') {
      insertBefore = layers[i + 1]?.id || null;
      break;
    }
  }

  // Add the orange outline above lots-final-click
  map.addLayer({
    id: 'featured-lots-outline',
    type: 'line',
    source: 'featured-lots',
    paint: {
      'line-color': '#ff8400',
      'line-width': 2,
      'line-opacity': 1
    }
  }, 'lots-final-click');  
  
  // Start animation with completion callback 
  startPolygonPulse(map, onComplete); 
}




// Animate each polygon's opacity independently
function startPolygonPulse(map, onComplete) {
  let t = 0;
  let initialPulseCompleted = false;
  const PULSE_DURATION = 2.0; // seconds

  function frame() {
    t += 0.05; // SLOWER: was 0.05, now 0.02 for slower animation

    const source = map.getSource('featured-lots');
    if (!source || !source._data) return;

    const updated = {
      ...source._data,
      features: source._data.features.map(f => {
        const phase = f.properties?.phase ?? 0;
        const opacity = 0.3 + Math.sin(t + phase) * 0.2;
        return {
          ...f,
          properties: {
            ...f.properties,
            opacity
          }
        };
      })
    };

    source.setData(updated);
    
    // Call completion callback after initial pulse duration
    if (!initialPulseCompleted && t >= PULSE_DURATION) {
      initialPulseCompleted = true;
      if (onComplete && typeof onComplete === 'function') {
        onComplete();
      }
    }
    
    requestAnimationFrame(frame); 
  }

  requestAnimationFrame(frame);
}
</script> 



<script>
  // MODAL HERE
let lastOffset = [0, 0];

function adjustMapForModal() {
  if (!map) {
    console.error('Map not initialized');
    return;
  }

  const isMobile = window.innerWidth < 768;

  const offset = isMobile
    ? [0, -window.innerHeight * 0.23] // mobile: pan upward
    : [-240, 0];                      // desktop: pan left

  lastOffset = offset;

  console.log('üîÑ map.panBy:', offset);
  map.panBy(offset, { duration: 800 });
}
 
const modal = document.getElementById('lotModal');
const modalInfo = document.getElementById('modalInfo');
const customScrollbar = document.getElementById('customScrollbar');
const customScrollthumb = document.getElementById('customScrollthumb');
const loadingSpinner = document.getElementById('loadingSpinner');
const lotDetails = document.getElementById('lotDetails');
const backButton = document.getElementById('backButton');
const detailNumber = document.getElementById('detailNumber');
const detailSize = document.getElementById('detailSize');
const detailPrice = document.getElementById('detailPrice');
const detailAvailability = document.getElementById('detailAvailability');
const headerLotNumber = document.getElementById('headerLotNumber');

//scroll thumb for info page
let infiniteScrollUpdater = null;
let infoScrollUpdater = null;

// ===== INFINITE SCROLLBAR (for lot list) =====
function enableInfiniteScrollbar() {
  console.log('Enabling INFINITE scrollbar');
  const modalInfoEl = document.getElementById('modalInfo');
  const bar = document.getElementById('customScrollbar');
  const thumb = document.getElementById('customScrollthumb');

  // Clean up any existing scrollbars first
  disableInfoScrollbar();
  if (infiniteScrollUpdater) {
    disableInfiniteScrollbar();
  }

  const update = () => {
    if (!modalInfoEl || baseLots.length === 0) return;

    const containerHeight = modalInfoEl.clientHeight;
    const contentHeight = modalInfoEl.scrollHeight;
    const scrollTop = modalInfoEl.scrollTop;

    if (contentHeight === 0) {
      thumb.style.height = '0px';
      thumb.style.transform = 'translateY(0)';
      return;
    }

    const rowHeight = contentHeight / lots.length;
    const bufferHeight = rowHeight * cloneCount;
    const baseHeight = rowHeight * baseLots.length;

    const thumbHeight = Math.max(20, (containerHeight / contentHeight) * containerHeight);
    thumb.style.height = `${thumbHeight}px`;

    let baseScrollTop = ((scrollTop - bufferHeight) % baseHeight);
    if (baseScrollTop < 0) baseScrollTop += baseHeight;
    baseScrollTop = Math.min(baseScrollTop, baseHeight - containerHeight);

    const scrollRatio = baseScrollTop / (baseHeight - containerHeight);
    const thumbPosition = scrollRatio * (containerHeight - thumbHeight);

    thumb.style.transform = `translateY(${thumbPosition}px)`;
  };

  infiniteScrollUpdater = update;
  
  bar.style.display = '';
  update();
  
  // Remove any existing scroll listener first
  modalInfoEl.removeEventListener('scroll', handleScroll);
  modalInfoEl.addEventListener('scroll', handleScroll);
  window.addEventListener('resize', update);
}

function disableInfiniteScrollbar() {
  console.log('Disabling INFINITE scrollbar');
  const modalInfoEl = document.getElementById('modalInfo');
  if (infiniteScrollUpdater) {
    modalInfoEl.removeEventListener('scroll', handleScroll);
    window.removeEventListener('resize', infiniteScrollUpdater);
    infiniteScrollUpdater = null;
  }
}

// ===== NATURAL SCROLLBAR (for info page) =====
function enableInfoScrollbar() {
  console.log('Enabling INFO scrollbar');
  const modalInfoEl = document.getElementById('modalInfo');
  const bar = document.getElementById('customScrollbar');
  const thumb = document.getElementById('customScrollthumb');

  // Clean up infinite scroll first
  disableInfiniteScrollbar();
  if (infoScrollUpdater) {
    disableInfoScrollbar();
  }

  const update = () => {
    if (!modalInfoEl) return;
    
    const H = modalInfoEl.scrollHeight;
    const h = modalInfoEl.clientHeight;
    const t = modalInfoEl.scrollTop;

    if (H <= h) {
      thumb.style.height = '0px';
      thumb.style.transform = 'translateY(0)';
      return;
    }

    const th = Math.max(20, (h / H) * h);
    const top = (t / (H - h)) * (h - th);
    thumb.style.height = `${th}px`;
    thumb.style.transform = `translateY(${top}px)`;
  };

  infoScrollUpdater = update;
  
  bar.style.display = '';
  update();
  
  // Remove any existing scroll listeners first
  modalInfoEl.removeEventListener('scroll', update);
  modalInfoEl.addEventListener('scroll', update);
  window.addEventListener('resize', update);
}

function disableInfoScrollbar() {
  console.log('Disabling INFO scrollbar');
  const modalInfoEl = document.getElementById('modalInfo');
  if (infoScrollUpdater) {
    modalInfoEl.removeEventListener('scroll', infoScrollUpdater);
    window.removeEventListener('resize', infoScrollUpdater);
    infoScrollUpdater = null;
  }
}




let cloneCount = 5;
let baseLots = [];
let lots = [];
let isDataLoaded = false;
let previousMapView = null; // for "Back" button inside modal
let preModalView = null;    // for closing modal completely
let isDragging = false;
let isScrollbarDragging = false;
let dragStartY = 0;
let dragStartScroll = 0;
let scrollTimeout;
let scrollHandlerAttached = true;
let clampCooldown = false;
let infoMode = false;

function extractLotNumber(lotName) {
  // Remove only the 'lot' prefix (case-insensitive) but keep any remaining letters
  const withoutLotPrefix = lotName.replace(/^lot/i, '');
  return withoutLotPrefix;
}

async function fetchLots() {
  try {
    loadingSpinner.style.display = 'block';
    modalInfo.style.opacity = '0.5';
    
    await window.supabaseReady;
    
    // Fetch ALL data (including images) upfront
    const { data, error } = await window.supabaseClient
      .from('lots')
      .select('lot_name, rSize, millones, availability, fraccionamiento, nickname, subtitle, image')
      .order('lot_name', { ascending: true });
    
    if (error) throw error;
    
    baseLots = data.map(lot => ({
      number: extractLotNumber(lot.lot_name),
      size: lot.rSize,
      price: lot.millones,
      availability: lot.availability,
      fraccionamiento: lot.fraccionamiento,
      // Store all detail data upfront
      detailData: {
        nickname: lot.nickname,
        subtitle: lot.subtitle,
        image: lot.image
      }
    }));
    
    
    window.baseLotsAll = baseLots.slice();
updateLotsArray();
    isDataLoaded = true;
    console.log('‚úÖ Pre-loaded all lots + images');
  } catch (error) {
    console.error('Error fetching lots:', error);
    // Fallback dummy data
    baseLots = Array.from({ length: 10 }, (_, i) => ({
      number: 100 + i,
      size: '150',
      price: '1.5',
      availability: 'available',
      detailData: {
        nickname: `Lot ${100 + i}`,
        image: 'https://via.placeholder.com/800x400?text=No+Image'
      }
    }));
    updateLotsArray();
  } finally {
    loadingSpinner.style.display = 'none';
    modalInfo.style.opacity = '1';
  }
}

function updateLotsArray() {
  lots = [
    ...baseLots.slice(-cloneCount).map(l => ({ ...l, clone: true })),
    ...baseLots,
    ...baseLots.slice(0, cloneCount).map(l => ({ ...l, clone: true }))
  ];
}

function setupLotClickHandlers() {
  const allRows = document.querySelectorAll('.info-row');

  allRows.forEach(row => {
    row.addEventListener('click', async (e) => {
      const index = row.dataset.index;
      const lot = lots[index];
      const status = (lot.availability ?? '').toLowerCase();

      if (status === 'sold') return;

      // If a detail is already open, switch to the new lot
      if (isDetailOpen) {
        // Save the current map state before switching
        if (map && map.getCenter) {
          previousMapView = {
            center: map.getCenter().toArray(),
            zoom: map.getZoom(),
            bearing: map.getBearing(),
            pitch: map.getPitch()
          };
        }

        const lotNumber = lot.number;
        const lotMapIndex = lotData.findIndex(l => extractLotNumber(l.name) === lotNumber);
        
        if (lotMapIndex !== -1 && lotData[lotMapIndex].center && map) {
          const [lng, lat] = lotData[lotMapIndex].center;
          currentLotIndex = lotMapIndex;

          // Animate map to new lot
          await new Promise(resolve => {
            map.once('moveend', resolve);

            const isDesktop = window.innerWidth >= 768;
            const xOffset = isDesktop ? 310 : 0;
            const yOffset = isDesktop ? 0 : 180;

            map.easeTo({
              center: [lng, lat],
              zoom: 18.8,
              speed: 1.2,
              curve: 1.5,
              offset: [xOffset, yOffset]
            });
          });

          // Switch to the new lot's detail view
          showDetailViewForLot(index, true);
        } else {
          // Fallback if map data isn't available
          showDetailViewForLot(index, true);
        }
        
        e.stopPropagation();
        return; // üö® CRITICAL: Exit the function here!
      }

      // Original code for when detail view is NOT open
      if (status === 'featured' || status === 'available') {
        // Save map state
        if (map && map.getCenter) {
          preModalView = {
            center: map.getCenter().toArray(),
            zoom: map.getZoom(),
            bearing: map.getBearing(),
            pitch: map.getPitch()
          };
        }

        const lotNumber = lot.number;
        const lotMapIndex = lotData.findIndex(l => extractLotNumber(l.name) === lotNumber);
        
        if (lotMapIndex !== -1 && lotData[lotMapIndex].center && map) {
          previousMapView = {
            center: map.getCenter().toArray(),
            zoom: map.getZoom(),
            bearing: map.getBearing(),
            pitch: map.getPitch()
          };

          const [lng, lat] = lotData[lotMapIndex].center;
          currentLotIndex = lotMapIndex;

          // 1. First start the map animation
          await new Promise(resolve => {
            map.once('moveend', resolve);

            const isDesktop = window.innerWidth >= 768;
            const xOffset = isDesktop ? 310 : 0;
            const yOffset = isDesktop ? 0 : 180;

            map.easeTo({
              center: [lng, lat],
              zoom: 18.8,
              speed: 1.2,
              curve: 1.5,
              offset: [xOffset, yOffset]
            });
          });

          // 2. Then show detail view for the new lot
          showDetailViewForLot(index);
        } else {
          // Fallback if map data isn't available
          showDetailViewForLot(index);
        }
      }

      e.stopPropagation();
    });
  });
}



async function showDetailViewForLot(index, isSwitchingLots = false) {
  const modalEl        = document.getElementById('lotModal');
  const lotDetails     = document.getElementById('lotDetails');
  const calendlyEl     = document.getElementById('calendlyEmbed');
  const contentWrapper = document.querySelector('.modal-content-wrapper');
  const bottomPlusEl   = document.querySelector('.bottom-plus-button');
  const plusBtnEl      = document.querySelector('.plus-button');
  const backBtnEl      = document.getElementById('backButton');
const plusBtn = document.querySelector('.plus-button');
if (plusBtn) {
  plusBtn.style.display = 'none';
}
document.getElementById('authControls').classList.add('hide-in-detail');

  // ---- data
  const lot = lots?.[index];
  if (!lot) return;

  const status = String(lot.availability || '').toLowerCase();
  if (status === 'sold') return;

  const lotMapData = Array.isArray(lotData)
    ? lotData.find(l => extractLotNumber(l.name) === lot.number)
    : null;



    

  const detailData = lot.detailData || {};

  // ---- prep
  isDetailOpen = true;
  if (calendlyEl) calendlyEl.style.display = 'none';

  // Clear only lotDetails content (but not other UI like back button)
  lotDetails.classList.remove('active');
  lotDetails.innerHTML = '';

  if (isSwitchingLots && typeof removeSideLengthLabels === 'function' && currentLabeledLot) {
    removeSideLengthLabels();
  }

  // Ensure modal is in info/detail mode
  modalEl.classList.remove('pin-mode', 'lot-mode');
  modalEl.classList.add('info-mode');

  if (bottomPlusEl) bottomPlusEl.style.display = '';
  if (plusBtnEl) plusBtnEl.style.display = '';
  if (backBtnEl) backBtnEl.style.display = 'flex';

  // ---- build
  const detailContainer = document.createElement('div');
  detailContainer.className = 'detail-container';

  // Header
  const headerSection = document.createElement('div');
  headerSection.className = 'detail-header';

  const nickname = detailData.nickname || ('');
  const subtitle = detailData.subtitle || (lotMapData?.subtitle || '');
  const isFeatured = status === 'featured';

  headerSection.innerHTML = `
    <div class="tag-row">
      ${isFeatured ? '<div class="featured-tag">SELECCI√ìN LALALAND</div>' : ''}
      <div class="nickname">${nickname}</div>
    </div>
    ${subtitle ? `<div class="subtitle-row">${subtitle}</div>` : ''}
  `;
  detailContainer.appendChild(headerSection);

  // Price/size row
  const detailRow = document.createElement('div');
  detailRow.className = 'detail-data-row';

  const price = parseFloat(lot.price);
  const size  = parseFloat(lot.size);
  let pricePerM2Formatted = 'N/A';
  if (price > 0 && size > 0) {
    const pricePerM2 = (price * 1_000_000) / size;
    pricePerM2Formatted = `$${pricePerM2.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ",")}<sup class="sup">/M2</sup>`;
  }

detailRow.innerHTML = `
  <div class="lot-left">
    <div class="lote-label">LOTE</div>
    <div class="lote-number">${lot.number.replace(/^[a-z]+/i, '')}</div>
    <div style="font-size: 14px; color: #8a8880; margin-top: 4px;">
      ID: ${lot.number}
    </div>
  </div>

  <div class="lot-middle">
    ${lot.size}<span class="sup">M2</span>
  </div>

  <div class="lot-price">
    <div class="price-wrapper">
      ${editMode ? 
        `<input type="text" class="price-edit" value="${lot.price}" data-lot-number="${lot.number}" data-original-price="${lot.price}">` :
        `<span class="price">$${lot.price}</span>`
      }
      <span class="mdp">MDP</span>
    </div>
  </div>

  <div class="price-per-m2-column">${pricePerM2Formatted}</div>
`;

  detailContainer.appendChild(detailRow);

  // üü¢ ADD SUPABASE SAVE CODE RIGHT HERE
  if (editMode) {
    const priceInput = detailContainer.querySelector('.price-edit');
    
    priceInput.addEventListener('blur', async function() {
    const newPrice = this.value.replace('$', '').trim();
    const lotNumber = this.dataset.lotNumber;
    const originalPrice = this.dataset.originalPrice;
    
    if (!newPrice || newPrice === originalPrice) return;
    
    try {
        await window.supabaseReady;
        const { error } = await window.supabaseClient
            .from('lots')
            .update({ millones: newPrice })
            .eq('lot_name', `lot${lotNumber}`);
        
        if (error) throw error;
        
        showToaster(`‚úÖ Price updated to $${newPrice} MDP`);
        this.dataset.originalPrice = newPrice;
        
        // üü¢ UPDATE IMMEDIATELY while waiting for real-time
        const baseLot = window.baseLotsAll.find(bl => bl.number === lotNumber);
        if (baseLot) baseLot.price = newPrice;
        
        const currentBaseLot = baseLots.find(bl => bl.number === lotNumber);
        if (currentBaseLot) currentBaseLot.price = newPrice;
        
    } catch (error) {
        console.error('Failed to update price:', error);
        showToaster('‚ùå Failed to update price');
        this.value = originalPrice;
    }
});

    priceInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') this.blur();
    });
  }

  // CTA Buttons Section
  const ctaSection = document.createElement('div');
  ctaSection.className = 'detail-cta-section';
  
  // Header labels
  const ctaHeader = document.createElement('div');
  ctaHeader.className = 'cta-header';
  ctaHeader.innerHTML = `
    <div class="cta-header-label">PR√ìXIMAMENTE</div>
    <div class="cta-header-label"></div>
    <div class="cta-header-label" style="color:#ff8400; display:flex; align-items:center; justify-content:center;">
    <!-- This will be dynamically filled by updateChatHeaderVisibility() -->
    DISPONIBLE AHORA
  </div>
  `;
  
  // Buttons row
  const buttonsRow = document.createElement('div');
  buttonsRow.className = 'cta-buttons-row';
  buttonsRow.innerHTML = `
    <button class="cta-button third" id="separarBtn">SEPARAR</button>
    <button class="cta-button first" id="visitarBtn">VISITAR</button>
    <button class="cta-button second" id="chatearBtn">CHATEAR</button>
  `;
  
  ctaSection.appendChild(ctaHeader);
  ctaSection.appendChild(buttonsRow);
  detailContainer.appendChild(ctaSection);

  // Use event delegation instead of direct event listeners
  detailContainer.addEventListener('click', function(e) {
    if (e.target.id === 'separarBtn') {
      // Add your "Separar" functionality here
      console.log('Separar button clicked');
      e.stopPropagation();
    } else if (e.target.id === 'visitarBtn') {
      // Existing Calendly functionality
      lotDetails.style.display = 'none';
      if (calendlyEl) calendlyEl.style.display = 'block';
      try { 
        loadCalendlyWidget?.({ lot, detailData: { nickname, subtitle } }); 
      } catch (e) {
        console.error('Calendly error:', e);
      }
      e.stopPropagation();
    } else if (e.target.id === 'chatearBtn') {
      // Add your "Chatear" functionality here
      console.log('Chatear button clicked');
      // Example: open WhatsApp
      // window.open('https://wa.me/5218185261819', '_blank');
      e.stopPropagation();
    }
  });

// In showDetailViewForLot function, after creating ctaSection:
detailContainer.appendChild(ctaSection);

// Initialize chat availability features
setTimeout(() => {
  initChatAvailability();
}, 100);

  // Mount and activate
  lotDetails.appendChild(detailContainer);
  contentWrapper?.classList.add('show-details');
  lotDetails.classList.add('active');

// üîπ Show lot dimensions like before
if (lotMapData) {
  const currentZoom = map.getZoom();
  if (currentZoom >= 18.8) {
    if (currentLabeledLot && currentLabeledLot.name !== lotMapData.name) {
      removeSideLengthLabels();
    }
    addSideLengthLabels(lotMapData);
    currentLabeledLot = lotMapData;
  }
}

//index to scroll
  const baseIndex = baseLots.findIndex(l => l.number === lot.number);
lastOpenedBaseIndex = baseIndex;

  // Calendly hook
  scheduleButton.addEventListener('click', function () {
    lotDetails.style.display = 'none';
    if (calendlyEl) calendlyEl.style.display = 'block';
    try { loadCalendlyWidget?.({ lot, detailData: { nickname, subtitle } }); } catch (e) {}
  }, { once: true });
}



backButton.addEventListener('click', () => {
  const modal = document.getElementById('lotModal');
  const plusIcon = document.querySelector('.plus-button .plus-icon');
  const minusIcon = document.querySelector('.plus-button .minus-icon');
  const calendly = document.getElementById('calendlyEmbed');

  // üü¢ FIX: Handle 360 viewer back navigation FIRST
  if (modal.classList.contains('viewer-mode')) {
    close360ViewerInModal();
    return;
  }

  isDetailOpen = false;
  removeSideLengthLabels(); // keep it

  // If we were in Calendly, just go back to details
  if (calendly && calendly.style.display === 'block') {
    calendly.style.display = 'none';
    document.getElementById('lotDetails').style.display = 'block';
    return;
  }

  // Collapse if expanded
  if (modal.classList.contains('expanded')) {
    modal.classList.remove('expanded');
    plusIcon.style.display = 'block';
    minusIcon.style.display = 'none';
  }

  // === Return to LIST mode UI ===
  headerLotNumber.style.display = 'none';
  document.querySelector('.modal-content-wrapper').classList.remove('show-details');
  lotDetails.classList.remove('active');
  backButton.style.display = 'none';
  document.querySelector('.plus-button').style.display = 'none';
  modal.classList.add('lot-mode');
  modal.classList.remove('info-mode');

  // Recenter the list on the last opened lot (your current behavior)
  if (typeof lastOpenedBaseIndex === 'number') {
    requestAnimationFrame(() => {
      scrollToBaseIndex(lastOpenedBaseIndex, false);
    });
  }

  // === Re-arm scrolling + hover ===
  // 1) Ensure the custom (infinite) scrollbar is active again
  try {
    enableInfiniteScrollbar();   // reattach scroll -> handleScroll
  } catch {}

  // 2) Force one pass of highlight + thumb sync
  try {
    highlightCenter();           // computes centered row/lot
    updateScrollbar();
  } catch {}

  // 3) Normalize map hover feature-state to match current selection
  try {
    if (typeof hoveredId !== 'undefined' && hoveredId !== null && map?.getSource('lots-final')) {
      map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
      hoveredId = null;
    }
    // Use your existing selection helpers (added later in the file)
    const sel = (typeof getSelectedLot === 'function') ? getSelectedLot() : null;
    const lotName = sel?.lotName || window.selectedLotName;
    if (lotName && map?.getSource('lots-final')) {
      const mapIndex = lotData.findIndex(l => l.name === lotName);
      if (mapIndex !== -1) {
        map.setFeatureState({ source: 'lots-final', id: mapIndex }, { hover: true });
        hoveredId = mapIndex;
      }
    }
  } catch {}

  // Finally allow scroll handler to run
  scrollHandlerAttached = true;

  // Restore previous map view if you stored one for details
  if (previousMapView && map) {
    map.flyTo({
      center: previousMapView.center,
      zoom: previousMapView.zoom,
      bearing: previousMapView.bearing,
      pitch: previousMapView.pitch,
      speed: 1.2,
      curve: 1.5
    });
    previousMapView = null;
  }
});




function render() {
  modalInfo.innerHTML = '';
  lots.forEach((lot, i) => {
    const row = document.createElement('div');
    row.classList.add('info-row');
    row.dataset.index = i;
    row.dataset.baseIndex = lot.clone ? -1 : baseLots.findIndex(l => l.number === lot.number);

const state = (lot.availability ?? '').toString().toLowerCase();
const isFeatured  = state === 'featured';
const isAvailable = state === 'available';
const isSold      = state === 'sold';

    if (isFeatured) row.classList.add('info-row--featured');

row.innerHTML = `
  <div class="lot-left">
    <div class="lote-label">LOTE</div>
    <div class="lote-number">${lot.number.replace(/^[a-z]+/i, '')}</div>
  </div>

      <div class="lot-middle ${isSold ? 'lot-middle--sold' : ''}">
        ${
          isSold
            ? `<div style="font-size:48px; font-weight:700; color:#ff8400;">VENDIDO</div>`
            : `${lot.size}<span class="sup">M2</span>`
        }
      </div>

      <div class="lot-price ${isSold ? 'lot-price--hidden' : ''}">
        <div class="price-wrapper">
          <span class="price">$${lot.price}</span>
          <span class="mdp">MDP</span>
        </div>
      </div>

<div class="arrow ${isSold ? 'arrow-hidden' : ''}">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 12"
       class="${(isFeatured || isAvailable) ? 'wiggle-arrow' : ''}">
    <path d="M4 3 L7 6 L4 9" stroke="#888" stroke-width="1" fill="none"
          stroke-linecap="round" stroke-linejoin="round"/>
  </svg>
</div>
    `;

    if (isFeatured) {
      const left = document.createElement('div');
      left.classList.add('border-left');
      row.appendChild(left);

      const top = document.createElement('div');
      top.classList.add('border-top');
      row.appendChild(top);

      const label = document.createElement('div');
      label.classList.add('featured-label');
      label.textContent = 'SELECCI√ìN LALALAND';
      row.appendChild(label);
    }

    modalInfo.appendChild(row);
  });
  
  setupLotClickHandlers();
  updateScrollbar();
}

// ===== SIMPLIFIED updateScrollbar =====
function updateScrollbar() {
  const modal = document.getElementById('lotModal');
  
  if (modal.classList.contains('info-mode')) {
    // Info page - use natural scrollbar
    if (infoScrollUpdater) {
      infoScrollUpdater();
    } else {
      enableInfoScrollbar();
    }
  } else {
    // Lot list - use infinite scrollbar
    if (infiniteScrollUpdater) {
      infiniteScrollUpdater();
    } else {
      enableInfiniteScrollbar();
    }
  }
}

function scrollToBaseIndex(baseIndex, smooth = true) {
  if (baseLots.length === 0) return;
  
  const actualIndex = baseIndex + cloneCount;
  const target = modalInfo.querySelector(`.info-row[data-index="${actualIndex}"]`);

  if (target) {
    target.offsetWidth;
    target.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto', block: 'center' });

    if (!smooth) {
      setTimeout(() => {
        highlightCenter();
        updateScrollbar();
      }, 0);
    }
  }
}

const animatedFeaturedLots = new Set();




function highlightCenter(isClamping = false) {
  const rows = [...modalInfo.querySelectorAll('.info-row')];
  
  // Get current scroll position to find which row is at the center
  const scrollTop = modalInfo.scrollTop;
  const rowHeight = modalInfo.scrollHeight / rows.length;
  
  // Find the index of the row at the center of the viewport
  const centerScrollPos = scrollTop + (modalInfo.clientHeight / 2);
  const targetCenterIndex = Math.floor(centerScrollPos / rowHeight);
  
  // Track if we're changing to a different lot
  let changingLot = false;
  let newLotMapIndex = -1;
  
  // Update classes
  rows.forEach((row, index) => {
    row.classList.remove('active', 'center');
    
    if (index === targetCenterIndex) {
      row.classList.add('active', 'center');

      if (row.classList.contains('info-row--featured')) {
        const featureIndex = row.dataset.index;
        if (!animatedFeaturedLots.has(featureIndex)) {
          void row.offsetWidth;
          row.classList.add('animate-featured');
          animatedFeaturedLots.add(featureIndex);
        } else {
          row.classList.add('animate-featured');
        }
      }

      // === Map sync logic ===
      const baseIndex = parseInt(row.dataset.baseIndex, 10);
      if (!isNaN(baseIndex)) {
        const lot = baseLots[baseIndex];
        if (lot && window.map && lotData) {
          newLotMapIndex = lotData.findIndex(l => extractLotNumber(l.name) === lot.number);
          if (newLotMapIndex !== -1) {
            if (hoveredId !== null && hoveredId !== newLotMapIndex) {
              map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
              changingLot = true; // We're changing to a different lot
            }
            map.setFeatureState({ source: 'lots-final', id: newLotMapIndex }, { hover: true });
            hoveredId = newLotMapIndex;
             
            // Always remove labels when changing to a different lot, regardless of detail view
            if (changingLot && currentLabeledLot) {
              // Check if we're actually switching to a different lot, not just re-highlighting the same one
              const newLot = lotData[newLotMapIndex];
              if (newLot && currentLabeledLot.name !== newLot.name) {
                removeSideLengthLabels();
              }
            }
          }
        }
      }
      // === END Map sync ===
    }
  });
}
  



// ===== FIXED clampScroll FUNCTION =====
function clampScroll() {
  const modal = document.getElementById('lotModal');
  
  // DON'T clamp if we're in info mode
  if (modal.classList.contains('info-mode')) {
    return;
  }
  
  if (baseLots.length === 0 || lots.length === 0 || clampCooldown) return;

  const { scrollTop, scrollHeight, clientHeight } = modalInfo;
  const lotHeight = scrollHeight / lots.length;
  const bufferHeight = lotHeight * cloneCount;
  const baseHeight = lotHeight * baseLots.length;

  let virtualScroll = scrollTop;
  
  if (scrollTop < bufferHeight) {
    clampCooldown = true;
    virtualScroll = scrollTop + baseHeight;
  } 
  else if (scrollTop + clientHeight >= scrollHeight - bufferHeight) {
    clampCooldown = true;
    virtualScroll = scrollTop - baseHeight;
  }

  if (clampCooldown) {
    modalInfo.removeEventListener('scroll', handleScroll);
    modalInfo.scrollTop = virtualScroll;
    
    requestAnimationFrame(() => {
      highlightCenter(true);
      updateScrollbar();
      
      setTimeout(() => {
        modalInfo.addEventListener('scroll', handleScroll);
        clampCooldown = false;
      }, 50);
    });
  }
}

function stopDragging() {
  const modal = document.getElementById('lotModal');
  
  // Only apply infinite scroll snapping in LOT mode
  if (modal.classList.contains('info-mode')) {
    isDragging = false;
    isScrollbarDragging = false;
    customScrollthumb.classList.remove('active');
    modalInfo.classList.remove('dragging');
    return; // No snapping in info mode
  }
  
  if (!isDragging && !isScrollbarDragging) return;
  
  isDragging = false;
  isScrollbarDragging = false;
  customScrollthumb.classList.remove('active');
  modalInfo.classList.remove('dragging');

  const rows = [...modalInfo.querySelectorAll('.info-row')];
  const containerRect = modalInfo.getBoundingClientRect();
  const centerY = containerRect.top + containerRect.height / 2;

  let closestBaseIndex = 0;
  let closestDistance = Infinity;

  rows.forEach(row => {
    if(row.dataset.baseIndex === "-1") return;
    const rect = row.getBoundingClientRect();
    const rowCenter = (rect.top + rect.bottom) / 2;
    const dist = Math.abs(rowCenter - centerY);
    if (dist < closestDistance) {
      closestDistance = dist;
      closestBaseIndex = parseInt(row.dataset.baseIndex, 10);
    }
  });

  scrollToBaseIndex(closestBaseIndex, true);
}

customScrollthumb.addEventListener('pointerdown', (e) => {
  e.stopPropagation();
  isScrollbarDragging = true;
  dragStartY = e.clientY;
  dragStartScroll = modalInfo.scrollTop;
  customScrollthumb.classList.add('active');
  
  document.addEventListener('pointermove', handleScrollDrag);
  document.addEventListener('pointerup', stopScrollDrag);
  e.preventDefault();
});

function handleScrollDrag(e) {
  if (isScrollbarDragging) {
    const deltaY = e.clientY - dragStartY;
    const scrollRatio = deltaY / modalInfo.clientHeight;
    modalInfo.scrollTop = dragStartScroll + (scrollRatio * modalInfo.scrollHeight);
  }
  e.preventDefault();
}

function stopScrollDrag() {
  if (isScrollbarDragging) {
    isScrollbarDragging = false;
    customScrollthumb.classList.remove('active');
    document.removeEventListener('pointermove', handleScrollDrag);
    document.removeEventListener('pointerup', stopScrollDrag);
    stopDragging();
  }
}

modalInfo.addEventListener('pointerdown', (e) => {
  if (e.target.closest('.custom-scrollbar')) return;
  isDragging = true;
  dragStartY = e.clientY;
  dragStartScroll = modalInfo.scrollTop;
  modalInfo.classList.add('dragging');
  document.addEventListener('pointermove', handleContentDrag);
  document.addEventListener('pointerup', stopContentDrag);
  e.preventDefault();
});

function handleContentDrag(e) {

const modal = document.getElementById('lotModal');

  // Don't apply infinite scroll drag behavior in info mode
  if (modal.classList.contains('info-mode')) {
    return; // Let the browser handle natural scrolling
  }

  if (isDragging) {
    const deltaY = dragStartY - e.clientY;
    modalInfo.scrollTop = dragStartScroll + deltaY;

    const scrollTop = modalInfo.scrollTop;
    const scrollHeight = modalInfo.scrollHeight;
    const clientHeight = modalInfo.clientHeight;
    const lotHeight = scrollHeight / lots.length;
    const bufferHeight = lotHeight * cloneCount;
    const baseHeight = lotHeight * baseLots.length;

    if (scrollTop < bufferHeight) {
      modalInfo.scrollTop = scrollTop + baseHeight;
      dragStartScroll = modalInfo.scrollTop;
      dragStartY = e.clientY;
    } else if (scrollTop + clientHeight >= scrollHeight - bufferHeight) {
      modalInfo.scrollTop = scrollTop - baseHeight;
      dragStartScroll = modalInfo.scrollTop;
      dragStartY = e.clientY;
    }
  }
  e.preventDefault();
}

function stopContentDrag() {
  if (isDragging) {
    isDragging = false;
    modalInfo.classList.remove('dragging');
    document.removeEventListener('pointermove', handleContentDrag);
    document.removeEventListener('pointerup', stopContentDrag);
    stopDragging();
  }
}

// ===== FIXED handleScroll FUNCTION =====
function handleScroll() {
  const modal = document.getElementById('lotModal');
  
  // Always update the scrollbar visual position
  updateScrollbar();
  
  // Only run infinite scroll logic for LOT mode (not info mode)
  if (modal.classList.contains('lot-mode') && scrollHandlerAttached) {
    requestAnimationFrame(() => {
      highlightCenter();
      
      if (!isDragging && !isScrollbarDragging) {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          clampScroll();
        }, 100);
      }
    });
  }
}

modalInfo.addEventListener('scroll', handleScroll);

modalInfo.addEventListener('wheel', (e) => {
  const modal = document.getElementById('lotModal');
  // Allow natural scrolling in INFO mode
  if (modal.classList.contains('info-mode')) {
    return; // Let the browser handle scrolling naturally
  }

  // Only apply infinite scroll behavior in LOT mode
  e.preventDefault();
  if(isDragging || isScrollbarDragging) return;

  const rows = [...modalInfo.querySelectorAll('.info-row')];
  const containerRect = modalInfo.getBoundingClientRect();
  const centerY = containerRect.top + containerRect.height / 2;
  
  let closestRow = null;
  let minDistance = Infinity;
  
  rows.forEach(row => {
    const rect = row.getBoundingClientRect();
    const distance = Math.abs((rect.top + rect.bottom)/2 - centerY);
    if (distance < minDistance) {
      minDistance = distance;
      closestRow = row;
    }
  });

  if (!closestRow) return;
  
  const currentIndex = parseInt(closestRow.dataset.index);
  const direction = Math.sign(e.deltaY);
  let nextIndex = currentIndex + direction;

  if (nextIndex < 0) {
      nextIndex = lots.length - 1;
  } else if (nextIndex >= lots.length) {
      nextIndex = 0;
  }
  
  modalInfo.querySelector(`.info-row[data-index="${nextIndex}"]`)?.scrollIntoView({
    behavior: 'auto',
    block: 'center'
  });
});




function openModal(lot = null, baseIndex = 0) {
  const modal = document.getElementById('lotModal');
  const wasHidden = !modal.classList.contains('show');

  // üü¢ FIX: Reset ALL modal modes and content areas when opening fresh
  if (wasHidden || !lot) {
    // Reset modal classes
    modal.classList.remove('pin-mode', 'info-mode', 'lot-mode', 'expanded');
    
    // Reset content areas
    const lotDetails = document.getElementById('lotDetails');
    const modalInfo = document.getElementById('modalInfo');
    const calendly = document.getElementById('calendlyEmbed');
    const viewerContainer = document.getElementById('viewer-container');
    const customScrollbar = document.getElementById('customScrollbar');
    const loadingSpinner = document.getElementById('loadingSpinner');
    
    if (lotDetails) {
      lotDetails.classList.remove('active');
      lotDetails.style.display = 'block';
      lotDetails.innerHTML = '';
    }
    
    if (modalInfo) {
      modalInfo.style.display = '';
      modalInfo.style.opacity = '1';
      modalInfo.innerHTML = ''; // Clear any existing content
    }
    
    if (calendly) calendly.style.display = 'none';
    if (viewerContainer) viewerContainer.style.display = 'none';
    if (customScrollbar) customScrollbar.style.display = '';
    if (loadingSpinner) loadingSpinner.style.display = 'block';
    
    // Reset UI controls
    const backButton = document.getElementById('backButton');
    const plusButton = document.querySelector('.plus-button');
    const bottomPlusButton = document.querySelector('.bottom-plus-button');
    const headerLotNumber = document.getElementById('headerLotNumber');
    
    if (backButton) backButton.style.display = 'none';
    if (plusButton) plusButton.style.display = 'none';
    if (bottomPlusButton) bottomPlusButton.style.display = 'none';
    if (headerLotNumber) headerLotNumber.style.display = 'none';
    
    // Reset content wrapper
    const contentWrapper = document.querySelector('.modal-content-wrapper');
    if (contentWrapper) contentWrapper.classList.remove('show-details');
    
    // Reset internal states
    isDetailOpen = false;
    scrollHandlerAttached = true;
    
    // Reset auth controls
    document.getElementById('authControls')?.classList.remove('hide-in-detail');
  }

  // Check if we're just switching lots in an already-open modal
  const isJustSwitchingLots = wasHidden === false && lot && !infoMode && !modal.classList.contains('pin-mode');
  
  // If we're in PIN mode, block only when NOT switching to Info
  const isPinMode = modal.classList.contains('pin-mode');
  if (isPinMode && !infoMode) return;
  if (isPinMode && infoMode) {
    // we are explicitly switching from pin to info
    modal.classList.remove('pin-mode');
  }

  // üî• CONSOLIDATED: Apply fraccionamiento filter function
  function applyFraccFilter(shouldRender = true) {
    try {
      // Get fracc directly from the lot data - this should work if your Supabase data is correct
      const fracc = (lot && (lot.fraccionamiento || '').toString().trim()) || 'santte1';
      
      const modalEl = document.getElementById('lotModal');
      const currentFracc = modalEl?.dataset.fracc || '';
      
      // Only re-filter if the fraccionamiento has changed
      if (fracc !== currentFracc) {
        if (modalEl) modalEl.dataset.fracc = fracc;
        const headerFraccEl = document.getElementById('headerFracc');
        if (headerFraccEl) headerFraccEl.textContent = fracc ? fracc.toUpperCase() : 'SANTTE';
        if (Array.isArray(window.baseLotsAll) && window.baseLotsAll.length) {
          // Filter baseLots by fraccionamiento
          baseLots = window.baseLotsAll.filter(l => (l.fraccionamiento || '').toString().trim() === fracc);
          updateLotsArray();
          // Only re-render when requested
          if (shouldRender) {
            render();
          }
        }
      }
      if (window.resetUnitButtons) window.resetUnitButtons();
    } catch (e) {
      console.warn('Fraccionamiento filter failed:', e);
    }
  }

  // If just switching lots, handle it efficiently without resetting everything
  if (isJustSwitchingLots) {
    // ‚§µÔ∏è Apply filter FIRST when switching between different fraccionamientos
    // Use shouldRender: true to force re-render when switching communities
    applyFraccFilter(true);

    // Just scroll to the new lot after filtering
    const scrollToIndex = baseLots.findIndex(l => l.number === extractLotNumber(lot.name));
    if (scrollToIndex !== -1) {
      scrollToBaseIndex(scrollToIndex, true);
      
      // Update map highlight
      const mapIndex = lotData.findIndex(l => l.name === lot.name);
      if (mapIndex !== -1 && map) {
        if (hoveredId !== null) {
          map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
        }
        map.setFeatureState({ source: 'lots-final', id: mapIndex }, { hover: true });
        hoveredId = mapIndex;
        currentLotIndex = mapIndex;
      }
      
      // Add side length labels if zoom is high enough
      const currentZoom = map.getZoom();
      if (currentZoom >= 18.8) {
        removeSideLengthLabels();
        addSideLengthLabels(lot);
      }
    }
    return; // Exit early - no need to reset the modal
  }

  document.getElementById('communitySearchBtn')?.classList.add('hide');
  document.getElementById('lalalandInfoBtn')?.classList.add('hide');
  
  // Now show the modal
  modal.classList.add('show');
  modal.style.display = 'block';
  if (wasHidden) adjustMapForModal();

  // üî∏ INFO MODE short-circuit (your existing block)
  if (infoMode) {
    modal.classList.add('expanded', 'info-mode');
    
    const modalInfoEl = document.getElementById('modalInfo');
    const customScrollbarEl = document.getElementById('customScrollbar');
    const spinnerEl = document.getElementById('loadingSpinner');
    
    modalInfoEl.innerHTML = `
      <div style="padding:20px; color:#8a8880; height:2000px;">
        <h2 style="color:#a17345; margin-bottom:10px;">Sobre Santte 2</h2>
        <p>Bienvenido a Santte 2. Aqu√≠ puedes poner descripci√≥n, ubicaci√≥n, beneficios, etc.</p>
        <p>Para m√°s informaci√≥n cont√°ctanos por WhatsApp o visita nuestras oficinas.</p>
        <div style="height:1000px; background:linear-gradient(#f0f0f0, #e0e0e0);"></div>
      </div>
    `;
    customScrollbarEl.style.display = '';
    spinnerEl.style.display = 'none';
    scrollHandlerAttached = false;
    infoMode = false;

    document.getElementById('authControls').classList.remove('hide-in-detail');

    // ‚úÖ Use natural scrollbar for info page
    setTimeout(() => {
      enableInfoScrollbar();
      // Reset scroll position to top
      modalInfoEl.scrollTop = 0;
    }, 100);
    
    return;
  }

  // üëá Normal list flow
  modal.classList.add('lot-mode');
  modal.classList.remove('info-mode');

  const modalInfoEl = document.getElementById('modalInfo');
  const customScrollbarEl = document.getElementById('customScrollbar');
  const spinnerEl = document.getElementById('loadingSpinner');

  const doScrollAndHighlight = () => {
    const scrollToIndex = lot
      ? baseLots.findIndex(l => l.number === extractLotNumber(lot.name))
      : baseIndex;

    scrollToBaseIndex(scrollToIndex, false);

    setTimeout(() => {
      highlightCenter();
      updateScrollbar(); // This will call enableInfiniteScrollbar via handleScroll
      spinnerEl.style.display = 'none';
      modalInfoEl.style.opacity = '1';
    }, 0);
  };

  // Only fetch and render if needed
  if (!isDataLoaded) {
    fetchLots().then(() => {
      // üî• Apply filter when data is first loaded
      applyFraccFilter(false); // Don't render yet, we'll call render() below
      render();
      requestAnimationFrame(() => {
        requestAnimationFrame(doScrollAndHighlight);
      });
    });
  } else {
    // Only re-render if content was cleared (modal was hidden)
    if (wasHidden || !lot) {
      // üî• Apply filter when opening modal fresh or with new lot
      applyFraccFilter(false); // Don't render yet, we'll call render() below
      render();
      requestAnimationFrame(() => {
        requestAnimationFrame(doScrollAndHighlight);
      });
    } else {
      // Modal is already open with content - just scroll to the lot
      // üî• Apply filter but don't re-render (content is already there)
      applyFraccFilter(false);
      
      const scrollToIndex = baseLots.findIndex(l => l.number === extractLotNumber(lot.name));
      if (scrollToIndex !== -1) {
        scrollToBaseIndex(scrollToIndex, true);
        
        // Update map highlight
        const mapIndex = lotData.findIndex(l => l.name === lot.name);
        if (mapIndex !== -1 && map) {
          if (hoveredId !== null) {
            map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
          }
          map.setFeatureState({ source: 'lots-final', id: mapIndex }, { hover: true });
          hoveredId = mapIndex;
          currentLotIndex = mapIndex;
        }
        
        // Ensure UI is ready
        spinnerEl.style.display = 'none';
        modalInfoEl.style.opacity = '1';
        highlightCenter();
        updateScrollbar();
      }
    }
  }
}



function closeModal() {

document.getElementById('authControls').classList.remove('hide-in-detail');
  document.getElementById('communitySearchBtn')?.classList.remove('hide');
  document.getElementById('lalalandInfoBtn')?.classList.remove('hide');

  if (window.resetUnitButtons) window.resetUnitButtons();

  const modal = document.getElementById('lotModal');
  if (!modal) return;

  const wrapper = document.querySelector('.modal-content-wrapper');
  const modalInfo = document.getElementById('modalInfo');
  const customScrollbar = document.getElementById('customScrollbar');
  const lotDetails = document.getElementById('lotDetails');
  const backButton = document.getElementById('backButton');
  const headerLotNumber = document.getElementById('headerLotNumber');
  const plusIcon = document.querySelector('.plus-button .plus-icon');
  const minusIcon = document.querySelector('.plus-button .minus-icon');
  const plusBtn = document.querySelector('.plus-button');
  const bottomPlus = document.querySelector('.bottom-plus-button');

  

  // --- 1) Kill special modes / embeds
  modal.classList.remove('info-mode', 'pin-mode', 'expanded', 'lot-mode');
  hideCalendlyEmbed();                       // blanks iframe + hides container
  isDetailOpen = false;

  // --- 2) Clear lot side labels & map hover
  removeSideLengthLabels();
  if (typeof hoveredId !== 'undefined' && hoveredId !== null && map && map.getSource('lots-final')) {
    try { map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false }); } catch {}
    hoveredId = null;
  }

  // --- 3) Reset panes (detail vs list) & content
  if (wrapper) wrapper.classList.remove('show-details');
  if (lotDetails) {
    lotDetails.classList.remove('active');
    lotDetails.style.display = 'block';
    lotDetails.innerHTML = '';
  }
  if (modalInfo) {
    modalInfo.style.display = '';
    modalInfo.style.opacity = '1';
    // Optional: reset scroll position so list starts clean

  }
  if (customScrollbar) customScrollbar.style.display = '';

  // --- 4) Reset controls visibility & header
  if (backButton) backButton.style.display = 'none';
  if (headerLotNumber) headerLotNumber.style.display = 'none';
  if (plusBtn) plusBtn.style.display = 'none';
  if (bottomPlus) bottomPlus.style.display = 'none';
  if (plusIcon) plusIcon.style.display = 'block';
  if (minusIcon) minusIcon.style.display = 'none';

  // --- 5) Reset internal scroll/animation flags (if you use them)
  try { scrollHandlerAttached = true; } catch {}
  try { clampCooldown = false; } catch {}
  try { animatedFeaturedLots?.clear?.(); } catch {}

  // --- 6) Restore map view (undo panBy offset + preModalView fly)
  if (preModalView && map) {
    map.flyTo({
      center: preModalView.center,
      zoom: preModalView.zoom,
      bearing: preModalView.bearing,
      pitch: preModalView.pitch,
      speed: 1.2,
      curve: 1.5
    });

    // After fly, undo the modal offset pan
    map.once('moveend', () => {
      if (lastOffset) {
        map.panBy([-lastOffset[0], -lastOffset[1]], { duration: 800 });
        lastOffset = [0, 0];
      }
    });

    preModalView = null;
  } else if (map && lastOffset) {
    // Fallback: just undo the offset
    map.panBy([-lastOffset[0], -lastOffset[1]], { duration: 800 });
    lastOffset = [0, 0];
  }

  // --- 7) Close modal (let CSS transition run)
  modal.classList.remove('show');
  setTimeout(() => { modal.style.display = 'none'; }, 300);

    disableInfiniteScrollbar();
  disableInfoScrollbar();
}


function handlePlusButton() {
  const modal = document.getElementById('lotModal');
  const plusIcon = document.querySelector('.plus-button .plus-icon');
  const minusIcon = document.querySelector('.plus-button .minus-icon');
  
  // Toggle expanded state
  modal.classList.toggle('expanded');
  
  // Toggle between plus and minus icon
  if (modal.classList.contains('expanded')) {
    plusIcon.style.display = 'none';
    minusIcon.style.display = 'block';
  } else {
    plusIcon.style.display = 'block';
    minusIcon.style.display = 'none';
  }
 }

function loadCalendlyWidget({ lot, detailData }) {
  const container = document.getElementById('calendlyEmbed');
  const iframe = document.getElementById('calendly-iframe');
  
  // Build the Calendly URL with all hiding parameters
  const calendlyUrl = new URL('https://calendly.com/lalaland_/santte2');
  calendlyUrl.searchParams.set('hide_gdpr_banner', '1');
  calendlyUrl.searchParams.set('background_color', 'fcfaf3');
  calendlyUrl.searchParams.set('text_color', '1a1a1a');
  calendlyUrl.searchParams.set('primary_color', 'ff8400');
  
  // Load the iframe
  iframe.src = calendlyUrl.toString();
  container.style.display = 'block';
  
}





</script>
 
 
<script>
// RESET GPS + INFO (reusing #lotModal)
document.addEventListener('DOMContentLoaded', () => {
  const modal    = document.getElementById('lotModal');
  const resetBtn = document.getElementById('resetViewBtn');
  const lalalandBtn = document.getElementById('lalalandInfoBtn');
  const infoBtn  = document.getElementById('infoBtn'); // left orange button
  const gpsBtn   = document.getElementById('gpsButton'); 

// Open lot modal in "info mode" - attach to Lalaland button
document.getElementById('lalalandInfoBtn')?.addEventListener('click', () => {
  infoMode = true;
  document.getElementById('lotModal')?.classList.remove('pin-mode');
  openModal();

  const modal = document.getElementById('lotModal');
  modal.classList.add('info-mode');
  modal.classList.remove('lot-mode');
  modal.classList.add('expanded');

  const modalInfo = document.getElementById('modalInfo');
  const customScrollbar = document.getElementById('customScrollbar');
  document.getElementById('headerFracc').textContent = 'LALALAND';

  modalInfo.innerHTML = `
  
<div class="faq-section">

  <h3><span class="emoji">üí®</span> ¬øQu√© tan r√°pido puedo vender con Lalaland?</h3>

 <ul>
  <li><span class="emoji">üöÄ</span> Vende <strong>hasta 30‚Äì50% m√°s r√°pido</strong> al reemplazar PDFs por experiencias interactivas.<sup>1</sup></li>
  <li><span class="emoji">üè°</span> Los desarrollos con <strong>recorridos 360¬∞</strong> y <strong>disponibilidad en tiempo real</strong> generan <strong>2√ó m√°s inter√©s</strong> de compradores.<sup>2</sup></li>
  <li><span class="emoji">üí¨</span> El <strong>77% de los compradores</strong> afirma que un tour virtual los ayud√≥ a decidirse a visitar ‚Äî decisiones m√°s r√°pidas, menos visitas desperdiciadas.<sup>3</sup></li>
  <li><span class="emoji">üìà</span> Los proyectos que usan <strong>herramientas digitales</strong> reportan <strong>cierres 4‚Äì9% m√°s altos</strong> en precio.<sup>4</sup></li>
  <li><span class="emoji">‚è±Ô∏è</span> Los asesores ahorran <strong>40‚Äì60% de tiempo</strong> por cliente, ya que los compradores se informan por s√≠ mismos.<sup>5</sup></li>
  <li><span class="emoji">‚ùå</span> Adi√≥s a los <strong>PDFs anticuados</strong> ‚Äî la disponibilidad se actualiza <strong>en tiempo real</strong>, manteniendo alineadas las ventas con los clientes.</li>
</ul>


  <div class="faq-sources" style="font-size: 0.85em; color: #777; margin-top: 10px;">
    <p><strong>Fuentes:</strong></p>
    <ol>
      <li>REACH PropTech Report (2022): ‚ÄúDigital Sales Tools Reduce Time on Market by 30‚Äì50%.‚Äù</li>
      <li>Zillow & NAR Research (2023): ‚ÄúVirtual Tours Double Buyer Engagement.‚Äù</li>
      <li>National Association of Realtors (2024): ‚Äú77% of Buyers Say Virtual Tours Influence Visit Decisions.‚Äù</li>
      <li>Matterport + Redfin Study (2023): ‚Äú3D Listings Sell 31% Faster and for 4‚Äì9% Higher Prices.‚Äù</li>
      <li>HubSpot / DemandGen Report (2023): ‚ÄúInteractive Content Yields 65% Higher Lead-to-Sale Conversion.‚Äù</li>
    </ol>
  </div>


<div class="cta-section">
  <a href="https://arquidromo.com/colmena" class="cta-link" target="_blank">
    <span class="emoji">üêù</span> Ver proyecto ‚Üí <strong>Colmena</strong><br>
  </a>
</div>

<div class="cta-section">
  <a href="https://arquidromo.com/vivecolmena" class="cta-link" target="_blank">
    <span class="emoji">üåø</span> Explorar ‚Üí <strong>Vive Colmena</strong><br>
  </a>
</div>

</div>


  `;
  customScrollbar.style.display = '';
  enableInfoScrollbar();
});




 
  // Hide/show floating buttons while modal is expanded (mobile)
const observer = new MutationObserver(() => {
  // Add Pin button may be created later by PS.addAddPinButton()
  const addPinBtn = document.getElementById('addPinBtn');

  const hideAll = () => {
communitySearchBtn?.classList.add('hide');
    lalalandBtn?.classList.add('hide');


    // If user was in "add pin" mode, turn it off so no crosshair while hidden
    if (window.__LL_PINS__?.addMode) {
      try { window.__LL_PINS__.toggleAddMode(); } catch {}
    }
  };

  const showAll = () => {
    communitySearchBtn?.classList.remove('hide');
    lalalandBtn?.classList.remove('hide');

  };
 
  if (window.innerWidth < 768) {
    if (modal.classList.contains('expanded')) {
      hideAll();
    } else {
      showAll();
    }
  } else {
    // Desktop: keep them visible
    showAll();
  }
});

  observer.observe(modal, { attributes: true, attributeFilter: ['class'] });

  // Reset map view (existing behavior)
  const initialZoom = getCurrentFraccZoom();
  resetBtn.addEventListener('click', () => {
    if (!window.map) return;
    map.flyTo({
      center: [-100.15994, 25.461823],
      zoom: initialZoom,
      bearing: 0,
      pitch: 0,
      speed: 1.2,
      curve: 1.5
    });
  });
});


function hideCalendlyEmbed() {
  // Hide the embedded Calendly pane
  const wrap = document.getElementById('calendlyEmbed');
  if (wrap) wrap.style.display = 'none';

  // Blank the iframe so it fully resets next time
  const iframe = document.getElementById('calendly-iframe');
  if (iframe) iframe.src = 'about:blank';

  // Close Calendly popup widget if it's open
  if (window.Calendly && typeof window.Calendly.closePopupWidget === 'function') {
    try { window.Calendly.closePopupWidget(); } catch {}
  }
}

</script>




<script>
(() => {
  'use strict';

  const PS = (window.__LL_PINS__ = window.__LL_PINS__ || {});
  PS.markers = new Map();      // id -> { pin, marker }
  PS.addMode = false;
  PS._mapClickHandler = null;
  PS._isVisible = false;       // markers start hidden (button is now always visible)

  // === Cone visibility & size ===
  PS._conesVisible = false; 
  PS._coneFillOpacity = 0.30;  // final fill opacity when visible
  PS._coneLineOpacity = 0;     // final line opacity when visible
  PS.coneRadiusMeters = 30;    // cone length (meters)
  PS.coneFovDegrees   = 60;    // cone width (degrees)

  // GeoJSON store for all cone triangles
  PS._coneFC = { type: 'FeatureCollection', features: [] };

  // Track pins awaiting cone appearance order
  PS._pinsAwaitingCone = new Set();  // ids that will get cone after dot is visible

  const toast = (m, t=2500) => { try{ window.showToaster?.(m, t);}catch{} };
  const debounce = (fn, wait=400) => { let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); }; };

  async function compressImageToJPEG(fileOrBlob, maxSize = 1000) {
    const dataURL = await new Promise((res) => {
      const fr = new FileReader();
      fr.onload = () => res(fr.result);
      fr.readAsDataURL(fileOrBlob);
    });
    const img = await new Promise((res) => {
      const i = new Image();
      i.onload = () => res(i);
      i.src = dataURL;
    });
    let { width, height } = img;
    if (width > height && width > maxSize) {
      height = Math.round(height * (maxSize / width));
      width = maxSize;
    } else if (height > width && height > maxSize) {
      width = Math.round(width * (maxSize / height));
      height = maxSize;
    }
    const canvas = document.createElement('canvas');
    canvas.width = width; canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, width, height);
    return await new Promise((res) => canvas.toBlob(b => res(b), 'image/jpeg', 0.85));
  }

  // ======== GEO UTILS: destination point (lng,lat + meters + bearing¬∞) ========
  function destination(lng, lat, distMeters, bearingDeg) {
    const R = 6371000; // meters
    const Œ¥ = distMeters / R;
    const Œ∏ = (bearingDeg * Math.PI) / 180;
    const œÜ1 = (lat * Math.PI) / 180;
    const Œª1 = (lng * Math.PI) / 180;

    const sinœÜ1 = Math.sin(œÜ1), cosœÜ1 = Math.cos(œÜ1);
    const sinŒ¥ = Math.sin(Œ¥),   cosŒ¥ = Math.cos(Œ¥);
    const sinœÜ2 = sinœÜ1 * cosŒ¥ + cosœÜ1 * sinŒ¥ * Math.cos(Œ∏);
    const œÜ2 = Math.asin(sinœÜ2);
    const y = Math.sin(Œ∏) * sinŒ¥ * cosœÜ1;
    const x = cosŒ¥ - sinœÜ1 * sinœÜ2;
    const Œª2 = Œª1 + Math.atan2(y, x);

    return [ ((Œª2 * 180) / Math.PI + 540) % 360 - 180, (œÜ2 * 180) / Math.PI ];
  }

  // Build a triangular cone polygon for a pin
  function _buildConeFeature(pin) {
    const heading = ((pin.heading ?? 0) % 360 + 360) % 360;
    const half = PS.coneFovDegrees / 2;
    const leftBrg  = heading - half;
    const rightBrg = heading + half;

    const pLeft  = destination(pin.lng, pin.lat, PS.coneRadiusMeters, leftBrg);
    const pRight = destination(pin.lng, pin.lat, PS.coneRadiusMeters, rightBrg);

    return {
      type: 'Feature',
      properties: { role: 'cone', pin_id: pin.id, heading },
      geometry: {
        type: 'Polygon',
        coordinates: [[
          [pin.lng, pin.lat],
          pLeft,
          pRight,
          [pin.lng, pin.lat]
        ]]
      }
    };
  }

  function _ensureConeLayer() {
  if (!window.map) return;
  if (!map.getSource('ps-cones')) {
    map.addSource('ps-cones', { type: 'geojson', data: PS._coneFC });
  }
  if (!map.getLayer('ps-cones-fill')) {
    map.addLayer({
      id: 'ps-cones-fill',
      type: 'fill',
      source: 'ps-cones',
      paint: {
        'fill-color': '#ff8400',
        'fill-opacity': 0 // start hidden
      },
      filter: ['==', ['get', 'role'], 'cone']
    });
  } 
  if (!map.getLayer('ps-cones-outline')) {
    map.addLayer({
      id: 'ps-cones-outline',
      type: 'line',
      source: 'ps-cones',
      paint: {
        'line-color': '#ff8400',
        'line-width': 0, 
        'line-opacity': 0 // start hidden
      },
      filter: ['==', ['get', 'role'], 'cone']
    });
  }
  
  // Add click handler for cone layer (only once)
  if (!map._coneClickHandlerAdded) {
    map.on('click', 'ps-cones-fill', (e) => {
      if (e.features.length > 0) {
        const pinId = e.features[0].properties.pin_id;
        const pinRec = PS.markers.get(pinId);
        if (pinRec) {
          // Prevent the event from bubbling to the map's click handler
          e.preventDefault();
          e.originalEvent.stopPropagation();
          e.originalEvent.stopImmediatePropagation();
          
          PS.openPinInModal(pinRec.pin);
        }
      }
    });
    
    map._coneClickHandlerAdded = true;
  }
  
  try {
    map.setPaintProperty('ps-cones-fill', 'fill-opacity-transition', { duration: 250 });
    map.setPaintProperty('ps-cones-outline', 'line-opacity-transition', { duration: 250 });
  } catch {}
}

  function _syncConesSource() {
    const src = map?.getSource('ps-cones');
    if (src) src.setData(PS._coneFC);
  }

  function _addConeFeatureNow(pin) {
    // upsert feature and sync source
    const idx = PS._coneFC.features.findIndex(f => f.properties?.pin_id === pin.id);
    const feat = _buildConeFeature(pin);
    if (idx >= 0) PS._coneFC.features[idx] = feat;
    else PS._coneFC.features.push(feat);
    _syncConesSource();
  }

  function _removeConeForPinId(pinId) {
    const before = PS._coneFC.features.length;
    PS._coneFC.features = PS._coneFC.features.filter(f => f.properties?.pin_id !== pinId);
    if (PS._coneFC.features.length !== before) _syncConesSource();
  }

function _ensureConesShown() {
  if (!window.map) return;
  // Ensure sources/layers exist before setting paint
  _ensureConeLayer(); // <‚Äî safe no-op if already present

  if (!PS._conesVisible) {
    const fill = PS._coneFillOpacity, line = PS._coneLineOpacity;
    map.setPaintProperty('ps-cones-fill', 'fill-opacity', fill);
    map.setPaintProperty('ps-cones-outline', 'line-opacity', line);
    PS._conesVisible = true;
  }
}

  // ---- Add Pin button (ALWAYS visible now)
  PS.addAddPinButton = function () {
    if (document.getElementById('addPinBtn')) return;
    const btn = document.createElement('button');
    btn.id = 'addPinBtn';
    btn.className = 'gps-button';
    btn.title = 'Add point';
    btn.style.bottom = '260px';
    btn.innerHTML = `
      <svg viewBox="0 0 24 24" width="24" height="24" stroke="#333" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <line x1="5" y1="12" x2="19" y2="12"></line>
      </svg>`;
    btn.addEventListener('click', () => PS.toggleAddMode());
    document.body.appendChild(btn);
  };

  // ---- Toggle add mode (no gating on _isVisible)
  PS.toggleAddMode = function () {
    if (!window.map) { toast('Map is still loading‚Ä¶'); return; }
    PS.addMode = !PS.addMode;
    const btn = document.getElementById('addPinBtn');
btn.style.backgroundColor = PS.addMode ? '#ff8400' : '#fcfaf3';
    map.getCanvas().style.cursor = PS.addMode ? 'crosshair' : '';
    if (PS.addMode && !PS._mapClickHandler) {
      PS._mapClickHandler = (e) => {
        const t = e.originalEvent?.target;
        if (t && (t.closest('#lotModal') || t.closest('.mapboxgl-ctrl') || t.closest('button') || t.closest('a'))) return;
        PS.createPinAt(e.lngLat).finally(() => {
          PS.addMode = false;
          PS.toggleAddMode(); 
        });
      };
      map.on('click', PS._mapClickHandler);
      toast('Click the map to drop a pin');
    } else if (!PS.addMode && PS._mapClickHandler) {
      map.off('click', PS._mapClickHandler);
      PS._mapClickHandler = null;
    }
  };

  // ---- DB create
  PS.createPinAt = async function (lngLat) {
    await window.supabaseReady;
    const { data, error } = await window.supabaseClient
      .from('pins').insert({ lng: lngLat.lng, lat: lngLat.lat, heading: 0 }).select().single();
    if (error) { console.error(error); toast('Could not create pin'); return; }
    PS.addMarker(data);
    toast('Pin added');
  };

  // ---- Delete pin (DB + local cleanup + cone)
  PS.deletePin = async function (pinId) {
    try {
      await window.supabaseReady;
      const { error } = await window.supabaseClient
        .from('pins').delete().eq('id', pinId);
      if (error) { console.error(error); toast('Failed to delete pin'); return false; }

      // Optimistic local cleanup (RT delete will also do this)
      const rec = PS.markers.get(pinId);
      if (rec) { rec.marker.remove(); PS.markers.delete(pinId); }
      _removeConeForPinId(pinId);

      toast('Pin deleted');
      return true;
    } catch (e) {
      console.error(e);
      toast('Delete failed');
      return false;
    }
  };

  // ---- HTML marker (12px dot)
  PS.markerElement = function () {
    const el = document.createElement('div');
    el.style.width = '10px';
    el.style.height = '10px';
    el.style.borderRadius = '50%';
    el.style.background = 'transparent';
    el.style.border = 'none';
    el.style.boxShadow = 'none';
    el.style.cursor = 'pointer';
    el.style.border = '2px solid #ff8400'; // Orange outline
    return el;
  };

  // ---- Add marker + schedule cone strictly AFTER dot is visible
  PS.addMarker = function (pin) {
    const updating = PS.markers.has(pin.id);
    if (updating) {
      PS.markers.get(pin.id).marker.setLngLat([pin.lng, pin.lat]);
      PS.markers.get(pin.id).pin = pin;
      return;
    }

    const el = PS.markerElement();
    const marker = new mapboxgl.Marker({ element: el, draggable: true })
      .setLngLat([pin.lng, pin.lat]);

    PS.markers.set(pin.id, { pin, marker });

    // Add marker to map immediately if pins are already visible
    if (PS._isVisible && window.map) {
      marker.addTo(map);
      // schedule cone AFTER this dot paints (2 RAFs)
      requestAnimationFrame(() => requestAnimationFrame(() => {
        _addConeFeatureNow(pin);
        _ensureConesShown();
      }));
    } else {
      // Initial load path: marker is not yet on map; _revealMarkers will add + fade-in.
      PS._pinsAwaitingCone.add(pin.id);
    }

    marker.on('dragend', async () => {
      const ll = marker.getLngLat();
      const { error } = await window.supabaseClient
        .from('pins').update({ lng: ll.lng, lat: ll.lat }).eq('id', pin.id);
      if (error) toast('Failed to save position'); else toast('Position saved');
      const rec = PS.markers.get(pin.id);
      if (rec) {
        rec.pin.lng = ll.lng; rec.pin.lat = ll.lat;
        _addConeFeatureNow(rec.pin); // move cone with pin
      }
    });

    el.addEventListener('click', (ev) => {
      ev.stopPropagation();
      PS.openPinInModal(pin);
    });



    
  };

  // programmatic setter (update heading + persist + refresh cone)
  PS.setPinHeading = async function (pinId, newHeading, { persist = true } = {}) {
    const rec = PS.markers.get(pinId);
    if (!rec) return;
    const h = (Math.round(newHeading) % 360 + 360) % 360;
    rec.pin.heading = h;
    _addConeFeatureNow(rec.pin); // redraw cone polygon
    if (persist) {
      await window.supabaseReady;
      const { error } = await window.supabaseClient
        .from('pins').update({ heading: h }).eq('id', pinId);
      if (error) console.warn('Failed to save heading', error);
    }
  };

  // ---- Reveal markers (fade-in) and then reveal cones per-pin on transition end
  PS._revealMarkers = function () {
    if (PS._isVisible) return;
    PS._isVisible = true;

    // Count how many awaiting pins we will handle
    const awaitingIds = new Set(PS._pinsAwaitingCone);
    let revealedCount = 0;
    const totalToReveal = awaitingIds.size;

    PS.markers.forEach(({ marker, pin }) => {
      const el = marker.getElement();
      if (!el.parentNode) marker.addTo(map); // put it on the map
      el.style.display = 'block';
      el.style.opacity = '0';
      el.style.transition = 'opacity 600ms ease';

      // After fade finishes for this dot, add its cone, then maybe show layer
      const onDone = () => {
        el.removeEventListener('transitionend', onDone);
        if (awaitingIds.has(pin.id)) {
          _addConeFeatureNow(pin);
          awaitingIds.delete(pin.id);
        }
        revealedCount++;
        if (revealedCount === totalToReveal) {
          _ensureConesShown(); // only after all initially pending dots are visible
          PS._pinsAwaitingCone.clear();
        }
      };

      el.addEventListener('transitionend', onDone, { once: true });

      // Safety: if transitionend never fires (browser quirk), force after 1s
      setTimeout(() => {
        if (awaitingIds.has(pin.id)) onDone();
      }, 1000);

      // start fade-in
      requestAnimationFrame(() => { el.style.opacity = '1'; });
    });
  };

  // ---- Open in your lot modal (with heading controls + DELETE button)
  // ---- Open in modal (full-width photo, no thumbnails)
// ---- Open in modal (full-width photo, controls overlayed above photo)
PS.openPinInModal = async function (pin) {
  await window.supabaseReady;
  
  // Check if user is authenticated
  const { data: { session } } = await window.supabaseClient.auth.getSession();
  const isAuthenticated = !!(session && session.user);
  
  document.getElementById('lotModal').classList.add('pin-mode');

  const modal = document.getElementById('lotModal');
  const wrapper = document.querySelector('.modal-content-wrapper');
  const lotDetails = document.getElementById('lotDetails');
  const backButton = document.getElementById('backButton');

  if (!modal.classList.contains('show')) {
    try {
      if (window.map) {
        window.preModalView = {
          center: map.getCenter().toArray(),
          zoom: map.getZoom(),
          bearing: map.getBearing(),
          pitch: map.getPitch()
        };
      }
      modal.classList.add('show');
      modal.style.display = 'block';
      if (typeof window.adjustMapForModal === 'function') adjustMapForModal();
    } catch (e) {
      console.warn('Could not open modal:', e);
    }
  }

  modal.classList.add('pin-mode');
  modal.classList.remove('lot-mode');
  if (backButton) backButton.style.display = 'none';
  document.querySelector('.plus-button')?.style && (document.querySelector('.plus-button').style.display = 'none');
  document.querySelector('.bottom-plus-button')?.style && (document.querySelector('.bottom-plus-button').style.display = 'none');

  // Optional: make the content truly edge-to-edge
  lotDetails.style.padding = '0';
  wrapper.style.padding = '0';

  lotDetails.innerHTML = '';
  wrapper.classList.add('show-details');
  lotDetails.classList.add('active');
  try { window.isDetailOpen = true; } catch {}

  // fetch photos (latest shown)
  const { data: photos } = await window.supabaseClient
    .from('pin_photos')
    .select('id,url,created_at')
    .eq('pin_id', pin.id)
    .order('created_at', { ascending: true });

  const latest = (photos && photos.length) ? photos[photos.length - 1] : null;
  const currentHeading = (typeof pin.heading === 'number') ? pin.heading : 0;

  // Build UI: Only show photo when not authenticated, show controls when authenticated
  const container = document.createElement('div');
  container.style.padding = '0';
  
  // Only show controls if authenticated
  const authControlsHtml = isAuthenticated ? `
    <!-- Heading control (on top of photo) -->
    <div style="display:flex; align-items:center; gap:10px; color:#fff;">
      <div style="font-size:12px; opacity:.85; min-width:70px;">Heading</div>
      <input id="ps-heading-${pin.id}" type="range" min="0" max="359" step="1"
             value="${currentHeading}" style="flex:1;">
      <input id="ps-heading-num-${pin.id}" type="number" min="0" max="359" step="1"
             value="${currentHeading}"
             style="width:64px; padding:4px 6px; border:1px solid #ddd; border-radius:6px; background:#fff; color:#111;">
    </div>

    <!-- Actions (Upload / Delete) -->
    <div style="display:flex; gap:10px; align-items:center;">
      <label style="display:inline-block; background:#ff8400; color:#fff; padding:8px 12px; border-radius:6px; cursor:pointer; font-weight:600;">
        Upload photo
        <input type="file" accept="image/*" capture="environment" style="display:none" id="ps-upload-${pin.id}">
      </label>
      <button id="ps-delete-${pin.id}" type="button"
        style="background:#f44336;color:#fff;padding:8px 12px;border:none;border-radius:6px;cursor:pointer;font-weight:700;">
        Delete pin
      </button>
    </div>
  ` : '';

  container.innerHTML = `
    <div id="ps-photo-wrap-${pin.id}" style="
      position:relative;
      width:100%;
      margin:0;
      border-radius:0 !important;
      overflow:hidden;
      background:none;">
      ${
        latest
          ? `<img id="ps-photo-${pin.id}" src="${latest.url}" alt=""
                 style="display:block;width:100%;height:auto;border-radius:0;cursor:pointer;">`
          : isAuthenticated 
            ? `<div id="ps-photo-empty-${pin.id}" style="padding:48px 0;text-align:center;color:#8a8880;">No photo yet.</div>`
            : `<div id="ps-photo-empty-${pin.id}" style="padding:48px 0;text-align:center;color:#8a8880;">No photo available.</div>`
      }

      <!-- Only show overlay with controls if authenticated -->
      ${isAuthenticated ? `
      <div class="ps-overlay" style="
        position:absolute;
        left:0; right:0; top:0;
        z-index:2;                 
        padding:12px;
        pointer-events:none;       
        background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.35) 40%, rgba(0,0,0,.45) 100%);
      ">
        <div class="ps-overlay-card" style="
          display:flex; flex-direction:column; gap:10px;
          pointer-events:auto;     
          background: rgba(0,0,0,0.40);
          backdrop-filter: blur(4px);
          -webkit-backdrop-filter: blur(4px);
          border-radius:10px;
          padding:10px;
        ">
          ${authControlsHtml}
        </div>
      </div>
      ` : ''}
    </div>
  `;
  lotDetails.appendChild(container);




  // photo click => fullscreen viewer (available for all users)
  const imgEl = container.querySelector(`#ps-photo-${pin.id}`);
  imgEl?.addEventListener('click', () => PS.showViewer(imgEl.src));

  // Only set up event handlers if authenticated
  if (isAuthenticated) {
    // delete pin
    const delBtn = container.querySelector(`#ps-delete-${pin.id}`);
    delBtn.addEventListener('click', async () => {
      if (!confirm('Delete this pin?')) return;
      const ok = await PS.deletePin(pin.id);
      if (ok) { try { modal.classList.remove('show'); modal.style.display = 'none'; } catch {} }
    });

    // heading controls
    const range = container.querySelector(`#ps-heading-${pin.id}`);
    const num   = container.querySelector(`#ps-heading-num-${pin.id}`);
    const syncPair = (v) => { range.value = v; num.value = v; };
    const updateLive = (v) => PS.setPinHeading(pin.id, Number(v), { persist:false });
    const saveDebounced = ((fn)=>{ let t; return (v)=>{ clearTimeout(t); t=setTimeout(()=>fn(v),300); }; })
      (async (v) => {
        await PS.setPinHeading(pin.id, Number(v), { persist:true });
        const rec = PS.markers.get(pin.id); if (rec) rec.pin.heading = Number(v);
      });

    range.addEventListener('input',  (e) => { syncPair(e.target.value); updateLive(e.target.value); });
    range.addEventListener('change', (e) => saveDebounced(e.target.value));
    num.addEventListener('input',    (e) => {
      const v = Math.max(0, Math.min(359, Number(e.target.value || 0)));
      syncPair(v); updateLive(v);
    });
    num.addEventListener('change',   (e) => {
      const v = Math.max(0, Math.min(359, Number(e.target.value || 0)));
      syncPair(v); saveDebounced(v);
    });

    // upload: replace full-width image (no thumbnails)
    const input = container.querySelector(`#ps-upload-${pin.id}`);
    input.addEventListener('change', async (e) => {
      if (!e.target.files || !e.target.files[0]) return;
      try {
        const blob = await compressImageToJPEG(e.target.files[0], 1200);
        const path = `${pin.id}/${Date.now()}.jpg`;

        const up = await window.supabaseClient.storage.from('pin-photos')
          .upload(path, blob, { contentType: 'image/jpeg', upsert: false });
        if (up.error) throw up.error;

        const pub = window.supabaseClient.storage.from('pin-photos').getPublicUrl(path);
        const url = pub?.data?.publicUrl;
        if (!url) throw new Error('No public URL');

        const { error: insErr } = await window.supabaseClient
          .from('pin_photos').insert({ pin_id: pin.id, url });
        if (insErr) throw insErr;

        const wrap = container.querySelector(`#ps-photo-wrap-${pin.id}`);
        let img = container.querySelector(`#ps-photo-${pin.id}`);
        if (!img) {
          wrap.insertAdjacentHTML('afterbegin',
            `<img id="ps-photo-${pin.id}" src="${url}" alt="" style="display:block;width:100%;height:auto;border-radius:0;cursor:pointer;">`);
          img = container.querySelector(`#ps-photo-${pin.id}`);
          img.addEventListener('click', () => PS.showViewer(img.src));
          document.getElementById(`ps-photo-empty-${pin.id}`)?.remove();
        } else {
          img.src = url;
        }

        try { window.showToaster?.('Photo uploaded'); } catch {}
      } catch (err) {
        console.error(err);
        try { window.showToaster?.('Upload failed'); } catch {}
      } finally {
        e.target.value = '';
      }
    });
  }
};




  // ---- Simple full-screen viewer
  PS.ensureViewer = function () {
    if (document.getElementById('pinViewer')) return;
    document.body.insertAdjacentHTML('beforeend', `
      <div id="pinViewer" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.92);z-index:10000;">
        <img id="pinViewerImg" style="max-width:90%;max-height:90%;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);" />
        <button id="pinViewerClose" style="position:absolute;top:20px;right:20px;background:#f44336;color:#fff;border:none;border-radius:50%;width:40px;height:40px;font-size:20px;cursor:pointer;">√ó</button>
      </div>`);
    document.getElementById('pinViewerClose').addEventListener('click', () => {
      document.getElementById('pinViewer').style.display = 'none';
    });
  };
  PS.showViewer = function (url) {
    PS.ensureViewer();
    document.getElementById('pinViewerImg').src = url;
    document.getElementById('pinViewer').style.display = 'block';
  };

  // ---- Load + realtime
  PS.loadPins = async function () {
    await window.supabaseReady;
    const { data, error } = await window.supabaseClient
      .from('pins').select('id,lng,lat,heading').order('created_at', { ascending: true });
    if (error) return;

    _ensureConeLayer();

    (data || []).forEach(p => {
      PS.addMarker(p); // cones deferred until dot visible
    });
  };

  PS.subscribe = function () {
    window.supabaseClient
      .channel('pins-rt')
      .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'pins' }, (payload) => {
        PS.addMarker(payload.new); // for live inserts, cone is delayed 2 RAFs inside addMarker
      })
      .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'pins' }, (payload) => {
        const rec = PS.markers.get(payload.new.id);
        if (!rec) return;
        const { lng, lat, heading } = payload.new;
        if (typeof lng === 'number' && typeof lat === 'number') {
          rec.marker.setLngLat([lng, lat]);
          rec.pin.lng = lng; rec.pin.lat = lat;
        }
        if (typeof heading === 'number') {
          rec.pin.heading = ((heading % 360) + 360) % 360;
        }
        _addConeFeatureNow(rec.pin); // move/rotate cone with updates
      })
      .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'pins' }, (payload) => {
        const rec = PS.markers.get(payload.old.id);
        if (rec) { rec.marker.remove(); PS.markers.delete(payload.old.id); }
        _removeConeForPinId(payload.old.id);
      })
      .subscribe();
  };

  // ---- Boot
  const boot = async () => {
    await window.supabaseReady;
    if (!window.map) {
      const i = setInterval(() => {
        if (window.map) { clearInterval(i); PS.addAddPinButton(); PS.loadPins(); PS.subscribe(); }
      }, 200);
    } else {
      PS.addAddPinButton();
      PS.loadPins();
      PS.subscribe();
    }
map.once('idle', () => { _ensureConeLayer(); /* wait for animations */ });
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot);
  } else {
    boot();
  }
})(); 
</script>

 

<script>
// CYCLE AVAILABILITY ‚Äî standalone + persistent selection
(() => {
  const btn = document.getElementById('cycleAvailabilityBtn');
  if (!btn) return;

  const ORDER = ['Available', 'Sold', 'Featured'];
  let selectedLotName = null; // persists selection inside this block

  const $modalInfo = document.getElementById('modalInfo');
  const $lotModal  = document.getElementById('lotModal');

  // --- utils ---
  const normalize = v => (v || '').toString().trim().toLowerCase();
const nextState = cur => {
  const i = ORDER.findIndex(v => v.toLowerCase() === normalize(cur));
  return ORDER[(i + 1) % ORDER.length];
};
 
  // Which lot is currently "selected" (detail view or centered row)
  function getSelectedLot() {
    // detail view path
    if (window.isDetailOpen && typeof window.currentLotIndex === 'number' && window.currentLotIndex >= 0) {
      const mapLot = lotData[window.currentLotIndex];
      if (!mapLot) return null;
      const n = extractLotNumber(mapLot.name);
      const baseIdx = baseLots.findIndex(b => b.number === n);
      return { lotName: mapLot.name, number: n, baseIndex: baseIdx };
    }
    // list-centered path
    const centered = document.querySelector('.info-row.center');
    if (!centered) return null;
    const baseIndex = parseInt(centered.dataset.baseIndex, 10);
    if (isNaN(baseIndex) || baseIndex < 0) return null;
    const base = baseLots[baseIndex];
    if (!base) return null;
    const mapIdx = lotData.findIndex(l => extractLotNumber(l.name) === base.number);
    if (mapIdx === -1) return null;
    return { lotName: lotData[mapIdx].name, number: base.number, baseIndex };
  } 

  // Visual re-apply: map hover + list active row + button color
  function setSelectedLotByName(lotName, { scroll = false } = {}) {
    if (!lotName) return;
    selectedLotName = lotName;

    // Map hover
    const mapIndex = lotData.findIndex(l => l.name === lotName);
    if (mapIndex !== -1 && map?.getSource('lots-final')) {
      if (window.hoveredId !== null && window.hoveredId !== mapIndex) {
        try { map.setFeatureState({ source:'lots-final', id: window.hoveredId }, { hover:false }); } catch {}
      }
      try { map.setFeatureState({ source:'lots-final', id: mapIndex }, { hover:true }); } catch {}
      window.hoveredId = mapIndex;
    }

    // List center/highlight
    const num = extractLotNumber(lotName);
    const baseIndex = baseLots.findIndex(b => b.number === num);
    if (baseIndex !== -1) {
      if (scroll) {
        // use your existing helper if present
        if (typeof scrollToBaseIndex === 'function') scrollToBaseIndex(baseIndex, true);
      } else {
        const actualIndex = baseIndex + (window.cloneCount ?? 5);
        const row = document.querySelector(`.info-row[data-index="${actualIndex}"]`);
        if (row) {
          document.querySelectorAll('.info-row').forEach(r => r.classList.remove('active','center'));
          row.classList.add('active','center');
        }
      }
    }

    // Button color reflects current state
    const lot = lotData[mapIndex];
    const state = normalize(lot?.availability || 'available');
    btn.classList.remove('sold','featured');
    if (state === 'sold') btn.classList.add('sold');
    if (state === 'featured') btn.classList.add('featured');
  }

  // Keep button color synced when UI changes
  function syncButtonToCurrentSelection() {
    const sel = getSelectedLot();
    const name = sel?.lotName ?? selectedLotName;
    if (!name) { btn.classList.remove('sold','featured'); return; }
    setSelectedLotByName(name, { scroll:false });
  }

  // --- local data updates (optimistic) ---
function applyAvailabilityLocal(lotName, state) {
  const norm = (state ?? '').toString().toLowerCase();

  const idx = lotData.findIndex(l => l.name === lotName);
  if (idx !== -1) {
    lotData[idx].availability = state;            // keep whatever casing you want to store
    lotData[idx].featured = (norm === 'featured'); // boolean stays correct
  }

  const num = extractLotNumber(lotName);
  const bi = baseLots.findIndex(b => b.number === num);
  if (bi !== -1) baseLots[bi].availability = state;

  lots.forEach(l => { if (l.number === num) l.availability = state; });
}

  // --- layers refresh ---
function refreshFeaturedLayer() {
  const src = map.getSource('featured-lots');
  const feats = lotData
    .filter(l => (l.featured === true) || ((l.availability ?? '').toString().toLowerCase() === 'featured'))
    .map(featuredPolygonFeature);

  if (src) {
    src.setData({ type: 'FeatureCollection', features: feats });
  } else {
    addFeaturedLotsLayer(map);
  }
}

  function refreshSoldLayer() {
    const srcId = 'sold-x';
    const layerId = 'sold-x-layer';
    const soldLots = lotData.filter(l => normalize(l.availability) === 'sold');
    const features = soldLots.flatMap(makeXFeatures);

    if (!map.getSource(srcId)) {
      map.addSource(srcId, { type: 'geojson', data: { type:'FeatureCollection', features }});
      map.addLayer({
        id: layerId, type:'line', source: srcId,
        paint: { 'line-color':'white', 'line-width':1, 'line-opacity':1 }
      });
    } else {
      map.getSource(srcId).setData({ type:'FeatureCollection', features });
    }
  }

  function refreshVisuals() {
    refreshFeaturedLayer();
    refreshSoldLayer();
    if (typeof render === 'function') render();
  }

  // --- auth guard ---
  async function ensureLoggedIn() {
    const session = (await window.supabaseClient?.auth.getSession())?.data?.session;
    return !!(session && session.user);
  }

  // --- main action ---
  async function cycleSelectedLotAvailability() {
    if (!window.supabaseClient) { window.showToaster?.('Supabase no est√° listo.'); return; }
    if (!(await ensureLoggedIn())) { document.getElementById('modal-login-btn')?.click(); return; }

    const sel = getSelectedLot();
    if (!sel) { window.showToaster?.('Selecciona un lote primero.'); return; }

    const i = lotData.findIndex(l => l.name === sel.lotName);
    if (i === -1) return;

    const current = normalize(lotData[i].availability || 'available');
    const next = nextState(current);

    // remember selection and do optimistic update
    selectedLotName = sel.lotName;
    applyAvailabilityLocal(sel.lotName, next);
    // button feedback
    btn.classList.remove('sold','featured');
    if (next === 'sold') btn.classList.add('sold');
    if (next === 'featured') btn.classList.add('featured');

    try {
      const { error } = await window.supabaseClient
        .from('lots')
        .update({ availability: next })
        .eq('lot_name', sel.lotName);
      if (error) throw error;

      const LABELS = { available:'disponible', sold:'vendido', featured:'destacado' };
      window.showToaster?.(`Estado actualizado a "${LABELS[next] || next}".`);
 
      refreshVisuals();
      // ‚úÖ keep same lot selected after DOM/layers refresh
      setSelectedLotByName(selectedLotName, { scroll:false });
    } catch (e) {
      console.error(e);
      window.showToaster?.('No se pudo guardar. Revirtiendo‚Ä¶');
  
      // revert
      applyAvailabilityLocal(sel.lotName, current);
      btn.classList.remove('sold','featured');
      if (current === 'sold') btn.classList.add('sold');
      if (current === 'featured') btn.classList.add('featured');

      refreshVisuals();
      setSelectedLotByName(selectedLotName, { scroll:false });
    }
  }

  // --- wiring ---
  btn.addEventListener('click', cycleSelectedLotAvailability);

  // Keep button/selection in sync on modal changes & scroll
  const obs = new MutationObserver(() => syncButtonToCurrentSelection());
  if ($lotModal) obs.observe($lotModal, { attributes:true, attributeFilter:['class','style'] });

  $modalInfo?.addEventListener('scroll', () => {
    clearTimeout(window.__syncBtnTO);
    window.__syncBtnTO = setTimeout(syncButtonToCurrentSelection, 120);
  });

  // Patch highlightCenter to remember selection automatically
  const origHighlightCenter = window.highlightCenter;
  if (typeof origHighlightCenter === 'function') {
    window.highlightCenter = function(...args) {
      const r = origHighlightCenter.apply(this, args);
      const sel = getSelectedLot();
      if (sel?.lotName) selectedLotName = sel.lotName;
      syncButtonToCurrentSelection();
      return r;
    };
  }

  // Patch showDetailViewForLot to capture selection when opening detail
  const origShowDetail = window.showDetailViewForLot;
  if (typeof origShowDetail === 'function') {
    window.showDetailViewForLot = async function(index, ...rest) {
      const res = await origShowDetail.apply(this, [index, ...rest]);
      try {
        const lot = lots[index];
        const mapData = lotData.find(l => extractLotNumber(l.name) === lot.number);
        if (mapData?.name) selectedLotName = mapData.name;
        syncButtonToCurrentSelection();
      } catch {}
      return res;
    };
  }
 
  // Patch render so selection is restored after list re-render
  const origRender = window.render;
  if (typeof origRender === 'function') {
    window.render = function(...args) {
      const res = origRender.apply(this, args);
      if (selectedLotName) setSelectedLotByName(selectedLotName, { scroll:false });
      return res;
    };
  }
})();


</script>


  

  <script>
(() => {
  'use strict';

  // ===== Namespace GPS FEATURE=====
  const NS = (window.__LL_GPS__ = window.__LL_GPS__ || {});

  // ---- simple event bus
  NS._listeners = {};
  NS.on = function (evt, cb) { (NS._listeners[evt] ||= []).push(cb); };
  NS.emit = function (evt, payload) { (NS._listeners[evt] || []).forEach(fn => { try { fn(payload); } catch {} }); };

  // Config
  NS.lotCenter = NS.lotCenter || [-100.15994, 25.461823];
  NS.maxDistanceMeters = NS.maxDistanceMeters || 1000;

  // State
  NS.gpsWatchId = null;
  NS.lastUserLngLat = null;
  NS.hasInitialFly = false;
  NS.userHeading = null;
  NS.headingListenerAttached = false;
  NS.farAwayTimer = null;
  NS.farWarned = false;
  NS.headingMarker = null;
  NS._onOrientation = null;
  
  // Smoothing (for Android)
  NS.headingSmoothingFactor = 0.15;
  NS.lastSmoothedHeading = null;

  // Utils
  const safeToaster = (msg, duration = 3000) => {
    try { if (typeof window.showToaster === 'function') window.showToaster(msg, duration); } catch {}
  };

  // Distance calculation
  const distanceMeters = (a, b) => {
    const [lng1, lat1] = a, [lng2, lat2] = b;
    const R = 6371000, œÜ1 = lat1 * Math.PI / 180, œÜ2 = lat2 * Math.PI / 180;
    const ŒîœÜ = (lat2 - lat1) * Math.PI / 180, ŒîŒª = (lng2 - lng1) * Math.PI / 180;
    const a_ = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
              Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    return R * 2 * Math.atan2(Math.sqrt(a_), Math.sqrt(1 - a_));
  };

  // Smooth heading
  const smoothHeading = (newHeading) => {
    if (NS.lastSmoothedHeading === null) {
      NS.lastSmoothedHeading = newHeading;
    } else {
      const diff = ((newHeading - NS.lastSmoothedHeading + 540) % 360) - 180;
      NS.lastSmoothedHeading = (NS.lastSmoothedHeading + diff * NS.headingSmoothingFactor) % 360;
    }
    return NS.lastSmoothedHeading;
  };

  // ===== Core Functions =====
  function ensureUserLocationLayers() {
    if (!window.map) return;

    if (!map.getSource('ll-user-location')) {
      map.addSource('ll-user-location', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });
    }

    if (!map.getLayer('ll-user-accuracy')) {
      map.addLayer({
        id: 'll-user-accuracy',
        type: 'circle',
        source: 'll-user-location',
        paint: {
          'circle-radius': ['interpolate', ['linear'], ['zoom'],
            15, ['coalesce', ['get', 'accRadiusZ15'], 2],
            22, ['coalesce', ['get', 'accRadiusZ22'], 500]
          ],
          'circle-color': '#1a73e826',
          'circle-stroke-color': '#1a73e8',
          'circle-stroke-width': 1
        },
        filter: ['==', ['get', 'role'], 'accuracy']
      });
    }

    if (!map.getLayer('ll-user-dot')) {
      map.addLayer({
        id: 'll-user-dot',
        type: 'circle',
        source: 'll-user-location',
        paint: {
          'circle-radius': 8,
          'circle-color': '#4285F4',
          'circle-stroke-color': '#FFFFFF',
          'circle-stroke-width': 2
        },
        filter: ['==', ['get', 'role'], 'point']
      });
    }

    ensureHeadingMarker();
  }

  // Google Maps-style cone (wide part forward, pointy end at dot)
  function ensureHeadingMarker() {
    if (!window.map || NS.headingMarker) return;

    const el = document.createElement('div');
    el.style.width = '70px';
    el.style.height = '50px';
    el.style.pointerEvents = 'none';
    el.style.zIndex = '1000';
    el.innerHTML = `
      <svg viewBox="0 0 70 50" width="70" height="50">
        <!-- Solid wide cone (140¬∞ opening) -->
        <path d="M35 45 L5 5 L65 5 Z" 
              fill="#1a73e8" 
              opacity="0.6"
              stroke="none"/>
      </svg>
    `;

    NS.headingMarker = new mapboxgl.Marker({
      element: el,
      offset: [0, -25],
      anchor: 'center'
    })
      .setRotationAlignment('map')
      .setPitchAlignment('map')
      .setLngLat(NS.lotCenter)
      .addTo(map);
  }

  // Handle compass data (with iOS permission)
  async function ensureHeadingListener() {
    if (NS.headingListenerAttached) return;

    NS._onOrientation = (e) => {
      let rawHeading;
      if (typeof e?.webkitCompassHeading === 'number') {
        rawHeading = e.webkitCompassHeading; // iOS (true north)
      } else if (typeof e?.alpha === 'number') {
        rawHeading = (360 - e.alpha) % 360;   // Android
      } else {
        return;
      }

      NS.userHeading = smoothHeading(rawHeading);
      if (NS.lastUserLngLat) updateUserLocation(NS.lastUserLngLat[0], NS.lastUserLngLat[1]);
    };

    try {
      if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        safeToaster('Tip: enable HTTPS to access compass on iOS', 3500);
      }

      if (window.DeviceOrientationEvent &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        const response = await DeviceOrientationEvent.requestPermission();
        if (response === 'granted') {
          window.addEventListener('deviceorientation', NS._onOrientation, true);
        } else {
          safeToaster('Compass permission denied', 4000);
          return;
        }
      } else if ('ondeviceorientationabsolute' in window) {
        window.addEventListener('deviceorientationabsolute', NS._onOrientation, true);
      } else {
        window.addEventListener('deviceorientation', NS._onOrientation, true);
      }

      NS.headingListenerAttached = true;
    } catch (err) {
      console.warn('Heading listener setup failed:', err);
      safeToaster('Unable to access compass data', 4000);
    }
  }

  function removeHeadingListener() {
    if (!NS.headingListenerAttached) return;
    try {
      window.removeEventListener('deviceorientation', NS._onOrientation, true);
      window.removeEventListener('deviceorientationabsolute', NS._onOrientation, true);
    } catch {}
    NS._onOrientation = null;
    NS.headingListenerAttached = false;
  }

  // Update cone direction
  function updateUserLocation(lng, lat, accuracyMeters = 10) {
    const src = map?.getSource('ll-user-location');
    if (!src) return;

    src.setData({
      type: 'FeatureCollection',
      features: [
        { type: 'Feature', properties: { role: 'point' }, geometry: { type: 'Point', coordinates: [lng, lat] } },
        {
          type: 'Feature',
          properties: {
            role: 'accuracy',
            accRadiusZ15: Math.min(12, Math.max(2, accuracyMeters / 6)),
            accRadiusZ22: Math.min(600, Math.max(50, accuracyMeters * 6))
          },
          geometry: { type: 'Point', coordinates: [lng, lat] }
        }
      ]
    });

    if (NS.headingMarker) {
      NS.headingMarker.setLngLat([lng, lat]);
      NS.headingMarker.setRotation(NS.userHeading || 0);
    }
  }

  // ===== UI Controls =====
  document.addEventListener('DOMContentLoaded', () => {
    const gpsBtn = document.getElementById('gpsButton');
    if (gpsBtn && !gpsBtn.__llBound) {
      gpsBtn.__llBound = true;
      gpsBtn.addEventListener('click', () => {
        if (NS.gpsWatchId == null) startGPS();
        else stopGPS();
      });
    }
  });

  function startGPS() {
    safeToaster('Activating GPS...', 2000);

    if (!navigator.geolocation) {
      safeToaster('Geolocation not supported on this device', 5000);
      return;
    }
    if (!window.map) {
      safeToaster('Please wait - map is still loading', 5000);
      return;
    }

    ensureUserLocationLayers();
    ensureHeadingListener();

    document.getElementById('cameraButton')?.style && (document.getElementById('cameraButton').style.display = 'block');

    if (NS.gpsWatchId !== null) {
      navigator.geolocation.clearWatch(NS.gpsWatchId);
    }

    NS.gpsWatchId = navigator.geolocation.watchPosition(
      (pos) => {
        const { latitude, longitude, accuracy, heading } = pos.coords;
        NS.lastUserLngLat = [longitude, latitude];

        if (!NS._notifiedStart) { NS._notifiedStart = true; NS.emit('gps-start'); }

        if (heading && !NS.userHeading) {
          NS.userHeading = smoothHeading(heading);
        }

        updateUserLocation(longitude, latitude, accuracy);

        if (!NS.hasInitialFly) {
          NS.hasInitialFly = true;
          map.flyTo({
            center: [longitude, latitude],
            zoom: 17,
            speed: 1.2,
            curve: 1.5
          });
          safeToaster('GPS active - tracking your location', 3000);
        }
      },
      (err) => {
        let errorMsg = 'GPS error';
        switch(err.code) {
          case err.PERMISSION_DENIED: errorMsg = 'Please enable location permissions'; break;
          case err.POSITION_UNAVAILABLE: errorMsg = 'Location signal lost'; break;
          case err.TIMEOUT: errorMsg = 'GPS timeout - try moving outdoors'; break;
        }
        stopGPS(errorMsg);
      },
      { enableHighAccuracy: true, maximumAge: 2000, timeout: 10000 }
    );

    NS.gpsWatchId !== null && safeToaster('GPS activated successfully', 2000);
  }

  function stopGPS(reason) {
    if (NS.gpsWatchId) {
      navigator.geolocation.clearWatch(NS.gpsWatchId);
      NS.gpsWatchId = null;
    }

    removeHeadingListener();

    if (map?.getSource('ll-user-location')) {
      map.getSource('ll-user-location').setData({ type:'FeatureCollection', features:[] });
    }

    if (NS.headingMarker) {
      NS.headingMarker.remove();
      NS.headingMarker = null;
    }

    document.getElementById('cameraButton')?.style && (document.getElementById('cameraButton').style.display = 'none');

    NS.lastUserLngLat = null;
    NS.userHeading = null;
    NS.lastSmoothedHeading = null;

    safeToaster(reason || 'GPS stopped');
    NS._notifiedStart = false;
    NS.emit('gps-stop');
  }

})();
</script>
 


<script>
// Function to check authentication status and toggle buttons visibility hide buttons
function toggleAuthButtons(isAuthenticated) {
  const cycleAvailabilityBtn = document.getElementById('cycleAvailabilityBtn');
  const addPinBtn = document.getElementById('addPinBtn');
  const gpsButton = document.getElementById('gpsButton');
  const driveBtn = document.getElementById('driveBtn');
  const editBtn = document.getElementById('editBtn'); // Added editBtn

  console.log('Toggle buttons - Authenticated:', isAuthenticated);
  
  if (cycleAvailabilityBtn) {
    cycleAvailabilityBtn.classList.toggle('hide-button', !isAuthenticated);
  }
  if (addPinBtn) {
    addPinBtn.classList.toggle('hide-button', !isAuthenticated);
  }
  if (gpsButton) {
    gpsButton.classList.toggle('hide-button', !isAuthenticated);
  }
  if (driveBtn) {
    driveBtn.classList.toggle('hide-button', !isAuthenticated);
  }
  if (editBtn) { // Added editBtn condition
    editBtn.classList.toggle('hide-button', !isAuthenticated);
  }
}

// Hide buttons immediately on page load
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded - hiding buttons by default');
  toggleAuthButtons(false);
  
  // Check auth status once Supabase is likely ready
  const checkAuth = setInterval(function() {
    if (window.supabaseClient && typeof window.supabaseClient.auth.getSession === 'function') {
      clearInterval(checkAuth);
      window.supabaseClient.auth.getSession().then(({ data: { session } }) => {
        const isAuthenticated = !!(session && session.user);
        console.log('Initial auth check - Authenticated:', isAuthenticated);
        toggleAuthButtons(isAuthenticated);
      });
    }
  }, 100);
});
  
// Listen for auth changes once Supabase is ready
const setupAuthListener = setInterval(function() {
  if (window.supabaseClient && typeof window.supabaseClient.auth.onAuthStateChange === 'function') {
    clearInterval(setupAuthListener);
    window.supabaseClient.auth.onAuthStateChange((_event, session) => {
      const isAuthenticated = !!(session && session.user);
      console.log('Auth state changed - Authenticated:', isAuthenticated);
      toggleAuthButtons(isAuthenticated);
    });
  }
}, 100);
</script>
 
  

<script>
  //DRIVE NAVIGATION HERE
(() => {
  const DEST_LNG_LAT = [-100.15994, 25.461823]; // [lng, lat] ‚Äî change to your destination

  function openInNativeMaps([lng, lat]) {
    const isApple = /iPad|iPhone|Macintosh/.test(navigator.userAgent);
    // URLs for Google Maps and Apple Maps navigation
    const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=driving&dir_action=navigate`;
    const appleMapsUrl  = `https://maps.apple.com/?daddr=${lat},${lng}&dirflg=d`;
    const url = isApple ? appleMapsUrl : googleMapsUrl;
    window.open(url, '_blank');
  }

  function onDriveClick(e) {
    if (e && e.preventDefault) e.preventDefault();
    openInNativeMaps(DEST_LNG_LAT);
  }

  // Attach event listener to the button
  function bindDriveBtn() {
    const btn = document.getElementById('driveBtn');
    if (!btn || btn.dataset.bound) return;
    btn.addEventListener('click', onDriveClick);
    btn.dataset.bound = '1';
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindDriveBtn);
  } else {
    bindDriveBtn();
  }
})();
</script>

 
 



<script>
// LOT UNIT CONTROLS SORTING (hide sold in all modes)
(() => {
  const modal = document.getElementById('lotModal');
  const unitControls = document.getElementById('unitControls');
  if (!modal || !unitControls) return;

  // Config toggles (set to false if you ever want to show sold in a mode)
  const HIDE_SOLD_IN_NUM   = true;
  const HIDE_SOLD_IN_NAME  = true;
  const HIDE_SOLD_IN_AREA  = true;
  const HIDE_SOLD_IN_PRICE = true;

  let currentMode = null; // Start with no active mode
  const btns = Array.from(unitControls.querySelectorAll('.unit-btn'));

  // Robust sold detector
  function isSold(lot) {
    if (lot.sold === true) return true;
    const fields = [
      lot.availability, lot.status, lot.state,
      lot.availability_status, lot.sale_status, lot.disponibilidad
    ];
    for (const v of fields) {
      if (typeof v === 'string') {
        const s = v.normalize('NFKD').replace(/\p{Diacritic}/gu, '').trim().toLowerCase();
        if (/(^|[^a-z])(sold|vendido|ocupado)([^a-z]|$)/.test(s)) return true;
      }
    }
    return false;
  }

  function sortLots(mode) {
  // Use the current baseLots array (already filtered by fracc)
  if (!Array.isArray(baseLots) || baseLots.length === 0) return;

  // Create a copy to avoid mutating the original
  let set = [...baseLots];

  // Apply sold filtering based on mode (only if needed)
  if (mode === 'num'   && HIDE_SOLD_IN_NUM)   set = set.filter(l => !isSold(l));
  if ((mode === 'name' || mode === 'alpha' || mode === 'alphabet') && HIDE_SOLD_IN_NAME) set = set.filter(l => !isSold(l));
  if (mode === 'area'  && HIDE_SOLD_IN_AREA)  set = set.filter(l => !isSold(l));
  if (mode === 'price' && HIDE_SOLD_IN_PRICE) set = set.filter(l => !isSold(l));

  // Sort
  switch (mode) {
    case 'num':
      set.sort((a, b) => (a.number || 0) - (b.number || 0));
      break;
    case 'name':
    case 'alpha':
    case 'alphabet':
      set.sort((a, b) =>
        String(a.name || '').localeCompare(
          String(b.name || ''),
          undefined,
          { numeric: true, sensitivity: 'base' }
        )
      );
      break;
    case 'area':
      set.sort((a, b) => (parseFloat(b.size)  || 0) - (parseFloat(a.size)  || 0));
      break;
    case 'price':
      set.sort((a, b) => (parseFloat(b.price) || 0) - (parseFloat(a.price) || 0));
      break;
    default:
      return;
  }

  // Update baseLots with the sorted and filtered set
  baseLots = set;
  if (typeof updateLotsArray === 'function') updateLotsArray();
  if (typeof render === 'function') render();

  try {
    if (typeof highlightCenter === 'function') highlightCenter();
    if (typeof updateScrollbar === 'function') updateScrollbar();
  } catch {}

  // ‚úÖ Always scroll to first item after sorting
  if (typeof scrollToBaseIndex === 'function' && baseLots.length) {
    scrollToBaseIndex(0, true);
  }
}


  function setMode(mode) {
    // Remove active class from all buttons
    btns.forEach(b => b.classList.remove('active'));
    
    // If clicking the same mode, toggle it off (back to default order)
    if (currentMode === mode) {
      currentMode = null;
      modal.dataset.mode = '';
      
      // Reset to original order (re-apply fracc filter but no sorting)
      resetToDefaultOrder();
    } else {
      // Set new active mode
      currentMode = mode;
      modal.dataset.mode = mode;
      
      // Add active class to clicked button
      const activeBtn = btns.find(b => b.dataset.mode === mode);
      if (activeBtn) activeBtn.classList.add('active');
      
      sortLots(mode);
    }
  }

  // Function to reset to default order (when fracc changes or mode is toggled off)
  function resetToDefaultOrder() {
    const fracc = (modal.dataset.fracc || '').toString().trim();
    if (Array.isArray(window.baseLotsAll)) {
      baseLots = window.baseLotsAll.filter(l => 
        !fracc || (l.fraccionamiento || '').toString().trim() === fracc
      );
      updateLotsArray();
      if (typeof render === 'function') render();
      if (typeof highlightCenter === 'function') highlightCenter();
      if (typeof updateScrollbar === 'function') updateScrollbar();
    }
  }

  // Public function to reset buttons (call this when fracc changes)
  window.resetUnitButtons = function() {
    currentMode = null;
    modal.dataset.mode = '';
    btns.forEach(btn => btn.classList.remove('active'));
    resetToDefaultOrder();
  };

  btns.forEach(btn => btn.addEventListener('click', () => setMode(btn.dataset.mode)));
})();


</script>
  

  <!-- Temporary Coordinates Button - REMOVE AFTER USE  
<script>
// Add coordinates button after page loads
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(() => {
    const coordBtn = document.createElement('button');
    coordBtn.innerHTML = 'üìå Get Coordinates';
    coordBtn.id = 'coordHelperBtn';
    coordBtn.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 10000;
      background: #ff8400;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 15px;
      font-family: 'Barlow Condensed', sans-serif;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    `;

    coordBtn.addEventListener('click', function() {
      if (window.map && typeof window.map.getCenter === 'function') {
        const center = window.map.getCenter();
        const zoom = window.map.getZoom();
        
        console.log('üéØ CURRENT COORDINATES:', center);
        console.log('üìä CURRENT ZOOM:', zoom);
        
        // Show alert with copy-able coordinates
        alert(`üìç Current Location Coordinates:
Longitude: ${center.lng}
Latitude: ${center.lat}
Zoom: ${zoom}

üìã These coordinates have been copied to clipboard and logged to console.`);

        // Copy to clipboard
        const coordsText = `center: [${center.lng}, ${center.lat}],\nzoom: ${zoom}`;
        navigator.clipboard.writeText(coordsText).then(() => {
          console.log('‚úÖ Coordinates copied to clipboard:', coordsText);
        });
      } else {
        alert('‚ùå Map not ready yet. Wait a few seconds and try again.');
      }
    });

    document.body.appendChild(coordBtn);
  }, 3000); // Wait 3 seconds for map to load
});
</script>
<!-- END Temporary Coordinates Button -->

<script>
(() => {
  const modal = document.getElementById('lotModal');
  if (!modal) return;

  const sync = () => {
    const open =
      modal.classList.contains('show') ||
      modal.classList.contains('expanded') ||
      modal.classList.contains('pin-mode') ||
      modal.classList.contains('info-mode') ||
      modal.classList.contains('lot-mode');
    document.body.classList.toggle('modal-open', open);
  };

  // initial + on any class change
  sync();
  new MutationObserver(sync).observe(modal, { attributes: true, attributeFilter: ['class'] });

  // also catch hard style/display toggles if you ever use them
  const ro = new ResizeObserver(sync);
  ro.observe(modal);
})();
</script>

<script>
(function(){
  function setupCommunitySearchMenu() {
    const searchBtn  = document.getElementById('communitySearchBtn');
    const circleMenu = document.getElementById('communityCircleMenu');
    if (!searchBtn || !circleMenu) return;

    // 1) Config - Now with 4 communities using positions 1, 3, 5, 7
    const communities = [
      { id:'santte2', label:'Santte 2', center:[-100.15994,25.461823], zoom:16.5, fracc:'santte2', position: 1 },
      { id:'santte1', label:'Santte 1', center:[-100.157213, 25.462513],  zoom:16.7, fracc:'santte1', position: 2 },
      { id:'amani-aqua', label:'Amani Aqua', center:[-100.179408,25.437384], zoom:15.65, fracc:'amani-aqua', position: 6 },
      { id:'ca√±adas-vergel', label:'Ca√±adas Vergel', center:[-100.178308,25.441684], zoom:16.6, fracc:'ca√±adas-vergel', position: 7 }
    ];
    const N = 8;                 // Keep 8 positions in the circle
    const baseDeg = 0;           // 0¬∞ rotation
    const zeroAtTop = true;      // 0¬∞ at top 
    const rootStyles = getComputedStyle(document.documentElement);
    const btnPx  = parseFloat(rootStyles.getPropertyValue('--btn')) || 56;
    const diamPx = parseFloat(rootStyles.getPropertyValue('--orbit-diam')) || 160;
    const radius = (diamPx / 2) - (btnPx / 2);

    // 2) Build buttons - create all 8 positions but only make 4 visible
    circleMenu.innerHTML = '';
    
    for (let i = 0; i < N; i++) {
      const b = document.createElement('button');
      b.className = 'community-option';
      b.type = 'button';
      
      // Find if this position should have a visible button
      const community = communities.find(c => c.position === i);
      
      if (community) {
        // This position gets a visible button
        b.dataset.community = community.id;
        b.textContent = community.label;
        b.style.display = 'flex'; // Make visible
      } else {
        // Empty position - hidden
        b.style.display = 'none'; // Hide this position
      }
      
      circleMenu.appendChild(b);

      // Position all buttons (visible and hidden) in the circle
      const step = 360 / N;
      const theta = baseDeg + i*step + (zeroAtTop ? -90 : 0);
      const rad = theta * Math.PI / 180;
      const cx = circleMenu.clientWidth / 2;
      const cy = circleMenu.clientHeight / 2;
      b.style.left = (cx + radius * Math.cos(rad)) + 'px';
      b.style.top  = (cy + radius * Math.sin(rad)) + 'px';

      // Only add click handler to visible buttons
      if (community) {
        b.addEventListener('click', (e) => {
          e.stopPropagation();
          const c = community;
          if (c.center && window.map) {
            map.flyTo({ center: c.center, zoom: c.zoom || 16.5, speed: 1.2, curve: 1.5 });
            const modal = document.getElementById('lotModal');
            if (modal && modal.classList.contains('show')) {
              modal.dataset.fracc = c.fracc || '';
              if (typeof window.resetUnitButtons === 'function') window.resetUnitButtons();
            }
            if (typeof window.showToaster === 'function') showToaster(`Navegando a ${c.label}`);
          }
          circleMenu.classList.remove('active');
          menuActive = false;
        });
      }
    }

    // 3) Toggle open/close
    let menuActive = false;
    searchBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      menuActive = !menuActive;
      circleMenu.classList.toggle('active', menuActive);
    });

    document.addEventListener('click', () => {
      if (!menuActive) return;
      menuActive = false;
      circleMenu.classList.remove('active');
    });

    circleMenu.addEventListener('click', (e) => e.stopPropagation());
  }

  // call after map/layers are ready
  setupCommunitySearchMenu();
})();

</script>
  

<script>
// DEEP LINKING FOR SPECIFIC LOTS - PROPER FRACC-AWARE CLOSE BEHAVIOR
(function() {
  // Wait for everything to be ready
  setTimeout(() => {
    
    function getLotFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('lot');
    }

    // üü¢ GET CURRENT FRACC CENTER BASED ON ACTIVE FILTER
function getCurrentFraccCenter() {
  // üü¢ REUSE existing communities object from your search menu
  const communities = window.communities || {
    'santte1': { center: [-100.157213, 25.462513], zoom: 16.7 },
    'santte2': { center: [-100.15994, 25.461823], zoom: 16.5 },
    'amani-aqua': { center: [-100.179408, 25.437384], zoom: 15.65 },
    'ca√±adas-vergel': { center: [-100.178308, 25.441684], zoom: 16.6 }
  };
  
  const modal = document.getElementById('lotModal');
  let currentFracc = (modal?.dataset.fracc || '').trim().toLowerCase();
  
  // 1. Try current modal fracc
  if (communities[currentFracc]) {
    return communities[currentFracc].center;
  }
  
  // 2. Try most recent selected lot
  if (selectedLots.size > 0) {
    const lastSelected = Array.from(selectedLots).pop();
    const lot = lotData.find(l => l.name === lastSelected);
    if (lot && lot.fraccionamiento) {
      const fracc = lot.fraccionamiento.toLowerCase();
      if (communities[fracc]) {
        return communities[fracc].center;
      }
    }
  }
  
  // 3. Dynamic: Find closest community to current map view
  if (map) {
    const currentCenter = map.getCenter();
    return findClosestCommunityCenter(currentCenter, communities);
  }
  
  // 4. Fallback to first community
  return communities[Object.keys(communities)[0]].center;
}

// üü¢ REUSABLE: Find closest community to any point
function findClosestCommunityCenter(point, communities) {
  let closestFracc = null;
  let closestDistance = Infinity;
  
  Object.keys(communities).forEach(fracc => {
    const communityCenter = communities[fracc].center;
    const distance = turf.distance(
      turf.point([point.lng, point.lat]),
      turf.point(communityCenter),
      { units: 'kilometers' }
    );
    
    if (distance < closestDistance) {
      closestDistance = distance;
      closestFracc = fracc;
    }
  }); 
  
  return communities[closestFracc].center;
}

// üü¢ ADD THIS FUNCTION FOR DYNAMIC ZOOM
function getCurrentFraccZoom() {
  const modal = document.getElementById('lotModal');
  let currentFracc = (modal?.dataset.fracc || '').trim().toLowerCase();
  
  // Match the zoom levels from your communities object
  const zooms = {
    'santte1': 16.7,
    'santte2': 16.5,
    'amani-aqua': 15.65,
    'ca√±adas-vergel': 16.6
  };
  
  return zooms[currentFracc] || (window.innerWidth >= 768 ? 17 : 16.45);
}

    // Open lot from URL on page load
    function openInitialLotModal() {
      const lotName = getLotFromURL();
      if (lotName) {
        console.log('üîó Opening lot from URL:', lotName);
        
        // Try to find the lot - handle different naming formats
        let lot = lotData.find(l => l.name === lotName);
        if (!lot) {
          // Try without "Lot" prefix
          const cleanName = lotName.replace(/^lot/i, '');
          lot = lotData.find(l => extractLotNumber(l.name) === cleanName);
        }
        
        if (lot) {
          console.log('üîó Found lot:', lot.name, 'Center:', lot.center);
          
          // üü¢ WAIT FOR LOT ANIMATION TO COMPLETE BEFORE OPENING MODAL
          const lotAnimationDuration = 20 * 80 + 500 + 200; // groups * delay + fadeDuration + finalDelay
          console.log('üîó Waiting for lot animation to complete:', lotAnimationDuration + 'ms');
          
          setTimeout(() => {
            console.log('üîó Lot animation complete, opening modal...');
            
            // üü¢ COMBINE ZOOM AND MODAL OPENING
            if (lot.center && map) {
              const [lng, lat] = lot.center;
              const isDesktop = window.innerWidth >= 768;
              const xOffset = isDesktop ? 310 : 0;
              const yOffset = isDesktop ? 0 : 180;
              
              // üü¢ OPEN MODAL FIRST (this will trigger the panBy)
              openModal(lot);
              
              // üü¢ THEN ZOOM TO THE LOT (accounting for modal offset)
              setTimeout(() => {
                map.flyTo({
                  center: [lng, lat],
                  zoom: 18.8,
                  speed: 1.2,
                  curve: 1.5,
                  offset: [xOffset, yOffset]
                });
                
                // Wait for zoom to complete, then show detail
                map.once('moveend', () => {
                  console.log('üîó Map zoom completed with modal open');
                  
                  // Show detail view FIRST
                  setTimeout(() => {
                    const baseIndex = baseLots.findIndex(l => l.number === extractLotNumber(lot.name));
                    if (baseIndex !== -1) {
                      // üü¢ HIDE THE PLUS BUTTON
                      const plusButton = document.querySelector('.plus-button');
                      if (plusButton) plusButton.style.display = 'none';
                      
                      // üü¢ SHOW DETAIL VIEW (this will handle dimensions internally)
                      showDetailViewForLot(baseIndex + cloneCount);
                      
                      // üü¢ UPDATE CURRENT LOT INDEX
                      const lotMapIndex = lotData.findIndex(l => l.name === lot.name);
                      if (lotMapIndex !== -1) {
                        currentLotIndex = lotMapIndex;
                        if (hoveredId !== null) {
                          map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
                        }
                        map.setFeatureState({ source: 'lots-final', id: lotMapIndex }, { hover: true });
                        hoveredId = lotMapIndex;
                      }
                    }
                  }, 400);
                });
              }, 100); // Small delay to ensure modal pan starts first
            }
          }, lotAnimationDuration); // Wait for lot animation to finish
        } else {
          console.warn('Lot not found:', lotName);
        }
      }
    }

    // Update URL when selecting lots (use query parameter)
    function updateLotURL(lotName) {
      const url = new URL(window.location);
      url.searchParams.set('lot', lotName);
      window.history.replaceState(null, '', url);
    }

    // Clear lot from URL when closing modal
    function clearLotURL() {
      const url = new URL(window.location);
      url.searchParams.delete('lot');
      window.history.replaceState(null, '', url);
    }

    // üü¢ FIX: PROPER FRACC-AWARE CLOSE BEHAVIOR
    function closeModalWithZoomReset() {
      const modal = document.getElementById('lotModal');
      if (!modal) return;
      
      
       // üî• ADD THIS: Hide 360 viewer when closing modal
  const viewerContainer = document.getElementById('viewer-container');
  if (viewerContainer) {
    viewerContainer.style.display = 'none';
  }
      // Clear URL first
      clearLotURL();
      
      // Remove side length labels
      removeSideLengthLabels();
      
      // Clear map hover state
      if (hoveredId !== null && map && map.getSource('lots-final')) {
        try { 
          map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false }); 
        } catch {}
        hoveredId = null;
      }
      
      // üü¢ GET THE CORRECT FRACC CENTER BASED ON CURRENT VIEW
      const fraccCenter = getCurrentFraccCenter();
      const initialZoom = getCurrentFraccZoom();
      
      if (map) {
        map.flyTo({
          center: fraccCenter, // üü¢ Uses dynamic fracc center
          zoom: initialZoom,
          bearing: 0,
          pitch: 0,
          speed: 1.2,
          curve: 1.5
        });
      }
      
      // Reset modal state
      const wrapper = document.querySelector('.modal-content-wrapper');
      const lotDetails = document.getElementById('lotDetails');
      const backButton = document.getElementById('backButton');
      const headerLotNumber = document.getElementById('headerLotNumber');
      const plusBtn = document.querySelector('.plus-button');
      const bottomPlus = document.querySelector('.bottom-plus-button');
      
      if (wrapper) wrapper.classList.remove('show-details');
      if (lotDetails) {
        lotDetails.classList.remove('active');
        lotDetails.style.display = 'block';
        lotDetails.innerHTML = '';
      }
      if (backButton) backButton.style.display = 'none';
      if (headerLotNumber) headerLotNumber.style.display = 'none';
      if (plusBtn) plusBtn.style.display = 'none';
      if (bottomPlus) bottomPlus.style.display = 'none';
      
      // Hide calendly if open
      const calendlyEl = document.getElementById('calendlyEmbed');
      if (calendlyEl) calendlyEl.style.display = 'none';
      
      // Close modal with animation
      modal.classList.remove('show', 'info-mode', 'pin-mode', 'expanded', 'lot-mode');
      setTimeout(() => { 
        modal.style.display = 'none'; 
        
        // üü¢ SHOW FLOATING BUTTONS AGAIN
        document.getElementById('communitySearchBtn')?.classList.remove('hide');
        document.getElementById('lalalandInfoBtn')?.classList.remove('hide');
      }, 300);
      
      // Reset internal states
      isDetailOpen = false;
      scrollHandlerAttached = true;
    }

    // Handle URL changes - for browser navigation AFTER initial load
    function handleURLChange() {
      const lotName = getLotFromURL();
      if (lotName) {
        const lot = lotData.find(l => l.name === lotName) || 
                   lotData.find(l => extractLotNumber(l.name) === lotName.replace(/^lot/i, ''));
        
        if (lot && lot.center && map) {
          const [lng, lat] = lot.center;
          const isDesktop = window.innerWidth >= 768;
          const xOffset = isDesktop ? 310 : 0;
          const yOffset = isDesktop ? 0 : 180;
          
          const modal = document.getElementById('lotModal');
          const isModalOpen = modal.classList.contains('show');
          
          if (isModalOpen) {
            // üü¢ MODAL IS ALREADY OPEN - JUST UPDATE THE VIEW
            map.flyTo({
              center: [lng, lat],
              zoom: 18.8,
              speed: 1.2,
              curve: 1.5,
              offset: [xOffset, yOffset]
            });
            
            map.once('moveend', () => {
              // üü¢ REMOVE EXISTING LABELS BEFORE SHOWING DETAIL
              removeSideLengthLabels();
              
              // Update detail view if in detail mode
              if (isDetailOpen) {
                const baseIndex = baseLots.findIndex(l => l.number === extractLotNumber(lot.name));
                if (baseIndex !== -1) {
                  const plusButton = document.querySelector('.plus-button');
                  if (plusButton) plusButton.style.display = 'none';
                  
                  const lotMapIndex = lotData.findIndex(l => l.name === lot.name);
                  if (lotMapIndex !== -1) {
                    currentLotIndex = lotMapIndex;
                    if (hoveredId !== null) {
                      map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
                    }
                    map.setFeatureState({ source: 'lots-final', id: lotMapIndex }, { hover: true });
                    hoveredId = lotMapIndex;
                  }
                  
                  showDetailViewForLot(baseIndex + cloneCount, true);
                }
              }
            });
          } else {
            // üü¢ MODAL IS CLOSED - OPEN IT FIRST, THEN ZOOM
            openModal(lot);
            
            setTimeout(() => {
              map.flyTo({
                center: [lng, lat],
                zoom: 18.8,
                speed: 1.2,
                curve: 1.5,
                offset: [xOffset, yOffset]
              });
              
              map.once('moveend', () => {
                // üü¢ REMOVE ANY EXISTING LABELS
                removeSideLengthLabels();
                
                setTimeout(() => {
                  const baseIndex = baseLots.findIndex(l => l.number === extractLotNumber(lot.name));
                  if (baseIndex !== -1) {
                    const plusButton = document.querySelector('.plus-button');
                    if (plusButton) plusButton.style.display = 'none';
                    
                    const lotMapIndex = lotData.findIndex(l => l.name === lot.name);
                    if (lotMapIndex !== -1) {
                      currentLotIndex = lotMapIndex;
                      if (hoveredId !== null) {
                        map.setFeatureState({ source: 'lots-final', id: hoveredId }, { hover: false });
                      }
                      map.setFeatureState({ source: 'lots-final', id: lotMapIndex }, { hover: true });
                      hoveredId = lotMapIndex;
                    }
                    
                    showDetailViewForLot(baseIndex + cloneCount);
                  }
                }, 400);
              });
            }, 100);
          }
        }
      } else {
        // No lot in URL - close modal with zoom reset
        closeModalWithZoomReset();
      }
    }

    // Listen for URL changes
    window.addEventListener('popstate', handleURLChange);

    // üü¢ REPLACE THE CLOSE MODAL FUNCTION
    window.closeModal = closeModalWithZoomReset;

    // Initialize - open lot from URL if present
    openInitialLotModal();

    console.log('üîó Deep linking initialized - fracc-aware close behavior');
  }, 2000);
})();

// Share functionality
function setupShareButton() {
  const shareButton = document.getElementById('shareButton');
  if (!shareButton) return;

  shareButton.addEventListener('click', function() {
    shareCurrentLot();
  });
}

function shareCurrentLot() {
  // Get current lot information
  let lotName = '';
  let lotNumber = '';
  
  // METHOD 1: Try to get from detail view (more reliable)
  const detailContainer = document.querySelector('.lot-details.active');
  if (detailContainer) {
    // Look for the lot number in the detail view
    const lotNumberEl = detailContainer.querySelector('.lote-number');
    if (lotNumberEl) {
      lotNumber = lotNumberEl.textContent.trim();
      
      // Also try to get the ID text if available
      const idText = detailContainer.querySelector('div[style*="font-size: 14px"]');
      if (idText && idText.textContent.includes('ID:')) {
        const idMatch = idText.textContent.match(/ID:\s*(\S+)/);
        if (idMatch) {
          lotName = idMatch[1]; // This should be the full lot name
        }
      }
    }
  }
  
  // METHOD 2: If we have lotNumber but not lotName, try to find it in the data
  if (lotNumber && !lotName) {
    // Search through all lot data to find matching lot
    const foundLot = lotData.find(l => extractLotNumber(l.name) === lotNumber);
    if (foundLot) {
      lotName = foundLot.name;
    }
  }
  
  // METHOD 3: Fallback - use currentLotIndex if available
  if (!lotName && typeof currentLotIndex !== 'undefined' && currentLotIndex !== -1) {
    const currentLot = lotData[currentLotIndex];
    if (currentLot) {
      lotName = currentLot.name;
      lotNumber = extractLotNumber(currentLot.name);
    }
  }
  
  // METHOD 4: Last resort - try to get from centered row in list
  if (!lotName) {
    const centeredRow = document.querySelector('.info-row.center .lote-number');
    if (centeredRow) {
      lotNumber = centeredRow.textContent.trim();
      const foundLot = lotData.find(l => extractLotNumber(l.name) === lotNumber);
      if (foundLot) {
        lotName = foundLot.name;
      }
    }
  }
  
  if (!lotName) {
    console.warn('No lot found to share');
    showToaster('Selecciona un lote para compartir');
    return;
  }
  
  // Create share URL
  const shareUrl = `${window.location.origin}${window.location.pathname}?lot=${encodeURIComponent(lotName)}`;
  const shareText = `Check out Lote ${lotNumber} in Lalaland`;
  
  console.log('üîó Share attempt:', { lotName, lotNumber, shareUrl });
  
  // Rest of your share logic remains the same...
  if (navigator.share) {
    setTimeout(() => {
      navigator.share({
        title: `Lote ${lotNumber} - Lalaland`,
        text: shareText,
        url: shareUrl
      }).then(() => {
        console.log('‚úÖ Share successful');
        showToaster('Shared successfully! üì§');
      }).catch((error) => {
        console.log('‚ùå Share failed or cancelled:', error);
        if (error.name !== 'AbortError') {
          fallbackShare(shareUrl, lotNumber);
        }
      });
    }, 100);
  } else {
    fallbackShare(shareUrl, lotNumber);
  }
}

function fallbackShare(url, lotNumber) {
  // üü¢ IMPROVED FALLBACK WITH BETTER UX
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(url).then(() => {
      showToaster(`Link to Lote ${lotNumber} copied! üìã`);
    }).catch(() => {
      // Clipboard failed, use prompt
      copyViaPrompt(url, lotNumber);
    });
  } else {
    // No clipboard API
    copyViaPrompt(url, lotNumber);
  }
}

function copyViaPrompt(url, lotNumber) {
  const input = document.createElement('input');
  input.value = url;
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  
  try {
    const successful = document.execCommand('copy');
    document.body.removeChild(input);
    if (successful) {
      showToaster(`Link to Lote ${lotNumber} copied! üìã`);
    } else {
      showToaster(`Select and copy this link:\n${url}`);
    }
  } catch (err) {
    document.body.removeChild(input);
    showToaster(`Share this link:\n${url}`);
  }
}

// Initialize share button when page loads
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(setupShareButton, 1000);
});


// Add this function to check current time in Mexico City (Monday-Friday only)
// Add this function to check current time in Mexico City (Monday-Friday only)
function isBusinessHours() {
  const now = new Date();
  
  // Convert to Mexico City time using toLocaleString
  const mexicoCityTime = now.toLocaleString("en-US", {
    timeZone: "America/Mexico_City",
    hour: "2-digit",
    hour12: false,
    weekday: "long"
  });
  
  // Parse the formatted string - it will be like "Monday, 14" or "Friday, 09"
  const [weekday, hourPart] = mexicoCityTime.split(', ');
  const mexicoCityHour = parseInt(hourPart);
  
  console.log('Mexico City time:', { weekday, hour: mexicoCityHour }); // Debug log
  
  // Business hours: Monday-Friday, 8am to 8pm (9-20 in 24h format)
  const isWeekday = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].includes(weekday);
  const isBusinessHour = mexicoCityHour >= 8 && mexicoCityHour < 20;
  
  return isWeekday && isBusinessHour;
}

// Alternative simpler version if the above doesn't work:
function isBusinessHoursSimple() {
  const now = new Date();
  
  // Use UTC methods with Mexico City offset (UTC-6 for CST, UTC-5 for CDT)
  // This is a simplified approach that should work
  const utcHour = now.getUTCHours();
  const utcDay = now.getUTCDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
  
  // Mexico City is UTC-6 (CST) or UTC-5 (CDT)
  // For simplicity, we'll use UTC-6 (you may need to adjust for daylight saving)
  const mexicoCityHour = (utcHour - 6 + 24) % 24;
  
  // Business hours: Monday-Friday (1-5), 8am to 8pm
  const isWeekday = utcDay >= 1 && utcDay <= 5; // Monday to Friday
  const isBusinessHour = mexicoCityHour >= 8 && mexicoCityHour < 20;
  
  console.log('Simple check:', { utcHour, mexicoCityHour, utcDay, isWeekday, isBusinessHour });
  
  return isWeekday && isBusinessHour;
}

// Use the simple version for now to test
function isBusinessHours() {
  return isBusinessHoursSimple();
}

// Function to update header visibility with clock icon
function updateChatHeaderVisibility() {
  const ctaHeaderLabel = document.querySelector('.cta-header-label[style*="color:#ff8400"]');
  
  if (ctaHeaderLabel) {
    const isOpen = isBusinessHours();
    
    if (isOpen) {
      ctaHeaderLabel.innerHTML = `
<svg width="12" height="12" viewBox="0 0 24 24" fill="#ff8400" style="margin-right:4px; vertical-align:middle;">
  <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/>
</svg>
        DISPONIBLE AHORA
      `;
      ctaHeaderLabel.style.visibility = 'visible';
      ctaHeaderLabel.style.opacity = '1';
    } else {
      ctaHeaderLabel.style.visibility = 'hidden';
      ctaHeaderLabel.style.opacity = '0';
    }
  }
}

// Update the button click handler to always open WhatsApp
function setupChatButton() {
  const chatButton = document.getElementById('chatearBtn');
  if (chatButton) {
    chatButton.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      window.open('https://wa.me/5218185261819', '_blank');
    });
  }
}

// Initialize and set up interval to check time
function initChatAvailability() {
  updateChatHeaderVisibility();
  setupChatButton();
  
  // Check every minute to update status
  setInterval(updateChatHeaderVisibility, 60000);
}

// Call this function when your detail view is created
// Add this to your showDetailViewForLot function after creating the CTA section:
function initChatAvailability() {
  updateChatHeaderVisibility();
  setupChatButton();
  
  // Check every minute to update status
  setInterval(updateChatHeaderVisibility, 60000);
}
</script>

<script>
// ===== EDIT MODE FUNCTIONALITY =====
let editMode = false;
let selectedLots = new Set();

// Edit button event listener
document.getElementById('editBtn').addEventListener('click', function() {
    editMode = !editMode;
    
    if (editMode) {
        // Enter edit mode
        this.style.boxShadow = '0 0 0 3px rgba(255,132,0,1)';
        this.style.backgroundColor = '#ff8400';
        showToaster('‚úèÔ∏è Edit mode ON - Click lots to compare');
        console.log('Edit mode ON');
} else {
    // Exit edit mode
    this.style.boxShadow = '';
    this.style.backgroundColor = '#fcfaf3';
    selectedLots.clear();
    removeEditOutlines();
    
    // üü¢ RESTORE original baseLots
    if (window.originalBaseLots) {
        baseLots = window.originalBaseLots;
        updateLotsArray();
        window.originalBaseLots = null; // Clean up
    }
    
    // Restore normal list
    if (isDataLoaded) {
        render();
    }
    showToaster('Edit mode OFF');
    console.log('Edit mode OFF');
}
});

// Edit mode click handler
function handleEditClick(e) {
  if (!editMode) return false;
  
  // üü¢ CHECK IF CLICKING ON MARBLES (NOT LOTS)
  const marbleFeatures = map.queryRenderedFeatures(e.point, { 
    layers: ['marbles-click-layer'] 
  });
  
  if (marbleFeatures.length > 0) {
    // This is a marble click, not a lot click - let the marble handler deal with it
    return false;
  }
  
  console.log('Edit click detected');
  
  // Rest of your existing edit mode logic...
  if (e.features && e.features.length > 0) {
    const feature = e.features[0];
    const lotName = feature.properties.name;
    const lotNumber = extractLotNumber(lotName);
    
    // Toggle selection
    if (selectedLots.has(lotName)) {
      selectedLots.delete(lotName);
      showToaster(`‚ùå Removed ${lotNumber}`);
    } else {
      selectedLots.add(lotName);
      showToaster(`‚úÖ Added ${lotNumber}`);
    }
    
    console.log('Selected lots:', Array.from(selectedLots));
    
    // Update visuals
    updateEditOutlines();
    updateModalList();
    
    // Stop normal modal from opening
    e.preventDefault();
    if (e.originalEvent) {
      e.originalEvent.stopPropagation();
    }
    return true;
  }
  return false;
}

// Update outlines - SIMPLE ORANGE LINES
// Update outlines - WHITE FILL INSTEAD OF ORANGE OUTLINE
function updateEditOutlines() {
    // Remove old outlines
    removeEditOutlines();
    
    if (!map || selectedLots.size === 0) return;
    
    // Add white fill using map layers
    selectedLots.forEach(lotName => {
        const lot = lotData.find(l => l.name === lotName);
        if (lot) {
            // Create a simple source for this lot
            const sourceId = `edit-outline-${lotName}`;
            const layerId = `edit-outline-layer-${lotName}`;
            
            // Remove existing if any
            if (map.getLayer(layerId)) map.removeLayer(layerId);
            if (map.getSource(sourceId)) map.removeSource(sourceId);
            
            // Create source with lot polygon
            const coords = [...lot.coords];
            if (coords[0][0] !== coords[coords.length - 1][0] || 
                coords[0][1] !== coords[coords.length - 1][1]) {
                coords.push(coords[0]);
            }
            
            map.addSource(sourceId, {
                type: 'geojson',
                data: {
                    type: 'Feature',
                    geometry: {
                        type: 'Polygon',
                        coordinates: [coords]
                    }
                }
            });
            
            // Add white fill layer instead of orange outline
            map.addLayer({
                id: layerId,
                type: 'fill',
                source: sourceId,
paint: {
    'fill-color': '#fcfaf3',
    'fill-opacity': 0.4, // Very subtle orange

}
            }, 'lots-final-click'); // Add above existing layers
        }
    });
}

// Remove outlines
function removeEditOutlines() {
    if (!map) return;
    
    try {
        // Get current style
        const style = map.getStyle();
        if (!style || !style.layers) return;
        
        // Remove all edit outline layers and sources safely
        style.layers.forEach(layer => {
            if (layer.id && layer.id.startsWith('edit-outline-layer-')) {
                try {
                    if (map.getLayer(layer.id)) {
                        map.removeLayer(layer.id);
                    }
                } catch (e) {
                    console.log('Could not remove layer:', layer.id);
                }
            }
        });
        
        // Remove sources
        Object.keys(style.sources || {}).forEach(sourceId => {
            if (sourceId.startsWith('edit-outline-')) {
                try {
                    if (map.getSource(sourceId)) {
                        map.removeSource(sourceId);
                    }
                } catch (e) {
                    console.log('Could not remove source:', sourceId);
                }
            }
        });
    } catch (error) {
        console.log('Error removing edit outlines:', error);
    }
}


// Update modal list - FIXED VERSION with multiple communities support
function updateModalList() {
    const modal = document.getElementById('lotModal');
    const modalInfo = document.getElementById('modalInfo');
    
    if (selectedLots.size === 0) {
        if (modal.classList.contains('show')) {
            modalInfo.innerHTML = '<div style="padding:20px; text-align:center; color:#8a8880;">Select lots to compare</div>';
            // Restore normal baseLots if no selections
            if (window.originalBaseLots) {
                baseLots = window.originalBaseLots;
                updateLotsArray();
                window.originalBaseLots = null;
            }
        }
        return;
    }
    
    // Auto-open modal if closed
    if (!modal.classList.contains('show')) {
        openModal(); // Open without specific lot
    }
    
    // Get selected lots data
    const selectedBaseLots = [];
    let uniqueFraccs = new Set(); // üü¢ NEW: Track communities

    selectedLots.forEach(lotName => {
        const lotNumber = extractLotNumber(lotName);
        const baseLot = window.baseLotsAll.find(bl => bl.number === lotNumber);
        if (baseLot) {
            selectedBaseLots.push({...baseLot});
            // üü¢ NEW: Collect all unique communities
            if (baseLot.fraccionamiento) {
                uniqueFraccs.add(baseLot.fraccionamiento);
            }
        }
    });
    
    console.log('Selected base lots:', selectedBaseLots);
    console.log('Unique communities:', Array.from(uniqueFraccs)); // üü¢ NEW: Debug log
    
    if (selectedBaseLots.length > 0) {
        // üü¢ STORE original and REPLACE baseLots completely
        if (!window.originalBaseLots) {
            window.originalBaseLots = [...baseLots];
        }
        
        baseLots = selectedBaseLots;
        updateLotsArray();
        
        // üü¢ NEW: Update header for single or multiple communities
        let headerText;
        if (uniqueFraccs.size === 1) {
            headerText = Array.from(uniqueFraccs)[0].toUpperCase();
        } else if (uniqueFraccs.size > 1) {
            headerText = 'MULTIPLE COMMUNITIES';
        } else {
            headerText = 'COMPARING LOTS';
        }
        
        document.getElementById('headerFracc').textContent = headerText;
        modal.dataset.fracc = 'multiple';
        
        render();
    }
}

// Update outlines on map move
if (map) {
    map.on('move', function() {
        if (editMode && selectedLots.size > 0) {
            // For map layers, they auto-update with map movement
        }
    });
}
</script>

<script>
  // ===== 360 VIEWER UTILITY FUNCTIONS =====
function calculateDistance(a, b) {
  const R = 6371000;
  const dLat = (b[1]-a[1])*Math.PI/180;
  const dLon = (b[0]-a[0])*Math.PI/180;
  const lat1 = a[1]*Math.PI/180, lat2 = b[1]*Math.PI/180;
  const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
  return 2*R*Math.atan2(Math.sqrt(h), Math.sqrt(1-h));
}

function bearingDeg(a, b){
  const toRad=d=>d*Math.PI/180, toDeg=r=>r*180/Math.PI;
  const œÜ1 = toRad(a[1]), œÜ2 = toRad(b[1]);
  const Œª1 = toRad(a[0]), Œª2 = toRad(b[0]);
  const y = Math.sin(Œª2-Œª1)*Math.cos(œÜ2);
  const x = Math.cos(œÜ1)*Math.cos(œÜ2)*Math.cos(Œª2-Œª1) - Math.sin(œÜ1)*Math.sin(œÜ2);
  return (toDeg(Math.atan2(y,x)) + 360) % 360;
}

function angularDiffDeg(a,b){ 
  let d=Math.abs(a-b)%360; 
  return d>180?360-d:d; 
}

function findClosestPointOnSegment(P, A, B){
  const Ax=A[0], Ay=A[1], Bx=B[0], By=B[1], Px=P[0], Py=P[1];
  const ABx=Bx-Ax, ABy=By-Ay, APx=Px-Ax, APy=Py-Ay;
  const ab2 = ABx*ABx + ABy*ABy;
  let t = ab2 ? (APx*ABx + APy*ABy)/ab2 : 0;
  t = Math.max(0, Math.min(1, t));
  const Qx = Ax + ABx*t, Qy = Ay + ABy*t;
  return { point:[Qx,Qy], distance: Math.sqrt(ab2)*t };
}

function findClosestPointOnRoute(point, coordinates){
  let closestPoint=null, minDistance=Infinity, accumulatedDistance=0;
  for (let i=1;i<coordinates.length;i++){
    const A=coordinates[i-1], B=coordinates[i];
    const segLen = calculateDistance(A,B);
    const cps = findClosestPointOnSegment(point, A, B);
    const d = calculateDistance(point, cps.point);
    if (d<minDistance){ minDistance=d; closestPoint={ point: cps.point, distance: accumulatedDistance + cps.distance }; }
    accumulatedDistance += segLen;
  }
  return closestPoint;
}

function destFromBearingDistance(lat, lon, bearingDegVal, distMeters){
  const R=6378137, brng=degToRad(bearingDegVal);
  const œÜ1=degToRad(lat), Œª1=degToRad(lon);
  const œÜ2=Math.asin(Math.sin(œÜ1)*Math.cos(distMeters/R)+Math.cos(œÜ1)*Math.sin(distMeters/R)*Math.cos(brng));
  const Œª2=Œª1+Math.atan2(Math.sin(brng)*Math.sin(distMeters/R)*Math.cos(œÜ1), Math.cos(distMeters/R)-Math.sin(œÜ1)*Math.sin(œÜ2));
  return [radToDeg(Œª2), radToDeg(œÜ2)];
}

function radToDeg(r){ return r*180/Math.PI; }
function degToRad(d){ return d*Math.PI/180; }

// ===== 360 VIEWER INITIALIZATION =====
function initializeViewer() {
  console.log('360 Viewer system ready');
  setupViewerEventListeners();
  loadGPXFromManifest();
}

function initThreeJSViewer() {
  if (viewerInitialized) return;
  
  console.log('üîÑ Initializing Three.js viewer...');
  
  const viewerContainer = document.getElementById('viewer-container');
  const canvas = document.getElementById('canvas');
  
  if (!viewerContainer || !canvas) {
    console.error('‚ùå Viewer container or canvas not found');
    return;
  }

  // Get dimensions with fallbacks
  let width = viewerContainer.clientWidth || canvas.clientWidth || 800;
  let height = viewerContainer.clientHeight || canvas.clientHeight || 600;
  
  
  // Set canvas dimensions
  canvas.width = width;
  canvas.height = height;
  
  scene = new THREE.Scene();
  panoGroup = new THREE.Group();
  scene.add(panoGroup);

  camera = new THREE.PerspectiveCamera(
    currentFov, 
    width / height, 
    0.1, 
    1000
  );
  camera.position.set(0, 0, 0.1);

  renderer = new THREE.WebGLRenderer({
    canvas, 
    antialias: true, 
    alpha: false, 
    powerPreference: 'high-performance'
  });
  
  const dpr = Math.min(window.devicePixelRatio || 4, 4);
  renderer.setPixelRatio(dpr);
  renderer.setSize(width, height, false);
  
  console.log('‚úÖ Three.js initialized successfully');

  viewerInitialized = true;
  
  // Start animation loop
  animateViewer();
}

function animateViewer(){
  if (!viewerInitialized) return;
  requestAnimationFrame(animateViewer);
  updateNavigationRing();
  if (renderer && scene && camera) {
    try {
      renderer.render(scene, camera);
    } catch(e) {}
  }
}

function setupViewerEventListeners(){
  const canvas = document.getElementById('canvas');
  if (!canvas) return;
  
  let isDragging=false, lastX=0, lastY=0;
  let touchStartX = 0, touchStartY = 0;
  let initialDistance = 0;

  // Mouse events
  canvas.addEventListener('mousedown', e=>{
    isDragging=true; lastX=e.clientX; lastY=e.clientY; 
    canvas.style.cursor='grabbing';
    document.body.classList.add('dragging-pano');
  });
  
  canvas.addEventListener('mousemove', e=>{
    if (!isDragging || !sphere) return;
    const dx=e.clientX-lastX, dy=e.clientY-lastY;
    
    sphere.rotation.y -= dx*0.01;
    sphere.rotation.x -= dy*0.01;
    
    currentYaw = sphere.rotation.y; 
    currentPitch = sphere.rotation.x;
    
    lastX=e.clientX; lastY=e.clientY;
    updateNavigationRing(); 
    updateViewCone(); 
    refreshBranchButtons();
  });

  canvas.addEventListener('mouseup', ()=>{
    isDragging=false; 
    setTimeout(()=>{ canvas.style.cursor='grab'; }, 50);
    document.body.classList.remove('dragging-pano');
  });

  canvas.addEventListener('mouseenter', ()=>{ canvas.style.cursor='grab'; });
  canvas.addEventListener('mouseleave', ()=>{ isDragging=false; canvas.style.cursor='default'; });

  canvas.addEventListener('wheel', handleWheelZoom, { passive:false });

  // Touch events
  canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length == 1) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
    if (e.touches.length == 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      initialDistance = Math.sqrt(dx * dx + dy * dy);
    }
  });

  canvas.addEventListener('touchmove', (e) => {
    if (e.touches.length == 1 && sphere) {
      const dx = e.touches[0].clientX - touchStartX;
      const dy = e.touches[0].clientY - touchStartY;

      sphere.rotation.y -= dx * 0.01;
      sphere.rotation.x -= dy * 0.01;

      currentYaw = sphere.rotation.y;
      currentPitch = sphere.rotation.x;

      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;

      updateNavigationRing();
      updateViewCone();
      refreshBranchButtons();
    }

    if (e.touches.length == 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const currentDistance = Math.sqrt(dx * dx + dy * dy);

      if (initialDistance > 0) {
        const zoomChange = initialDistance - currentDistance;
        const zoomSpeed = 2;
        currentFov = Math.max(30, Math.min(120, currentFov + zoomChange * zoomSpeed * 0.1));
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        initialDistance = currentDistance;
        updateViewCone();
      }
    }
  });

  canvas.addEventListener('touchend', () => {
    touchStartX = 0;
    touchStartY = 0;
    initialDistance = 0;
  });
}

function handleWheelZoom(e){
  e.preventDefault(); 
  e.stopPropagation();
  const zoomSpeed = e.deltaMode===0 ? 2 : 60;
  const delta = e.deltaY>0 ? zoomSpeed : -zoomSpeed;
  const old = currentFov;
  currentFov = Math.max(30, Math.min(120, currentFov + delta));
  if (currentFov !== old){
    camera.fov = currentFov; 
    camera.updateProjectionMatrix();
    updateViewCone(); 
    if (renderer) renderer.render(scene, camera);
  }
}

// ===== NAVIGATION CONTROLS =====
function updateNavigationRing(instant = false) {
  const ring = document.querySelector('.navigation-ring');
  const nextBtn = document.getElementById('nextImageBtn');
  const prevBtn = document.getElementById('prevImageBtn');
  const branchBtn = document.getElementById('branchImageBtn');
  if (!ring || !sphere) return;

  const yawDegrees = THREE.MathUtils.radToDeg(currentYaw);
  ring.style.transform = `rotateZ(${-yawDegrees}deg)`;

  const track = getCurrentTrack();
  if (!track || !selectedMarbleId) return;

  const marbleIndex = track.marbles.findIndex(m => m.id === selectedMarbleId);
  const total = track.marbles.length;

  let canForward = false;
  let canBackward = false;
  let canBranch = false;

  if (marbleIndex < total - 1) canForward = true;
  if (marbleIndex > 0) canBackward = true;

  if (marbleIndex > 0 && marbleIndex < total - 1) {
    const fwd = getBestMarbleInDirection(currentYaw);
    const back = getBestMarbleInDirection(currentYaw + Math.PI);
    canForward = !!fwd;
    canBackward = !!back;
  }

  const edges = navGraph.get(selectedMarbleId) || [];
  if (edges.length > 2) {
    canForward = true;
    canBackward = true;
  }

  const isEndpoint = marbleIndex === 0 || marbleIndex === total - 1;
  const totalConnections = edges.length;
  canBranch = (isEndpoint && totalConnections >= 2) || totalConnections > 2;

  const showBranchAtBottom = shouldShowBranchAtBottom();
  if (showBranchAtBottom) {
    ring.classList.add('has-branch');
  } else {
    ring.classList.remove('has-branch');
  }

  nextBtn.disabled = !canForward;
  prevBtn.disabled = !canBackward;
  branchBtn.disabled = !canBranch;

  nextBtn.style.opacity = canForward ? 1 : 0;
  prevBtn.style.opacity = canBackward ? 1 : 0;
  branchBtn.style.opacity = canBranch ? 1 : 0;

  if (instant) {
    ring.style.transition = 'none';
    requestAnimationFrame(() => (ring.style.transition = ''));
  }
}

function shouldShowBranchAtBottom() {
  if (!selectedMarbleId) return false;
  const track = getCurrentTrack();
  if (!track) return false;
  
  const marbleIndex = track.marbles.findIndex(m => m.id === selectedMarbleId);
  const isEndpoint = marbleIndex === 0 || marbleIndex === track.marbles.length - 1;
  
  if (!isEndpoint) return false;
  
  const edges = navGraph.get(selectedMarbleId) || [];
  const normalConnectionIndex = marbleIndex === 0 ? 1 : marbleIndex - 1;
  const normalConnectionMarble = track.marbles[normalConnectionIndex];
  
  const alternativeConnections = edges.filter(edge => {
    return edge.toMarbleId !== normalConnectionMarble?.id;
  });
  
  return alternativeConnections.length > 0;
}

function getBestMarbleInDirection(directionRad){
  if (!selectedMarbleId) return null;
  const opts = getFacingOptions(selectedMarbleId, directionRad, 1);
  if (!opts.length) return null;
  const track = getCurrentTrack();
  const target = track.marbles.find(m=>m.id===opts[0].toMarbleId);
  return target ? { index: target.index, distance: opts[0].distanceM } : null;
}

function getFacingOptions(marbleId, currentYawRad, maxOptions=3){
  const edges = navGraph.get(marbleId) || [];
  const yawDeg = (THREE.MathUtils.radToDeg(currentYawRad) + 360) % 360;

  return edges.map(e => {
    const angleToView = angularDiffDeg(yawDeg, e.bearingDeg);
    let score = angleToView;

    if (lastHopBearingDeg != null) {
      const continueDiff = angularDiffDeg(lastHopBearingDeg, e.bearingDeg);
      score += continueDiff * 0.3;
    }

    const targetTrackId = [...allTracks.entries()]
      .find(([tid, tr]) => tr.marbles.some(m => m.id === e.toMarbleId))?.[0];
    const currentTrackId = getCurrentTrack()?.id;
    const sameTrack = targetTrackId === currentTrackId;

    if (sameTrack && e.distanceM < 8) {
      score += 20;
    } else {
      score += e.distanceM * 0.001;
    }

    return { ...e, angleToView, score };
  })
  .sort((a,b)=>a.score-b.score)
  .slice(0, maxOptions);
}

// ===== GPX LOADING AND MARBLE MANAGEMENT =====
async function loadGPXFromManifest() {
  try {
    const MANIFEST_URL = FRAMES_BASE + 'index.json';
    const res = await fetch(MANIFEST_URL, { cache: 'no-store' });
    if (!res.ok) { 
      console.log('No predefined tracks found'); 
      return; 
    }

    const manifest = await res.json();

    // Load yawfix mapping
    window.yawFixesByFile = manifest.yawfixes || {};
    console.log("Yaw fixes loaded:", window.yawFixesByFile);

    // Get GPX files from manifest
    let gpxFiles = [];
    if (manifest.gpxFiles && manifest.gpxFiles.length) gpxFiles = manifest.gpxFiles;
    else if (manifest.files) gpxFiles = manifest.files.filter(f => f.toLowerCase().endsWith('.gpx'));

    if (!gpxFiles.length) { 
      console.log('No GPX files in manifest'); 
      return; 
    }

    let loadedCount = 0;
    for (const gpxFile of gpxFiles) {
      try { 
        await loadSingleGPX(gpxFile); 
        loadedCount++; 
      } catch(e) { 
        console.error('Failed GPX:', gpxFile, e); 
      }
    }

    if (loadedCount > 0 && allTracks.size > 0) {
      const firstTrackId = Array.from(allTracks.keys())[0];
      selectTrack(firstTrackId);
      console.log(`Loaded ${loadedCount} GPX files with marbles`);
    }

  } catch(e) {
    console.error('Error loading manifest:', e);
  }
}

async function loadSingleGPX(filename) {
  const fullPath = filename.startsWith(FRAMES_BASE) ? filename : FRAMES_BASE + filename;
  const response = await fetch(fullPath);
  if (!response.ok) throw new Error(`HTTP ${response.status}`);

  const baseName = filename.split('/').pop();
  const yawFixDeg = window.yawFixesByFile?.[baseName] ?? 0;
  console.log(`Applying yaw fix ${yawFixDeg}¬∞ to ${baseName}`);

  const gpxContent = await response.text();
  parseGPX(gpxContent, baseName, true, yawFixDeg);
}

function parseGPX(gpxContent, fileName, isPredefined=false, yawFixDeg=0) {
  const parser = new DOMParser();
  const gpxDoc = parser.parseFromString(gpxContent, 'text/xml');

  const trkpts = gpxDoc.querySelectorAll('trkpt');
  const pointsWithTime = [];
  trkpts.forEach((trkpt, idx) => {
    const lat = parseFloat(trkpt.getAttribute('lat'));
    const lon = parseFloat(trkpt.getAttribute('lon'));
    const t = trkpt.querySelector('time');
    pointsWithTime.push({
      id: idx,
      coordinates: [lon, lat],
      originalIndex: idx,
      time: t ? t.textContent : null
    });
  });
  if (!pointsWithTime.length) return;

  const trackId = `track-${allTracks.size + 1}`;
  const trackColor = '#4285F4';

  const trackData = {
    id: trackId,
    name: fileName.replace('.gpx',''),
    color: trackColor,
    yawFixDeg: yawFixDeg,
    originalPoints: pointsWithTime,
    activePoints: pointsWithTime.map(p => ({...p})),
    isActive: false,
    isPredefined,
    originalStats: calculateOriginalStatsFromPoints(pointsWithTime),
    marbles: [],
    marbleSpacing: 10
  };

  parseWaypointsFromGPX(gpxDoc, trackData);

  allTracks.set(trackId, trackData);

  rebuildNavGraph();
  updateMarbleDisplay();
  console.log(`Parsed ${fileName} with ${trackData.marbles.length} marbles`);
}

function parseWaypointsFromGPX(gpxDoc, trackData) {
  const waypoints = gpxDoc.querySelectorAll('wpt');
  const coordinates = getDisplayCoordinates(trackData);
  const totalDistance = calculateTotalDistance(coordinates);

  waypoints.forEach((wpt, index) => {
    const lat = parseFloat(wpt.getAttribute('lat'));
    const lon = parseFloat(wpt.getAttribute('lon'));
    const nameEl = wpt.querySelector('name');
    const descEl = wpt.querySelector('desc');
    const timeEl = wpt.querySelector('time');

    const name = nameEl ? nameEl.textContent : `Waypoint_${index+1}`;
    const description = descEl ? descEl.textContent : '';
    const time = timeEl ? timeEl.textContent : null;

    const marble = {
      id: Date.now() + index + Math.random(),
      index: trackData.marbles.length,
      position: [lon, lat],
      distanceAlongRoute: 0,
      isLocked: false,
      isFixed: false,
      assignedImage: extractImageIndexFromWaypoint(name, description),
      isWaypoint: true,
      originalName: name,
      description,
      time
    };

    const closestPoint = findClosestPointOnRoute([lon, lat], coordinates);
    if (closestPoint) marble.distanceAlongRoute = closestPoint.distance;

    trackData.marbles.push(marble);
  });

  trackData.marbles.sort((a,b)=>a.distanceAlongRoute - b.distanceAlongRoute);
  trackData.marbles.forEach((m,i)=>{ m.index = i; });
}

function getDisplayCoordinates(track) {
  return track.activePoints.map(p => p.coordinates);
}

function calculateTotalDistance(points) {
  if (points.length < 2) return 0;
  let sum = 0;
  for (let i=1;i<points.length;i++) sum += calculateDistance(points[i-1], points[i]);
  return sum;
}

function calculateOriginalStatsFromPoints(points){
  const coords = points.map(p=>p.coordinates);
  const timeData = points.map(p=>p.time).filter(Boolean);
  const distance = calculateTotalDistance(coords);
  const duration = calculateDurationFromTimes(timeData);
  const avgSpeed = calculateAverageSpeedFromStats(distance, duration);
  return { distance, duration, avgSpeed, pointCount: points.length };
}

function calculateDurationFromTimes(timeData){
  if (timeData.length < 2) return '0s';
  const start = new Date(timeData[0]), end = new Date(timeData[timeData.length-1]);
  const ms = end - start;
  const h = Math.floor(ms/3600000), m = Math.floor((ms%3600000)/60000), s = Math.floor((ms%60000)/1000);
  if (h>0) return `${h}h ${m}m ${s}s`;
  if (m>0) return `${m}m ${s}s`;
  return `${s}s`;
}

function calculateAverageSpeedFromStats(distanceMeters, durationString){
  if (durationString==='0s' || !distanceMeters) return 0;
  const hMatch = durationString.match(/(\d+)h/), mMatch = durationString.match(/(\d+)m/), sMatch = durationString.match(/(\d+)s/);
  const hours = (hMatch?+hMatch[1]:0) + (mMatch?+mMatch[1]/60:0) + (sMatch?+sMatch[1]/3600:0);
  const km = distanceMeters/1000;
  return hours>0 ? km/hours : 0;
}

function extractImageIndexFromWaypoint(name, description){
  const text = (name + ' ' + description).toLowerCase();
  const m1 = text.match(/image[^\d]*(\d+)/); if (m1) return parseInt(m1[1])-1;
  const m2 = text.match(/photo[^\d]*(\d+)/); if (m2) return parseInt(m2[1])-1;
  const m3 = name?.match(/(\d+)$/); if (m3) return parseInt(m3[1])-1;
  return null;
}

// ===== TRACK AND MARBLE SELECTION =====
function selectTrack(trackId){
  if (currentTrackId && allTracks.has(currentTrackId)) {
    allTracks.get(currentTrackId).isActive = false;
  }
  
  currentTrackId = trackId;
  const track = allTracks.get(trackId);
  track.isActive = true;

  updateMarbleDisplay();
  load360Images();
  console.log(`Selected track: ${track.name}`);
}

function selectTrackWithoutMapReset(trackId){
  if (currentTrackId && allTracks.has(currentTrackId)) {
    allTracks.get(currentTrackId).isActive = false;
  }
  
  currentTrackId = trackId;
  const track = allTracks.get(trackId);
  track.isActive = true;

  resetViewerOrientationForTrack(track);
  updateMarbleDisplay();

  if (viewConeMarker){ 
    viewConeMarker.remove(); 
    viewConeMarker = null; 
  }
  
  updateNavigationRing(true);
  updateViewCone();
  load360Images();
  
  console.log(`Switched to track: ${track.name} - ${track.marbles.length} marbles`);
}

function resetViewerOrientationForTrack(track) {
  if (!track || !panoGroup) return;
  
  currentYaw = 0;
  currentPitch = 0;
  
  if (panoGroup) {
    panoGroup.rotation.y = currentYaw;
    panoGroup.rotation.x = currentPitch;
  }
  
  lastHopBearingDeg = null;
  console.log(`Orientation reset for track: ${track.name}`);
}

function getCurrentTrack(){ 
  return currentTrackId ? allTracks.get(currentTrackId) : null; 
}

function selectMarble(marbleId){
  const prevSelected = selectedMarbleId;
  selectedMarbleId = marbleId;

  const track = getCurrentTrack();
  if (!track) return;

  // Update last hop bearing for navigation
  if (prevSelected){
    const prev = track.marbles.find(m=>m.id===prevSelected);
    const curr = track.marbles.find(m=>m.id===marbleId);
    if (prev && curr) {
      lastHopBearingDeg = bearingDeg(prev.position, curr.position);
    }
  }

  updateMarbleDisplay();
  updateViewCone();
  refreshBranchButtons();
  console.log(`Selected marble: ${marbleId}`);
}

function deselectMarble(){
  selectedMarbleId = null;
  updateMarbleDisplay();
  hideViewCone();
}

// ===== NAVIGATION GRAPH =====
function rebuildNavGraph(){
  navGraph.clear();
  
  // A) sequential edges within each track
  allTracks.forEach(track=>{
    const m = track.marbles;
    for (let i=0;i<m.length-1;i++){
      const a=m[i], b=m[i+1];
      const dAB = calculateDistance(a.position, b.position);
      const brAB = bearingDeg(a.position, b.position);
      const brBA = bearingDeg(b.position, a.position);
      
      if (!navGraph.has(a.id)) navGraph.set(a.id, []);
      if (!navGraph.has(b.id)) navGraph.set(b.id, []);
      
      navGraph.get(a.id).push({ toMarbleId:b.id, distanceM:dAB, bearingDeg:brAB });
      navGraph.get(b.id).push({ toMarbleId:a.id, distanceM:dAB, bearingDeg:brBA });
    }
    m.forEach(mm=>{ if(!navGraph.has(mm.id)) navGraph.set(mm.id,[]); });
  });

  // B) junctions across tracks (nearby marbles)
  const all = [];
  allTracks.forEach(track => track.marbles.forEach(m => {
    all.push({trackId:track.id, m});
  }));
  
  const RADIUS_M = 8;
  for (let i=0;i<all.length;i++){
    for (let j=i+1;j<all.length;j++){
      const A=all[i].m, B=all[j].m;
      const d = calculateDistance(A.position, B.position);
      if (d>RADIUS_M) continue;
      
      const brAB = bearingDeg(A.position, B.position);
      const brBA = bearingDeg(B.position, A.position);
      
      if (!navGraph.has(A.id)) navGraph.set(A.id, []);
      if (!navGraph.has(B.id)) navGraph.set(B.id, []);
      
      navGraph.get(A.id).push({ toMarbleId:B.id, distanceM:d, bearingDeg:brAB });
      navGraph.get(B.id).push({ toMarbleId:A.id, distanceM:d, bearingDeg:brBA });
    }
  }

  // C) dedupe keep shortest
  navGraph.forEach((edges, key)=>{
    const byTarget = new Map();
    edges.forEach(e=>{
      const prev = byTarget.get(e.toMarbleId);
      if (!prev || e.distanceM < prev.distanceM) byTarget.set(e.toMarbleId, e);
    });
    navGraph.set(key, Array.from(byTarget.values()));
  });
  
  console.log('Navigation graph rebuilt');
}

// ===== BRANCH NAVIGATION =====
function refreshBranchButtons(){
  const host = document.getElementById('branch-buttons');
  if (!host) return;
  host.innerHTML = '';
  
  if (!selectedMarbleId) return;

  const picks = getFacingOptions(selectedMarbleId, currentYaw);
  picks.forEach((p, idx)=>{
    const btn = document.createElement('button');
    btn.className='small-btn';
    const meters = Math.round(p.distanceM);
    btn.textContent = idx===0 ? `Go ‚Üí (${meters}m)` : `Alt ${idx+1} ‚Üí`;
    btn.onclick = async ()=>{
      const track = getCurrentTrack(); 
      if(!track) return;

      // find target marble across all tracks
      let target=null, targetTrack=null;
      for (const [tid, tr] of allTracks){
        target = tr.marbles.find(m=>m.id===p.toMarbleId);
        if (target){ targetTrack = tr; break; }
      }
      if (!target) return;

      const currentZoom = map.getZoom();
      if (targetTrack.id !== currentTrackId){
        selectTrackWithoutMapReset(targetTrack.id);
        await load360Images();
        selectMarble(target.id);
      } else {
        selectMarble(target.id);
      }

      const current = track.marbles.find(m=>m.id===selectedMarbleId);
      if (current) {
        lastHopBearingDeg = bearingDeg(current.position, target.position);
      }

      if (target.assignedImage != null){
        showMarbleImage(target.id);
      } else {
        map.flyTo({ center: target.position, zoom: currentZoom, duration: 1000 });
        console.log(`Moved to marble ${target.index+1}${targetTrack.id!==currentTrackId?` in ${targetTrack.name}`:''}`);
      }
      updateNavigationRing(true);
    };
    host.appendChild(btn);
  });
}

// Branch button main handler
document.getElementById('branchImageBtn').addEventListener('click', async () => {
  if (!selectedMarbleId) return;
  const edges = navGraph.get(selectedMarbleId) || [];
  const nearby = edges.filter(e => e.distanceM < 10);
  if (!nearby.length) {
    console.log('No nearby marble (<10 m)');
    return;
  }

  // Pick nearest neighbor
  const targetEdge = nearby.sort((a, b) => a.distanceM - b.distanceM)[0];
  let targetTrack = null, targetMarble = null;

  for (const [tid, tr] of allTracks) {
    const m = tr.marbles.find(x => x.id === targetEdge.toMarbleId);
    if (m) { targetTrack = tr; targetMarble = m; break; }
  }
  if (!targetTrack || !targetMarble) return;

  // Perform jump
  if (targetTrack.id !== currentTrackId) {
    selectTrackWithoutMapReset(targetTrack.id);
    await new Promise(r => setTimeout(r, 100));
  }
  
  selectMarble(targetMarble.id);
  if (targetMarble.assignedImage != null) {
    showMarbleImage(targetMarble.id);
  } else {
    map.flyTo({ center: targetMarble.position, zoom: map.getZoom(), duration: 800 });
  }

  console.log(`Jumped to ${targetTrack.name} (${Math.round(targetEdge.distanceM)} m)`);
});

// ===== MARBLE VISUALIZATION =====
function updateMarbleDisplay(){
  const src = map.getSource('marbles');
  if (!src) return;

  const all = [];
  allTracks.forEach((track, trackId)=>{
    track.marbles.forEach((m, index)=>{
      const hasImage = m.assignedImage !== null;
      all.push({
        type:'Feature',
        geometry:{ type:'Point', coordinates: m.position },
        properties:{
          id: m.id,
          trackId,
          index,
          isSelected: (m.id === selectedMarbleId),
          hasImage
        }
      });
    });
  });

  src.setData({ type:'FeatureCollection', features: all });
}

// ===== MAP INTERACTIONS FOR MARBLES =====
function setupMapInteractions(){
  map.on('move', ()=> { if (selectedMarbleId) updateViewCone(); });
  map.on('zoom', ()=> { if (selectedMarbleId) updateViewCone(); });
  
  // üü¢ ADD MARBLE CLICK HANDLERS
  enableMarbleClickOnly();
}

function enableMarbleClickOnly(){
  // Remove existing handlers to avoid duplicates
  map.off('click','marbles-click-layer',handleMarbleClick);
  map.off('click', handleMapClickForDeselect);

  // Add new handlers
  map.on('click','marbles-click-layer', handleMarbleClick);
  map.on('click', handleMapClickForDeselect);
}

function handleMarbleClick(e){
  // üü¢ STOP EVENT PROPAGATION - PREVENT MODAL FROM CLOSING
  e.originalEvent.stopPropagation();
  
  if (!e.features?.length) { 
    deselectMarble(); 
    return; 
  }
  const marbleId = e.features[0].properties.id;
  const trackId = e.features[0].properties.trackId;

  if (trackId !== currentTrackId) {
    selectTrackAndThenMarble(trackId, marbleId);
  } else {
    selectMarble(marbleId);
    showMarbleImage(marbleId);
  }
}

function handleMapClickForDeselect(e){
  const f = map.queryRenderedFeatures(e.point, { layers:['marbles-click-layer'] });
  if (!f.length) deselectMarble();
}

// ===== VIEW CONE SYSTEM =====
function initConeSystem(){
  if (!map.getSource('view-cone')){
    map.addSource('view-cone', {
      type:'geojson',
      data:{ type:'Feature', geometry:{ type:'Polygon', coordinates:[[[0,0],[0,0],[0,0]]] } }
    });
    map.addLayer({ 
      id:'view-cone-fill', 
      type:'fill', 
      source:'view-cone', 
      paint:{ 'fill-color':'#ff8400', 'fill-opacity':0.5 } 
    });
    map.addLayer({ 
      id:'view-cone-outline', 
      type:'line', 
      source:'view-cone', 
      paint:{ 'line-color':'#ff6b6b', 'line-width':2, 'line-opacity':0 } 
    });
  }
}

function hideViewCone(){
  if (map && map.getSource('view-cone')){
    map.getSource('view-cone').setData({ 
      type:'Feature', 
      geometry:{ type:'Polygon', coordinates:[[[0,0],[0,0],[0,0]]] } 
    });
  }
}

function getHorizontalFovDeg(){
  const c=document.getElementById('canvas');
  const aspect = (camera && camera.aspect) || (c && c.clientHeight ? c.clientWidth/c.clientHeight : 16/9);
  const vRad = THREE.MathUtils.degToRad(currentFov);
  const hRad = 2 * Math.atan(Math.tan(vRad/2)*aspect);
  return THREE.MathUtils.radToDeg(hRad);
}

function updateViewCone() {
  if (!map || !map.getSource('view-cone')) return;
  
  const track = getCurrentTrack();
  if (!track || !selectedMarbleId) return;
  
  const marble = track.marbles.find(m => m.id === selectedMarbleId);
  if (!marble) return;

  const currentIndex = track.marbles.findIndex(m => m.id === selectedMarbleId);
  
  // Get path direction
  let pathBearing = track._lastPathBearing || 0;
  if (currentIndex < track.marbles.length - 1) {
    const nextMarble = track.marbles[currentIndex + 1];
    const dx = nextMarble.position[0] - marble.position[0];
    const dy = nextMarble.position[1] - marble.position[1];
    pathBearing = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
  } else if (currentIndex > 0) {
    const prevMarble = track.marbles[currentIndex - 1];
    const dx = marble.position[0] - prevMarble.position[0];
    const dy = marble.position[1] - prevMarble.position[1];
    pathBearing = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
  }

  // Smooth continuity
  if (track._lastPathBearing !== undefined) {
    const diff = pathBearing - track._lastPathBearing;
    if (Math.abs(diff) > 180) {
      pathBearing += diff > 0 ? -360 : 360;
    }
  }
  track._lastPathBearing = pathBearing;

  // Apply user yaw offset
  const userYawDeg = THREE.MathUtils.radToDeg(currentYaw);
  const finalHeading = (pathBearing + userYawDeg + 360) % 360;

  const fovH = getHorizontalFovDeg();
  const radiusMeters = 15;
  
  const ring = makeViewConeRing(
    marble.position[1],
    marble.position[0],
    finalHeading,
    fovH,
    radiusMeters,
    24
  );

  map.getSource('view-cone').setData({
    type: 'Feature',
    geometry: { type: 'Polygon', coordinates: [ring] }
  });
}

function makeViewConeRing(lat, lon, headingDeg, fovDeg, radiusMeters=7, steps=24){
  const half = Math.max(0, Math.min(89, fovDeg/2));
  const start = headingDeg - half, end = headingDeg + half;
  const ring = [[lon,lat]];
  for (let s=0;s<=steps;s++){
    const t=s/steps, brg=start + (end-start)*t;
    ring.push(destFromBearingDistance(lat, lon, brg, radiusMeters));
  }
  ring.push([lon,lat]); 
  return ring;
}

// ===== IMAGE LOADING AND DISPLAY =====
function showImageInViewer(imageUrl, imageData) {
  console.log('üñºÔ∏è Loading image:', imageUrl);
  showViewerLoading('Loading 360¬∞ image...');

  // üü¢ REMOVED: Don't initialize Three.js here anymore
  // if (!viewerInitialized) initThreeJSViewer();

  if (preloadedImages[imageUrl]) {
    console.log('‚úÖ Using preloaded image');
    hideViewerLoading();
    applyImageToSphere(preloadedImages[imageUrl], imageData);
    preloadAdjacentImages();
    return;
  }

  const img = new Image();
  img.crossOrigin = 'Anonymous';
  
  img.onload = function() {
    console.log('‚úÖ Image loaded successfully:', imageUrl);
    preloadedImages[imageUrl] = img;
    hideViewerLoading();
    applyImageToSphere(img, imageData);
    preloadAdjacentImages();
  };
  
  img.onerror = function() {
    console.error('‚ùå Failed to load image:', imageUrl);
    hideViewerLoading();
    showToaster('Failed to load 360 image');
  };
  
  console.log('üì§ Setting image src:', imageUrl);
  img.src = imageUrl + (imageUrl.includes('?')?'&':'?') + 't=' + Date.now();
}

function applyImageToSphere(img, imageData) {
 
  if (sphere) {
    panoGroup.remove(sphere);
    sphere.geometry?.dispose();
    if (sphere.material) {
      sphere.material.map?.dispose();
      sphere.material.dispose();
    }
  }

  const geometry = new THREE.SphereGeometry(500, 60, 40);
  geometry.scale(-1, 1, 1);
  geometry.rotateY(Math.PI);

  // Apply per-track yaw correction
  const track = getCurrentTrack();
  if (track && track.yawFixDeg) {
    geometry.rotateY(THREE.MathUtils.degToRad(track.yawFixDeg));
  }

  const texture = new THREE.Texture(img);
  texture.needsUpdate = true;

  const material = new THREE.MeshBasicMaterial({ map: texture });
  sphere = new THREE.Mesh(geometry, material);
  
  // Apply the current orientation to the sphere
  sphere.rotation.y = currentYaw;
  sphere.rotation.x = currentPitch;
  
  panoGroup.add(sphere);

  updateNavigationRing(true);
}

function preloadAdjacentImages() {
  const prev = currentImageIndex - 1;
  const next = currentImageIndex + 1;
  if (prev >= 0 && !preloadedImages[currentImages[prev].url]) preloadOne(prev);
  if (next < currentImages.length && !preloadedImages[currentImages[next].url]) preloadOne(next);
}

function preloadOne(index) {
  return new Promise(res => {
    const item = currentImages[index]; 
    if (!item) return res();
    const src = item.url; 
    if (preloadedImages[src]) return res();
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.onload = () => { preloadedImages[src] = img; res(); };
    img.onerror = () => res();
    img.src = src;
    if (img.decode) img.decode().catch(() => {});
  });
}

function nextImage() {
  if (currentImageIndex < currentImages.length - 1) {
    currentImageIndex++;
    showImageByIndex(currentImageIndex);
    updateNavigationRing(true);
  }
  updateViewerUI(); 
  refreshBranchButtons();
}

function previousImage() {
  if (currentImageIndex > 0) {
    currentImageIndex--;
    showImageByIndex(currentImageIndex);
    updateNavigationRing(true);
  }
  updateViewerUI(); 
  refreshBranchButtons();
}

function showImageByIndex(index) {
  if (index < 0 || index >= currentImages.length) return;
  const image = currentImages[index];
  if (preloadedImages[image.url]) {
    applyImageToSphere(preloadedImages[image.url], image);
    currentImageIndex = index;
    updateViewerUI();
    highlightMarbleWithImage(index);
  } else {
    showImageInViewer(image.url, image);
    currentImageIndex = index;
    updateViewerUI();
    highlightMarbleWithImage(index);
  }
  preloadAdjacentImages();
}

function updateViewerUI() {
  document.getElementById('time').textContent = `${currentImageIndex+1}/${currentImages.length}`;
  document.getElementById('viewer-info').textContent = `Image ${currentImageIndex+1}/${currentImages.length}`;
}

// Set up navigation button event listeners
document.getElementById('nextImageBtn').addEventListener('click', nextImage);
document.getElementById('prevImageBtn').addEventListener('click', previousImage);
document.getElementById('nextImageBtnTop').addEventListener('click', nextImage);
document.getElementById('prevImageBtnTop').addEventListener('click', previousImage);

function highlightMarbleWithImage(imageIndex) {
  const track = getCurrentTrack(); 
  if (!track) return;
  const marble = track.marbles.find(m => m.assignedImage === imageIndex);
  if (marble) selectMarble(marble.id);
}

function showMarbleImage(marbleId) {
  const track = getCurrentTrack(); 
  if (!track) return;
  const m = track.marbles.find(x => x.id === marbleId); 
  if (!m) return;
  
  if (m.assignedImage == null) {
    console.log('‚ùå Marble has no assigned image:', m);
    showToaster(`Marble ${m.index+1} has no image`);
    return;
  }
  
  console.log('üñºÔ∏è Showing image for marble:', m);
  console.log('üñºÔ∏è Assigned image index:', m.assignedImage);
  
 open360ViewerInModal();

// Wait for Three.js to initialize before showing image
setTimeout(() => {
  showImageByIndex(m.assignedImage);
  refreshBranchButtons();
}, 300); // Wait for Three.js to initialize
}

// Loading overlay functions
function showViewerLoading(msg) {
  const l = document.getElementById('viewer-loading'), 
        t = document.getElementById('loading-text');
  if (l && t) { 
    t.textContent = msg; 
    l.style.display = 'block'; 
  }
}

function hideViewerLoading() { 
  const l = document.getElementById('viewer-loading'); 
  if (l) l.style.display = 'none'; 
}

// ===== IMAGE SOURCING =====
async function load360Images() {
  try {
    await createImagesFromFramesFolder();
    if (currentImages.length > 0) {

      startBackgroundPreload(3);
    }
  } catch(e) { 
    console.error(e);
    showToaster('Error loading 360 images');
  }
}
  
async function createImagesFromFramesFolder() {
  currentImages = []; 
  currentImageIndex = -1;
  const track = getCurrentTrack(); 
  if (!track) { 
    showToaster('No track selected'); 
    return; 
  }
  const gpxName = (track.name || '').replace(/\.[^.]+$/, '');
  if (!gpxName) { 
    showToaster('GPX name missing'); 
    return; 
  }

  const requiredStartLC = (gpxName + '-').toLowerCase();

  let list;
  try {
    const res = await fetch(FRAMES_BASE + 'index.json', { cache: 'no-store' });
    if (!res.ok) { 
      showToaster('Could not fetch frames index'); 
      return; 
    }
    const data = await res.json();
    list = Array.isArray(data) ? data : Array.isArray(data.files) ? data.files : [];
  } catch(e) { 
    showToaster('Error reading frames manifest'); 
    return; 
  }

  const files = list.map(x => String(x).split('/').pop()).filter(Boolean);
  const matches = files
    .filter(n => n.toLowerCase().startsWith(requiredStartLC))
    .filter(n => /\.(?:jpe?g|png)$/i.test(n))
    .sort((a, b) => a.localeCompare(b));

  if (!matches.length) { 
    showToaster(`No frames for "${gpxName}"`); 
    return; 
  }

  currentImages = matches.map((filename, i) => ({
    url: FRAMES_BASE + filename, 
    index: i, 
    filename, 
    timestamp: filename, 
    sequence: i
  }));
}

// Background preload
function startBackgroundPreload(concurrency = 3) {
  if (currentImages.length <= 1) return;
  const order = buildPreloadOrder(currentImageIndex, currentImages.length);
  runPreloadPool(order, concurrency);
}

function buildPreloadOrder(center, total) {
  const seq = []; 
  for (let step = 1; step < total; step++) { 
    const f = center + step, b = center - step; 
    if (f < total) seq.push(f); 
    if (b >= 0) seq.push(b); 
  }
  return seq;
}

function runPreloadPool(indexes, concurrency) {
  let i = 0;
  const workers = Array.from({length: Math.min(concurrency, indexes.length)}, async () => {
    while (i < indexes.length) { 
      const idx = indexes[i++]; 
      await preloadOne(idx).catch(() => {}); 
    }
  });
  Promise.all(workers).then(() => console.log('Background preload complete'));
}

// ===== MODAL INTEGRATION FUNCTIONS =====
function open360ViewerInModal() {
  const modal = document.getElementById('lotModal');
  const viewerContainer = document.getElementById('viewer-container');
  const contentWrapper = document.querySelector('.modal-content-wrapper');
  const lotDetails = document.getElementById('lotDetails');
  const modalInfo = document.getElementById('modalInfo');
  const calendlyEl = document.getElementById('calendlyEmbed');
  const backButton = document.getElementById('backButton');
  const headerFracc = document.getElementById('headerFracc');
  const headerLotNumber = document.getElementById('headerLotNumber');

  const plusButton = document.querySelector('.plus-button');
  const bottomPlus = document.querySelector('.bottom-plus-button');

  // Hide other modal content
  if (lotDetails) lotDetails.style.display = 'none';
  if (modalInfo) modalInfo.style.display = 'none';
  if (calendlyEl) calendlyEl.style.display = 'none';

  // Show viewer container
  if (viewerContainer) {
    viewerContainer.style.display = 'block';
  }

  // Update modal classes and state
  modal.classList.add('viewer-mode');
  modal.classList.remove('pin-mode', 'info-mode', 'lot-mode');
  
  // Update header
  if (headerFracc) headerFracc.textContent = 'STREET VIEW';
  if (headerLotNumber) headerLotNumber.style.display = 'none';
  
  // Show back button, hide plus buttons
  if (backButton) backButton.style.display = 'flex';
  if (plusButton) plusButton.style.display = 'none';
  if (bottomPlus) bottomPlus.style.display = 'none';

  // Ensure modal is open
  if (!modal.classList.contains('show')) {
    modal.classList.add('show');
    modal.style.display = 'block';
    adjustMapForModal();
  }

  // Update internal state
  isDetailOpen = true;
  
  // Hide floating buttons
  document.getElementById('communitySearchBtn')?.classList.add('hide');
  document.getElementById('lalalandInfoBtn')?.classList.add('hide');

  console.log('360 Viewer opened in modal');
  
  // Wait for layout before initializing viewer
  requestAnimationFrame(() => {
    setTimeout(() => {
      if (!viewerInitialized || !renderer || !scene || !camera) {
        viewerInitialized = false;
        initThreeJSViewer();
      }
    }, 100);
  });
}

function close360ViewerInModal() {
  const modal = document.getElementById('lotModal');
  const viewerContainer = document.getElementById('viewer-container');
  const lotDetails = document.getElementById('lotDetails');
  const modalInfo = document.getElementById('modalInfo');
  const backButton = document.getElementById('backButton');
  const headerLotNumber = document.getElementById('headerLotNumber');
  const headerFracc = document.getElementById('headerFracc');
  const plusButton = document.querySelector('.plus-button');

  // Hide viewer
  if (viewerContainer) viewerContainer.style.display = 'none';
  
  // Show lot list, hide lot details
  if (modalInfo) modalInfo.style.display = '';
  if (lotDetails) lotDetails.style.display = 'none';

  // Update modal classes
  modal.classList.remove('viewer-mode', 'info-mode');
  modal.classList.add('lot-mode');
  
  // Update header back to SANTTE
  if (headerFracc) headerFracc.textContent = 'SANTTE';
  if (headerLotNumber) headerLotNumber.style.display = 'none';
  
  // Hide back button and plus button (list mode doesn't need them)
  if (backButton) backButton.style.display = 'none';
  if (plusButton) plusButton.style.display = 'none';

  // Update internal state
  isDetailOpen = false;
  
  // Show floating buttons
  document.getElementById('communitySearchBtn')?.classList.remove('hide');
  document.getElementById('lalalandInfoBtn')?.classList.remove('hide');

  // Re-arm scrolling + hover (same as back button from detail mode)
  try {
    enableInfiniteScrollbar();
  } catch {}

  try {
    highlightCenter();
    updateScrollbar();
  } catch {}

  // Recenter the list if needed
  if (typeof lastOpenedBaseIndex === 'number') {
    requestAnimationFrame(() => {
      scrollToBaseIndex(lastOpenedBaseIndex, false);
    });
  }

  console.log('360 Viewer closed in modal');
}

// Update closeModal to handle 360 viewer
const originalCloseModal = window.closeModal;
window.closeModal = function() {
  const modal = document.getElementById('lotModal');
  
  // If in viewer mode, just close the viewer, not the whole modal
  if (modal.classList.contains('viewer-mode')) {
    close360ViewerInModal();
    return;
  }
  
  // Otherwise use original closeModal
  if (originalCloseModal) {
    originalCloseModal();
  }
};

// ===== MISSING UTILITY FUNCTIONS =====
function calculateBounds(coordinates) {
  if (!coordinates.length) return null;
  const b = new mapboxgl.LngLatBounds();
  coordinates.forEach(c => b.extend(c));
  return b;
}

// UI status function
function setStatus(msg) { 
  console.log(msg); 
  // Optional: show in your toaster if you want
  // showToaster(msg);
}

async function selectTrackAndThenMarble(trackId, marbleId) {
  if (isSwitchingTrack) return;
  isSwitchingTrack = true;

  const prevTrackId = currentTrackId;
  try {
    selectTrackWithoutMapReset(trackId);
    
    // üîπ Wait for orientation reset and initial UI updates
    await new Promise(r => setTimeout(r, 100));
    
    selectMarble(marbleId);

    const track = getCurrentTrack();
    const marble = track.marbles.find(m => m.id === marbleId);
    if (marble && marble.assignedImage !== null) {
      // üîπ Small additional delay to ensure orientation is fully reset
      await new Promise(r => setTimeout(r, 50));
      showImageByIndex(marble.assignedImage);
    }
 
    console.log(`Switched to ${allTracks.get(trackId).name} and selected marble`);
  } catch (err) {
    console.error('Switch error', err);
    if (prevTrackId) selectTrackWithoutMapReset(prevTrackId);
  } finally {
    isSwitchingTrack = false;
  }
}

function resetViewerState() {
  // Reset 360 viewer globals
  currentTrackId = null;
  selectedMarbleId = null;
  currentImages = [];
  currentImageIndex = -1;
  isSwitchingTrack = false;
  
  // Reset any Three.js scene if needed
  if (renderer) {
    // Clean up Three.js resources if necessary
  }
}
</script>

</body>  
</html>
